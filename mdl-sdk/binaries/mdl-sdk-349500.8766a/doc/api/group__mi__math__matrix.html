<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Matrix Class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__mi__math__matrix.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Matrix Class<div class="ingroups"><a class="el" href="group__mi__math.html">Math API</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A NxM-dimensional matrix class template of fixed dimensions with supporting functions.  
<a href="#details"><span class="morelink">More...</span></a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__mi__math__matrix__struct"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix__struct.html">Internal Storage Classes for Matrices</a></td></tr>
<tr class="memdesc:group__mi__math__matrix__struct"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage class for matrix templates with support for <code>xx</code>, <code>xy</code>, <code>xz</code>, etc., members for appropriate dimensions. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1math_1_1Matrix.html">mi::math::Matrix&lt; T, ROW, COL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NxM-dimensional matrix class template of fixed dimensions.  <a href="classmi_1_1math_1_1Matrix.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab794fd43aa0531960e9d1eb2718ccb8a"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gab794fd43aa0531960e9d1eb2718ccb8a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gab794fd43aa0531960e9d1eb2718ccb8a">mi::math::operator==</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab794fd43aa0531960e9d1eb2718ccb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is elementwise equal to <code>rhs</code>.  <a href="#gab794fd43aa0531960e9d1eb2718ccb8a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gab794fd43aa0531960e9d1eb2718ccb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea1c9e2e9a48353663f5005f7477ddb"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gacea1c9e2e9a48353663f5005f7477ddb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gacea1c9e2e9a48353663f5005f7477ddb">mi::math::operator!=</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gacea1c9e2e9a48353663f5005f7477ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is elementwise not equal to <code>rhs</code>.  <a href="#gacea1c9e2e9a48353663f5005f7477ddb"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gacea1c9e2e9a48353663f5005f7477ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad66c3f2ae0dc6c6b47cc1cfed663f2e9"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gad66c3f2ae0dc6c6b47cc1cfed663f2e9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gad66c3f2ae0dc6c6b47cc1cfed663f2e9">mi::math::operator&lt;</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad66c3f2ae0dc6c6b47cc1cfed663f2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is lexicographically less than <code>rhs</code>.  <a href="#gad66c3f2ae0dc6c6b47cc1cfed663f2e9"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gad66c3f2ae0dc6c6b47cc1cfed663f2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga998be110d7b2e57b479d360615ea4eae"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga998be110d7b2e57b479d360615ea4eae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga998be110d7b2e57b479d360615ea4eae">mi::math::operator&lt;=</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga998be110d7b2e57b479d360615ea4eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is lexicographically less than or equal to <code>rhs</code>.  <a href="#ga998be110d7b2e57b479d360615ea4eae"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga998be110d7b2e57b479d360615ea4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78ad1864b819e3177f590f722bdce3a5"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga78ad1864b819e3177f590f722bdce3a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga78ad1864b819e3177f590f722bdce3a5">mi::math::operator&gt;</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga78ad1864b819e3177f590f722bdce3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is lexicographically greater than <code>rhs</code>.  <a href="#ga78ad1864b819e3177f590f722bdce3a5"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga78ad1864b819e3177f590f722bdce3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bed4bd519c2ca4f64410b3689a29e3a"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga7bed4bd519c2ca4f64410b3689a29e3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga7bed4bd519c2ca4f64410b3689a29e3a">mi::math::operator&gt;=</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga7bed4bd519c2ca4f64410b3689a29e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is lexicographically greater than or equal to <code>rhs</code>.  <a href="#ga7bed4bd519c2ca4f64410b3689a29e3a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga7bed4bd519c2ca4f64410b3689a29e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40001a3a194975b1efeecb092a80c88a"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga40001a3a194975b1efeecb092a80c88a"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga40001a3a194975b1efeecb092a80c88a">mi::math::operator+=</a> (Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga40001a3a194975b1efeecb092a80c88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>rhs</code> elementwise to <code>lhs</code> and returns the modified <code>lhs</code>.  <a href="#ga40001a3a194975b1efeecb092a80c88a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga40001a3a194975b1efeecb092a80c88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1fd4fdda9dc9560e4752395812169a6"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gab1fd4fdda9dc9560e4752395812169a6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gab1fd4fdda9dc9560e4752395812169a6">mi::math::operator-=</a> (Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab1fd4fdda9dc9560e4752395812169a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>rhs</code> elementwise from <code>lhs</code> and returns the modified <code>lhs</code>.  <a href="#gab1fd4fdda9dc9560e4752395812169a6"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gab1fd4fdda9dc9560e4752395812169a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5db14e159269bc1b840850af63130af"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gaa5db14e159269bc1b840850af63130af"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gaa5db14e159269bc1b840850af63130af">mi::math::operator+</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaa5db14e159269bc1b840850af63130af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds <code>lhs</code> and <code>rhs</code> elementwise and returns the new result.  <a href="#gaa5db14e159269bc1b840850af63130af"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gaa5db14e159269bc1b840850af63130af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab840cbd8c4c9a40f5a447db674f0e681"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gab840cbd8c4c9a40f5a447db674f0e681"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gab840cbd8c4c9a40f5a447db674f0e681">mi::math::operator-</a> (const Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, ROW, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab840cbd8c4c9a40f5a447db674f0e681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts <code>rhs</code> elementwise from <code>lhs</code> and returns the new result.  <a href="#gab840cbd8c4c9a40f5a447db674f0e681"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gab840cbd8c4c9a40f5a447db674f0e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70b6e6c0609e435eb6f16c8b5156e5d6"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga70b6e6c0609e435eb6f16c8b5156e5d6"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga70b6e6c0609e435eb6f16c8b5156e5d6">mi::math::operator-</a> (const Matrix&lt; T, ROW, COL &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga70b6e6c0609e435eb6f16c8b5156e5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negates the matrix <code>mat</code> elementwise and returns the new result.  <a href="#ga70b6e6c0609e435eb6f16c8b5156e5d6"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga70b6e6c0609e435eb6f16c8b5156e5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57ea48b0ff953898354aff81a93a3add"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga57ea48b0ff953898354aff81a93a3add"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga57ea48b0ff953898354aff81a93a3add">mi::math::operator*=</a> (Matrix&lt; T, ROW, COL &gt; &amp;lhs, const Matrix&lt; T, COL, COL &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga57ea48b0ff953898354aff81a93a3add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication, <code>lhs</code> times <code>rhs</code>, assigns it to <code>lhs</code>, and returns the modified <code>lhs</code>.  <a href="#ga57ea48b0ff953898354aff81a93a3add"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga57ea48b0ff953898354aff81a93a3add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d856bc557683c427c4726d7b3c6971"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW1, Size COL1, Size ROW2, Size COL2&gt; </td></tr>
<tr class="memitem:ga36d856bc557683c427c4726d7b3c6971"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW1, COL2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga36d856bc557683c427c4726d7b3c6971">mi::math::operator*</a> (const Matrix&lt; T, ROW1, COL1 &gt; &amp;lhs, const Matrix&lt; T, ROW2, COL2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga36d856bc557683c427c4726d7b3c6971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication, <code>lhs</code> times <code>rhs</code>, and returns the new result.  <a href="#ga36d856bc557683c427c4726d7b3c6971"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga36d856bc557683c427c4726d7b3c6971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e928862955ff8c996b1e8a31beccf5"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL, Size DIM&gt; </td></tr>
<tr class="memitem:ga71e928862955ff8c996b1e8a31beccf5"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; T, ROW &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga71e928862955ff8c996b1e8a31beccf5">mi::math::operator*</a> (const Matrix&lt; T, ROW, COL &gt; &amp;mat, const Vector&lt; T, DIM &gt; &amp;vec)</td></tr>
<tr class="memdesc:ga71e928862955ff8c996b1e8a31beccf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the (column) vector <code>vec</code> from the right with the matrix <code>mat</code> and returns the resulting vector.  <a href="#ga71e928862955ff8c996b1e8a31beccf5"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga71e928862955ff8c996b1e8a31beccf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06f62639757631fb6ff2b0a66749b8f8"><td class="memTemplParams" colspan="2">template&lt;Size DIM, typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga06f62639757631fb6ff2b0a66749b8f8"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; T, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga06f62639757631fb6ff2b0a66749b8f8">mi::math::operator*</a> (const Vector&lt; T, DIM &gt; &amp;vec, const Matrix&lt; T, ROW, COL &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga06f62639757631fb6ff2b0a66749b8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the (row) vector <code>vec</code> from the left with the matrix <code>mat</code> and returns the resulting vector.  <a href="#ga06f62639757631fb6ff2b0a66749b8f8"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga06f62639757631fb6ff2b0a66749b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162175bf56841447c897a102b22e3e08"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga162175bf56841447c897a102b22e3e08"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga162175bf56841447c897a102b22e3e08">mi::math::operator*=</a> (Matrix&lt; T, ROW, COL &gt; &amp;mat, T factor)</td></tr>
<tr class="memdesc:ga162175bf56841447c897a102b22e3e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the modified matrix <code>mat</code>.  <a href="#ga162175bf56841447c897a102b22e3e08"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga162175bf56841447c897a102b22e3e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fba9627a8ad99f813d881e41cc0bfc"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:gac6fba9627a8ad99f813d881e41cc0bfc"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gac6fba9627a8ad99f813d881e41cc0bfc">mi::math::operator*</a> (const Matrix&lt; T, ROW, COL &gt; &amp;mat, T factor)</td></tr>
<tr class="memdesc:gac6fba9627a8ad99f813d881e41cc0bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the new result.  <a href="#gac6fba9627a8ad99f813d881e41cc0bfc"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gac6fba9627a8ad99f813d881e41cc0bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d8b32647666770ee86c93a2bac798cf"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga3d8b32647666770ee86c93a2bac798cf"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, ROW, COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga3d8b32647666770ee86c93a2bac798cf">mi::math::operator*</a> (T factor, const Matrix&lt; T, ROW, COL &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga3d8b32647666770ee86c93a2bac798cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the new result.  <a href="#ga3d8b32647666770ee86c93a2bac798cf"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga3d8b32647666770ee86c93a2bac798cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga734bbaafd79c7b94482583db81b9d0e1"><td class="memTemplParams" colspan="2">template&lt;Size NEW_ROW, Size NEW_COL, typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga734bbaafd79c7b94482583db81b9d0e1"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, NEW_ROW, NEW_COL &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga734bbaafd79c7b94482583db81b9d0e1">mi::math::sub_matrix</a> (const Matrix&lt; T, ROW, COL &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga734bbaafd79c7b94482583db81b9d0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper-left sub-matrix of size <code>NEW_ROW</code> times <code>NEW_COL</code>.  <a href="#ga734bbaafd79c7b94482583db81b9d0e1"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga734bbaafd79c7b94482583db81b9d0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga323b1112f90d125bed53f5bd268a5467"><td class="memTemplParams" colspan="2">template&lt;typename T , Size ROW, Size COL&gt; </td></tr>
<tr class="memitem:ga323b1112f90d125bed53f5bd268a5467"><td class="memTemplItemLeft" align="right" valign="top">Matrix&lt; T, COL, ROW &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga323b1112f90d125bed53f5bd268a5467">mi::math::transpose</a> (const Matrix&lt; T, ROW, COL &gt; &amp;mat)</td></tr>
<tr class="memdesc:ga323b1112f90d125bed53f5bd268a5467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transpose of the matrix <code>mat</code> by exchanging rows and columns.  <a href="#ga323b1112f90d125bed53f5bd268a5467"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga323b1112f90d125bed53f5bd268a5467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa95a622ce18d8fe5154016808792953"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gafa95a622ce18d8fe5154016808792953"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gafa95a622ce18d8fe5154016808792953">mi::math::transform_point</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const U &amp;point)</td></tr>
<tr class="memdesc:gafa95a622ce18d8fe5154016808792953"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 1D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 1D point <code>point</code>, which includes the translation.  <a href="#gafa95a622ce18d8fe5154016808792953"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gafa95a622ce18d8fe5154016808792953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade1fbe1970aefc170f6f084c52872f7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gade1fbe1970aefc170f6f084c52872f7e"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gade1fbe1970aefc170f6f084c52872f7e">mi::math::transform_point</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 2 &gt; &amp;point)</td></tr>
<tr class="memdesc:gade1fbe1970aefc170f6f084c52872f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 2D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 2D point <code>point</code>, which includes the translation.  <a href="#gade1fbe1970aefc170f6f084c52872f7e"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gade1fbe1970aefc170f6f084c52872f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dff50a869ae1e6c7de06f05247580d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga85dff50a869ae1e6c7de06f05247580d"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga85dff50a869ae1e6c7de06f05247580d">mi::math::transform_point</a> (const Matrix&lt; T, 4, 3 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;point)</td></tr>
<tr class="memdesc:ga85dff50a869ae1e6c7de06f05247580d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D point by applying the full transformation in the 4x3 matrix <code>mat</code> on the 3D point <code>point</code>, which includes the translation.  <a href="#ga85dff50a869ae1e6c7de06f05247580d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga85dff50a869ae1e6c7de06f05247580d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e7304d4cb0036c19fc8a455e2b2e14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga27e7304d4cb0036c19fc8a455e2b2e14"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga27e7304d4cb0036c19fc8a455e2b2e14">mi::math::transform_point</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;point)</td></tr>
<tr class="memdesc:ga27e7304d4cb0036c19fc8a455e2b2e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 3D point <code>point</code>, which includes the translation.  <a href="#ga27e7304d4cb0036c19fc8a455e2b2e14"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga27e7304d4cb0036c19fc8a455e2b2e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fcb20ce8e5bd54902fe0b199e374148"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8fcb20ce8e5bd54902fe0b199e374148"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 4 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga8fcb20ce8e5bd54902fe0b199e374148">mi::math::transform_point</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 4 &gt; &amp;point)</td></tr>
<tr class="memdesc:ga8fcb20ce8e5bd54902fe0b199e374148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 4D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 4D point <code>point</code>, which includes the translation.  <a href="#ga8fcb20ce8e5bd54902fe0b199e374148"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga8fcb20ce8e5bd54902fe0b199e374148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec384a1dc458e4b243190bb819ea608a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaec384a1dc458e4b243190bb819ea608a"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gaec384a1dc458e4b243190bb819ea608a">mi::math::transform_vector</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const U &amp;vector)</td></tr>
<tr class="memdesc:gaec384a1dc458e4b243190bb819ea608a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 1D vector by applying the 1x1 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 1D vector <code>vector</code>, which excludes the translation.  <a href="#gaec384a1dc458e4b243190bb819ea608a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gaec384a1dc458e4b243190bb819ea608a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fbb530541a1a847aab7ded6b32502a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga3fbb530541a1a847aab7ded6b32502a8"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga3fbb530541a1a847aab7ded6b32502a8">mi::math::transform_vector</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 2 &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga3fbb530541a1a847aab7ded6b32502a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 2D vector by applying the 2x2 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 2D vector <code>vector</code>, which excludes the translation.  <a href="#ga3fbb530541a1a847aab7ded6b32502a8"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga3fbb530541a1a847aab7ded6b32502a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17bfc62f171d4dbb9c09694df3b3c4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gab17bfc62f171d4dbb9c09694df3b3c4f"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gab17bfc62f171d4dbb9c09694df3b3c4f">mi::math::transform_vector</a> (const Matrix&lt; T, 3, 3 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;vector)</td></tr>
<tr class="memdesc:gab17bfc62f171d4dbb9c09694df3b3c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D vector by applying the 3x3 matrix <code>mat</code> transformation on the 3D vector <code>vector</code>.  <a href="#gab17bfc62f171d4dbb9c09694df3b3c4f"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gab17bfc62f171d4dbb9c09694df3b3c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae984de575e1df91692e3abbfe1284e7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaae984de575e1df91692e3abbfe1284e7"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#gaae984de575e1df91692e3abbfe1284e7">mi::math::transform_vector</a> (const Matrix&lt; T, 4, 3 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaae984de575e1df91692e3abbfe1284e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D vector by applying the 3x3 linear sub-transformation in the 4x3 matrix <code>mat</code> on the 3D vector <code>vector</code>, which excludes the translation.  <a href="#gaae984de575e1df91692e3abbfe1284e7"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:gaae984de575e1df91692e3abbfe1284e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c06690650ed79d435f3f46b1061462c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga8c06690650ed79d435f3f46b1061462c"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga8c06690650ed79d435f3f46b1061462c">mi::math::transform_vector</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga8c06690650ed79d435f3f46b1061462c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D vector by applying the 3x3 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 3D vector <code>vector</code>, which excludes the translation.  <a href="#ga8c06690650ed79d435f3f46b1061462c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga8c06690650ed79d435f3f46b1061462c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a537f079b098d5e6ec56fa186ccbe6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga30a537f079b098d5e6ec56fa186ccbe6"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga30a537f079b098d5e6ec56fa186ccbe6">mi::math::transform_normal_inv</a> (const Matrix&lt; T, 3, 3 &gt; &amp;inv_mat, const Vector&lt; U, 3 &gt; &amp;normal)</td></tr>
<tr class="memdesc:ga30a537f079b098d5e6ec56fa186ccbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an inverse transformed 3D normal vector by applying the 3x3 transposed linear transformation in the matrix <code>inv_mat</code> on the 3D normal vector <code>normal</code>.  <a href="#ga30a537f079b098d5e6ec56fa186ccbe6"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga30a537f079b098d5e6ec56fa186ccbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7b6af9964b1ddec8a98ef876e35cf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga6a7b6af9964b1ddec8a98ef876e35cf8"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga6a7b6af9964b1ddec8a98ef876e35cf8">mi::math::transform_normal_inv</a> (const Matrix&lt; T, 4, 4 &gt; &amp;inv_mat, const Vector&lt; U, 3 &gt; &amp;normal)</td></tr>
<tr class="memdesc:ga6a7b6af9964b1ddec8a98ef876e35cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an inverse transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in the 4x4 matrix <code>inv_mat</code> on the 3D normal vector <code>normal</code>.  <a href="#ga6a7b6af9964b1ddec8a98ef876e35cf8"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga6a7b6af9964b1ddec8a98ef876e35cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea4c313df74f44aee4a3efdc8af39fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ga0ea4c313df74f44aee4a3efdc8af39fa"><td class="memTemplItemLeft" align="right" valign="top">Vector&lt; U, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__mi__math__matrix.html#ga0ea4c313df74f44aee4a3efdc8af39fa">mi::math::transform_normal</a> (const Matrix&lt; T, 4, 4 &gt; &amp;mat, const Vector&lt; U, 3 &gt; &amp;normal)</td></tr>
<tr class="memdesc:ga0ea4c313df74f44aee4a3efdc8af39fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in the inverse of the 4x4 matrix <code>mat</code> on the 3D normal vector <code>normal</code>.  <a href="#ga0ea4c313df74f44aee4a3efdc8af39fa"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga0ea4c313df74f44aee4a3efdc8af39fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A NxM-dimensional matrix class template of fixed dimensions with supporting functions. </p>
<dl class="section user"><dt>Include File:</dt><dd><code> #include &lt;<a class="el" href="matrix_8h.html" title="A NxM-dimensional matrix class template of fixed dimensions with supporting functions. ">mi/math/matrix.h</a>&gt;</code> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gacea1c9e2e9a48353663f5005f7477ddb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="group__mi__math__vector.html#gad1bd7986517e1f1fd0ff2cc4bb85c333">mi::math::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is elementwise not equal to <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ga36d856bc557683c427c4726d7b3c6971"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW1, Size COL1, Size ROW2, Size COL2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW1,COL2&gt; mi::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW1, COL1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW2, COL2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs matrix multiplication, <code>lhs</code> times <code>rhs</code>, and returns the new result. </p>
<p>The matrices can be of different sizes, but the number of columns of <code>lhs</code> must be equal to the number of rows of <code>rhs</code>. The result matrix has then the size (number of rows of <code>lhs</code>) times (number of columns of <code>rhs</code>). </p>

</div>
</div>
<a class="anchor" id="ga71e928862955ff8c996b1e8a31beccf5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL, Size DIM&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;T,ROW&gt; mi::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the (column) vector <code>vec</code> from the right with the matrix <code>mat</code> and returns the resulting vector. </p>
<p>The result vector has the same dimension as the number of rows in the matrix <code>mat</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vector <code>vec</code> must have the same dimension as the number of columns in the matrix <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga06f62639757631fb6ff2b0a66749b8f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Size DIM, typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;T,COL&gt; mi::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const Vector&lt; T, DIM &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the (row) vector <code>vec</code> from the left with the matrix <code>mat</code> and returns the resulting vector. </p>
<p>The result vector has the same dimension as the number of columns in the matrix <code>mat</code>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The vector <code>vec</code> must have the same dimension as the number of rows in the matrix <code>mat</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6fba9627a8ad99f813d881e41cc0bfc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt; mi::math::operator* </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the new result. </p>

</div>
</div>
<a class="anchor" id="ga3d8b32647666770ee86c93a2bac798cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt; mi::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the new result. </p>

</div>
</div>
<a class="anchor" id="ga57ea48b0ff953898354aff81a93a3add"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt;&amp; mi::math::operator*= </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, COL, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs matrix multiplication, <code>lhs</code> times <code>rhs</code>, assigns it to <code>lhs</code>, and returns the modified <code>lhs</code>. </p>
<p>The matrix <code>lhs</code> must be of size <code>ROW</code> times <code>COL</code>, and the matrix <code>rhs</code> must be of size <code>COL</code> times <code>COL</code>. For mixed size matrix multiplications, see the <a class="el" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">mi::math::operator*()</a> on matrices. </p>

</div>
</div>
<a class="anchor" id="ga162175bf56841447c897a102b22e3e08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt;&amp; mi::math::operator*= </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the matrix <code>mat</code> elementwise with the scalar <code>factor</code> and returns the modified matrix <code>mat</code>. </p>

</div>
</div>
<a class="anchor" id="gaa5db14e159269bc1b840850af63130af"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt; mi::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds <code>lhs</code> and <code>rhs</code> elementwise and returns the new result. </p>

</div>
</div>
<a class="anchor" id="ga40001a3a194975b1efeecb092a80c88a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, ROW, COL &gt; &amp; mi::math::operator+= </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds <code>rhs</code> elementwise to <code>lhs</code> and returns the modified <code>lhs</code>. </p>

</div>
</div>
<a class="anchor" id="gab840cbd8c4c9a40f5a447db674f0e681"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt; mi::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts <code>rhs</code> elementwise from <code>lhs</code> and returns the new result. </p>

</div>
</div>
<a class="anchor" id="ga70b6e6c0609e435eb6f16c8b5156e5d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,ROW,COL&gt; mi::math::operator- </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Negates the matrix <code>mat</code> elementwise and returns the new result. </p>

</div>
</div>
<a class="anchor" id="gab1fd4fdda9dc9560e4752395812169a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt; T, ROW, COL &gt; &amp; mi::math::operator-= </td>
          <td>(</td>
          <td class="paramtype">Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts <code>rhs</code> elementwise from <code>lhs</code> and returns the modified <code>lhs</code>. </p>

</div>
</div>
<a class="anchor" id="gad66c3f2ae0dc6c6b47cc1cfed663f2e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::math::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is lexicographically less than <code>rhs</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mi_def_lexicographic_order.html">Definition: Lexicographic order and comparison</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga998be110d7b2e57b479d360615ea4eae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::math::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is lexicographically less than or equal to <code>rhs</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mi_def_lexicographic_order.html">Definition: Lexicographic order and comparison</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab794fd43aa0531960e9d1eb2718ccb8a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::math::operator== </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is elementwise equal to <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="ga78ad1864b819e3177f590f722bdce3a5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::math::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is lexicographically greater than <code>rhs</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mi_def_lexicographic_order.html">Definition: Lexicographic order and comparison</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bed4bd519c2ca4f64410b3689a29e3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mi::math::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is lexicographically greater than or equal to <code>rhs</code>. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="mi_def_lexicographic_order.html">Definition: Lexicographic order and comparison</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga734bbaafd79c7b94482583db81b9d0e1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Size NEW_ROW, Size NEW_COL, typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,NEW_ROW,NEW_COL&gt; mi::math::sub_matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the upper-left sub-matrix of size <code>NEW_ROW</code> times <code>NEW_COL</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>NEW_ROW</code> &lt;= <code>ROW</code> and <code>NEW_COL</code> &lt;= <code>COL</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0ea4c313df74f44aee4a3efdc8af39fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_normal </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in the inverse of the 4x4 matrix <code>mat</code> on the 3D normal vector <code>normal</code>. </p>
<p>Note that in general, a normal vector is transformed by the transposed inverse matrix (compared to a point transformation) and the inverse is often costly to compute. So, if you wish to compute the inverse once and keep it to transform several normal vectors, you can use the <a class="el" href="group__mi__math__matrix.html#ga30a537f079b098d5e6ec56fa186ccbe6" title="Returns an inverse transformed 3D normal vector by applying the 3x3 transposed linear transformation ...">mi::math::transform_normal_inv()</a> function, which accepts the inverse matrix as argument.</p>
<p>If the linear sub-matrix cannot be inverted, this function returns the unchanged <code>normal</code>.</p>
<p>The normal vector <code>normal</code> is considered to be a row vector, which is multiplied from the left with the transposed upper-left 3x3 sub-matrix of the inverse of <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">normal</td><td>normal vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga30a537f079b098d5e6ec56fa186ccbe6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_normal_inv </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an inverse transformed 3D normal vector by applying the 3x3 transposed linear transformation in the matrix <code>inv_mat</code> on the 3D normal vector <code>normal</code>. </p>
<p>Note that in general, a normal vector is transformed by the transposed inverse matrix (compared to a point transformation). The inverse is often costly to compute, why one typically keeps the inverse stored and this function operates then on the inverse matrix to properly transform normal vectors. If you need to transform only one normal, you can also consider the <a class="el" href="group__mi__math__matrix.html#ga0ea4c313df74f44aee4a3efdc8af39fa" title="Returns a transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in th...">mi::math::transform_normal()</a> function, which includes the inverse computation.</p>
<p>The normal vector <code>normal</code> is considered to be a row vector, which is multiplied from the left with the transposed upper-left 3x3 sub-matrix of <code>inv_mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inv_mat</td><td>inverse 4x4 transformation matrix </td></tr>
    <tr><td class="paramname">normal</td><td>normal vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6a7b6af9964b1ddec8a98ef876e35cf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_normal_inv </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inv_mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an inverse transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in the 4x4 matrix <code>inv_mat</code> on the 3D normal vector <code>normal</code>. </p>
<p>Note that in general, a normal vector is transformed by the transposed inverse matrix (compared to a point transformation). The inverse is often costly to compute, why one typically keeps the inverse stored and this function operates then on the inverse matrix to properly transform normal vectors. If you need to transform only one normal, you can also consider the <a class="el" href="group__mi__math__matrix.html#ga0ea4c313df74f44aee4a3efdc8af39fa" title="Returns a transformed 3D normal vector by applying the 3x3 transposed linear sub-transformation in th...">mi::math::transform_normal()</a> function, which includes the inverse computation.</p>
<p>The normal vector <code>normal</code> is considered to be a row vector, which is multiplied from the left with the transposed upper-left 3x3 sub-matrix of <code>inv_mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inv_mat</td><td>inverse 4x4 transformation matrix </td></tr>
    <tr><td class="paramname">normal</td><td>normal vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa95a622ce18d8fe5154016808792953"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U mi::math::transform_point </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 1D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 1D point <code>point</code>, which includes the translation. </p>
<p>The point <code>point</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">point</td><td>point to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gade1fbe1970aefc170f6f084c52872f7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,2&gt; mi::math::transform_point </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 2D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 2D point <code>point</code>, which includes the translation. </p>
<p>The point <code>point</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">point</td><td>point to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga85dff50a869ae1e6c7de06f05247580d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_point </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D point by applying the full transformation in the 4x3 matrix <code>mat</code> on the 3D point <code>point</code>, which includes the translation. </p>
<p>The point <code>point</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x3 transformation matrix </td></tr>
    <tr><td class="paramname">point</td><td>point to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga27e7304d4cb0036c19fc8a455e2b2e14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_point </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 3D point <code>point</code>, which includes the translation. </p>
<p>The point <code>point</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">point</td><td>point to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8fcb20ce8e5bd54902fe0b199e374148"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,4&gt; mi::math::transform_point </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 4D point by applying the full transformation in the 4x4 matrix <code>mat</code> on the 4D point <code>point</code>, which includes the translation. </p>
<p>The point <code>point</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">point</td><td>point to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaec384a1dc458e4b243190bb819ea608a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">U mi::math::transform_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 1D vector by applying the 1x1 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 1D vector <code>vector</code>, which excludes the translation. </p>
<p>The vector <code>vector</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">vector</td><td>vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3fbb530541a1a847aab7ded6b32502a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,2&gt; mi::math::transform_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 2D vector by applying the 2x2 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 2D vector <code>vector</code>, which excludes the translation. </p>
<p>The vector <code>vector</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">vector</td><td>vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab17bfc62f171d4dbb9c09694df3b3c4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 3, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D vector by applying the 3x3 matrix <code>mat</code> transformation on the 3D vector <code>vector</code>. </p>
<p>The vector <code>vector</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>3x3 transformation matrix </td></tr>
    <tr><td class="paramname">vector</td><td>vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaae984de575e1df91692e3abbfe1284e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D vector by applying the 3x3 linear sub-transformation in the 4x3 matrix <code>mat</code> on the 3D vector <code>vector</code>, which excludes the translation. </p>
<p>The vector <code>vector</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x3 transformation matrix </td></tr>
    <tr><td class="paramname">vector</td><td>vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8c06690650ed79d435f3f46b1061462c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Vector&lt;U,3&gt; mi::math::transform_vector </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, 4, 4 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&lt; U, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a transformed 3D vector by applying the 3x3 linear sub-transformation in the 4x4 matrix <code>mat</code> on the 3D vector <code>vector</code>, which excludes the translation. </p>
<p>The vector <code>vector</code> is considered to be a row vector, which is multiplied from the left with the matrix <code>mat</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>4x4 transformation matrix </td></tr>
    <tr><td class="paramname">vector</td><td>vector to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga323b1112f90d125bed53f5bd268a5467"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , Size ROW, Size COL&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix&lt;T,COL,ROW&gt; mi::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const Matrix&lt; T, ROW, COL &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the transpose of the matrix <code>mat</code> by exchanging rows and columns. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
