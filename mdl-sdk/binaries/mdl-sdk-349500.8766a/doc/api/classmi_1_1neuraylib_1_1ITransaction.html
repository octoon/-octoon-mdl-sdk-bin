<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>mi::neuraylib::ITransaction Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmi_1_1neuraylib_1_1ITransaction.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classmi_1_1neuraylib_1_1ITransaction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mi::neuraylib::ITransaction Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__mi__neuray__database__access.html">Database Access</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A transaction provides a consistent view on the database.  
 <a href="classmi_1_1neuraylib_1_1ITransaction.html#details"><span class="morelink">More...</span></a></p>
<div class="dynheader">
Inheritance diagram for mi::neuraylib::ITransaction:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmi_1_1neuraylib_1_1ITransaction.png" usemap="#mi::neuraylib::ITransaction_map" alt=""/>
  <map id="mi::neuraylib::ITransaction_map" name="mi::neuraylib::ITransaction_map">
<area href="classmi_1_1base_1_1Interface__declare.html" alt="mi::base::Interface_declare&lt; 0x6ca1f0c2, 0xb262, 0x4f09, 0xa6, 0xa5, 0x05, 0xae, 0x14, 0x45, 0xed, 0xfa &gt;" shape="rect" coords="0,56,635,80"/>
<area href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. " alt="mi::base::IInterface" shape="rect" coords="0,0,635,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4ff8152107db238986b364273bceb0c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#aa4ff8152107db238986b364273bceb0c">commit</a> ()=0</td></tr>
<tr class="memdesc:aa4ff8152107db238986b364273bceb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits the transaction.  <a href="#aa4ff8152107db238986b364273bceb0c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aa4ff8152107db238986b364273bceb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e37d6996122404fc0a47bc39190d64a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a3e37d6996122404fc0a47bc39190d64a">abort</a> ()=0</td></tr>
<tr class="memdesc:a3e37d6996122404fc0a47bc39190d64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This operation is not supported.  <a href="#a3e37d6996122404fc0a47bc39190d64a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a3e37d6996122404fc0a47bc39190d64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2166710b6da32edf42b89d1aace235e1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a2166710b6da32edf42b89d1aace235e1">is_open</a> () const =0</td></tr>
<tr class="memdesc:a2166710b6da32edf42b89d1aace235e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether the transaction is open.  <a href="#a2166710b6da32edf42b89d1aace235e1"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a2166710b6da32edf42b89d1aace235e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b8ce71d7a6fea1f59573325dba126c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ad1b8ce71d7a6fea1f59573325dba126c">create</a> (const char *type_name, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> argc=0, const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *argv[]=0)=0</td></tr>
<tr class="memdesc:ad1b8ce71d7a6fea1f59573325dba126c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>type_name</code>.  <a href="#ad1b8ce71d7a6fea1f59573325dba126c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ad1b8ce71d7a6fea1f59573325dba126c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d9ca3eeebb1b34a55e765de72751c6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a87d9ca3eeebb1b34a55e765de72751c6"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a87d9ca3eeebb1b34a55e765de72751c6">create</a> (const char *type_name, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> argc=0, const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *argv[]=0)</td></tr>
<tr class="memdesc:a87d9ca3eeebb1b34a55e765de72751c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>type_name</code>.  <a href="#a87d9ca3eeebb1b34a55e765de72751c6"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a87d9ca3eeebb1b34a55e765de72751c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3b188c45023f86faf2b831d7bf9b9c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:abf3b188c45023f86faf2b831d7bf9b9c"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c">create</a> ()</td></tr>
<tr class="memdesc:abf3b188c45023f86faf2b831d7bf9b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>T</code>.  <a href="#abf3b188c45023f86faf2b831d7bf9b9c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:abf3b188c45023f86faf2b831d7bf9b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0cccf93ff990b7af8d0d0379f7c09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ae1c0cccf93ff990b7af8d0d0379f7c09">store</a> (<a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *db_element, const char *name, <a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">Uint8</a> privacy=<a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a59e2e7bc4226fffe5dabec10d13fe8a9">LOCAL_SCOPE</a>)=0</td></tr>
<tr class="memdesc:ae1c0cccf93ff990b7af8d0d0379f7c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the element <code>db_element</code> in the database under the name <code>name</code> and with the privacy level <code>privacy</code>.  <a href="#ae1c0cccf93ff990b7af8d0d0379f7c09"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae1c0cccf93ff990b7af8d0d0379f7c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adafe2621ae719c43076b79a5677b4934"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934">access</a> (const char *name)=0</td></tr>
<tr class="memdesc:adafe2621ae719c43076b79a5677b4934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the database.  <a href="#adafe2621ae719c43076b79a5677b4934"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:adafe2621ae719c43076b79a5677b4934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e21201f4a43bccd5d842dae34e16e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3b3e21201f4a43bccd5d842dae34e16e"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a3b3e21201f4a43bccd5d842dae34e16e">access</a> (const char *name)</td></tr>
<tr class="memdesc:a3b3e21201f4a43bccd5d842dae34e16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the database.  <a href="#a3b3e21201f4a43bccd5d842dae34e16e"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a3b3e21201f4a43bccd5d842dae34e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35971d023789574ee31dd05768fc7fe1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1">edit</a> (const char *name)=0</td></tr>
<tr class="memdesc:a35971d023789574ee31dd05768fc7fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the database and returns it ready for editing.  <a href="#a35971d023789574ee31dd05768fc7fe1"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a35971d023789574ee31dd05768fc7fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e4b2b958009fa43c679214939bfa4"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a986e4b2b958009fa43c679214939bfa4"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a986e4b2b958009fa43c679214939bfa4">edit</a> (const char *name)</td></tr>
<tr class="memdesc:a986e4b2b958009fa43c679214939bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the database and returns it ready for editing.  <a href="#a986e4b2b958009fa43c679214939bfa4"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a986e4b2b958009fa43c679214939bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c19e2739eb47e51386aff339be2ee09"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a0c19e2739eb47e51386aff339be2ee09">copy</a> (const char *source, const char *target, <a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">Uint8</a> privacy=0)=0</td></tr>
<tr class="memdesc:a0c19e2739eb47e51386aff339be2ee09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a copy of a database element.  <a href="#a0c19e2739eb47e51386aff339be2ee09"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a0c19e2739eb47e51386aff339be2ee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97632e9e40741b788c8c7ef599555789"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a97632e9e40741b788c8c7ef599555789">remove</a> (const char *name, bool only_localized=false)=0</td></tr>
<tr class="memdesc:a97632e9e40741b788c8c7ef599555789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the element with the name <code>name</code> from the database.  <a href="#a97632e9e40741b788c8c7ef599555789"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a97632e9e40741b788c8c7ef599555789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db9733124735032153593b1a6710ebb"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a0db9733124735032153593b1a6710ebb">name_of</a> (const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *db_element) const =0</td></tr>
<tr class="memdesc:a0db9733124735032153593b1a6710ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of a database element.  <a href="#a0db9733124735032153593b1a6710ebb"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a0db9733124735032153593b1a6710ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35439dc05ea91a5f6f67b261f1357062"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35439dc05ea91a5f6f67b261f1357062">get_time_stamp</a> () const =0</td></tr>
<tr class="memdesc:a35439dc05ea91a5f6f67b261f1357062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time stamp describing the current "time".  <a href="#a35439dc05ea91a5f6f67b261f1357062"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a35439dc05ea91a5f6f67b261f1357062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885bf28a2ceb2efb079414fe1ea1e73d"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a885bf28a2ceb2efb079414fe1ea1e73d">get_time_stamp</a> (const char *element) const =0</td></tr>
<tr class="memdesc:a885bf28a2ceb2efb079414fe1ea1e73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the time stamp of the last change of a database element.  <a href="#a885bf28a2ceb2efb079414fe1ea1e73d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a885bf28a2ceb2efb079414fe1ea1e73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6461ac4d7be4211d107ad57a6869ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a5d6461ac4d7be4211d107ad57a6869ca">has_changed_since_time_stamp</a> (const char *element, const char *time_stamp) const =0</td></tr>
<tr class="memdesc:a5d6461ac4d7be4211d107ad57a6869ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether an element has been stored or changed in the database since a given time stamp.  <a href="#a5d6461ac4d7be4211d107ad57a6869ca"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a5d6461ac4d7be4211d107ad57a6869ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691790207395f02b1487e6f98f4a7c11"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a691790207395f02b1487e6f98f4a7c11">get_id</a> () const =0</td></tr>
<tr class="memdesc:a691790207395f02b1487e6f98f4a7c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this transaction.  <a href="#a691790207395f02b1487e6f98f4a7c11"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a691790207395f02b1487e6f98f4a7c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f31ed9390cec1144c01a8347c0072"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1IScope.html">IScope</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ab94f31ed9390cec1144c01a8347c0072">get_scope</a> () const =0</td></tr>
<tr class="memdesc:ab94f31ed9390cec1144c01a8347c0072"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scope of this transaction.  <a href="#ab94f31ed9390cec1144c01a8347c0072"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ab94f31ed9390cec1144c01a8347c0072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470eb1b7674345c4669bd9faff1029d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1IArray.html">IArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a470eb1b7674345c4669bd9faff1029d3">list_elements</a> (const char *root_element, const char *name_pattern=0, const <a class="el" href="classmi_1_1IArray.html">IArray</a> *type_names=0) const =0</td></tr>
<tr class="memdesc:a470eb1b7674345c4669bd9faff1029d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns scene elements of a subgraph originating at a given scene element.  <a href="#a470eb1b7674345c4669bd9faff1029d3"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a470eb1b7674345c4669bd9faff1029d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf6962667197b0806c1bf9c9964a765"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#aecf6962667197b0806c1bf9c9964a765">get_privacy_level</a> (const char *name) const =0</td></tr>
<tr class="memdesc:aecf6962667197b0806c1bf9c9964a765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the privacy level of the element with the name <code>name</code>.  <a href="#aecf6962667197b0806c1bf9c9964a765"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aecf6962667197b0806c1bf9c9964a765"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a59e2e7bc4226fffe5dabec10d13fe8a9"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">mi::Uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a59e2e7bc4226fffe5dabec10d13fe8a9">LOCAL_SCOPE</a> = 255</td></tr>
<tr class="memdesc:a59e2e7bc4226fffe5dabec10d13fe8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symbolic privacy level for the privacy level of the scope of this transaction.  <a href="#a59e2e7bc4226fffe5dabec10d13fe8a9"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a59e2e7bc4226fffe5dabec10d13fe8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x6ca1f0c2, 0xb262, 0x4f09, 0xa6, 0xa5, 0x05, 0xae, 0x14, 0x45, 0xed, 0xfa &gt;</a></td></tr>
<tr class="memitem:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Interface__declare.html">Interface_declare</a>&lt; id1, <br class="typebreak"/>
id2, id3, id4, id5, id6, id7, <br class="typebreak"/>
id8, id9, id10, id11, <br class="typebreak"/>
<a class="el" href="classmi_1_1base_1_1IInterface.html">IInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#aaa2da9cb0b963fed938e3e19dcb912cd">Self</a></td></tr>
<tr class="memdesc:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Own type.  <a href="#aaa2da9cb0b963fed938e3e19dcb912cd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Uuid__t.html">Uuid_t</a>&lt; id1, id2, id3, <br class="typebreak"/>
id4, id5, id6, id7, id8, id9, <br class="typebreak"/>
id10, id11 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#a7ab89c594dc3cbbbb9aeffaf33b72a52">IID</a></td></tr>
<tr class="memdesc:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the interface ID (IID) of this interface.  <a href="#a7ab89c594dc3cbbbb9aeffaf33b72a52"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x6ca1f0c2, 0xb262, 0x4f09, 0xa6, 0xa5, 0x05, 0xae, 0x14, 0x45, 0xed, 0xfa &gt;</a></td></tr>
<tr class="memitem:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#ac18291e29369f959218926e0fe7d1667">compare_iid</a> (const <a class="el" href="structmi_1_1base_1_1Uuid.html">Uuid</a> &amp;iid)</td></tr>
<tr class="memdesc:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the interface ID <code>iid</code> against the interface ID of this interface and of its ancestors.  <a href="#ac18291e29369f959218926e0fe7d1667"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A transaction provides a consistent view on the database. </p>
<p>This view on the database is isolated from changes by other (parallel) transactions. Eventually, each transaction must be either committed or aborted, i.e., all changes become either atomically visible to transactions started afterwards, or not at all.</p>
<p>Transactions are associated with a scope of the database and can be created with <a class="el" href="classmi_1_1neuraylib_1_1IScope.html#ab7f4a9456f8a8ddc53e6279df11a2b45" title="Creates a new transaction associated with this scope. ">mi::neuraylib::IScope::create_transaction()</a>.</p>
<p>Transactions are not thread-safe. If you use a particular transaction from multiple threads, then you have to serialize all transaction uses. This does not only apply to methods of <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>, but all methods that implicitly use the transaction. For example, such a use can happen by methods of DB elements returned from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> or <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> calls, or by objects returned from factories taking the transaction as argument, like <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#acfb3f3619135d5162196851186472dfb" title="Creates a module builder for a given module. ">mi::neuraylib::IMdl_factory::create_module_builder()</a>..</p>
<dl class="section user"><dt>Concurrent accesses to database elements within a transaction</dt><dd>Access to database elements is provided by <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> (read-only) and <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> (for modification). The interface pointers returned by these methods must be released when you are done, in particular before the transaction is committed or aborted. Releasing the last interface pointer obtained from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> makes the changes also visible to later <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> calls for the same database element. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that it is possible to access the same database element concurrently in the same transaction. Concurrently means that the interface pointer obtained from an earlier <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> or <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> call has not yet been released and the same database element is accessed once more using <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> or <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a>. It is advisable to avoid such concurrent accesses since it can easily lead to difficult to understand effects. The semantics are as follows: <ul>
<li>
multiple <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> calls: Since all obtained interface pointers are const there is no way to modify the database elements. </li>
<li>
<a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> call after <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> calls: The interface pointer returned from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> reflects the changes as they are done to the interface pointer returned from the last <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> call.  </li>
<li>
<a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> call after <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> calls: The changes done to the interface pointer returned from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> are not observable through any interface pointer returned from the <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> calls.  </li>
<li>
multiple <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> calls: The changes done to the individual interface pointers are not observable through the other interface pointers. The changes from the interface pointer from the last <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> call survive, independent of the order in which the pointers are released. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Note that these semantics do not only apply to <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> and <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> calls. They also apply to other API methods that access other database elements, e.g., <a class="el" href="classmi_1_1IRef.html#a6c386bf4da9b4fe32669ab40c2c79a08" title="Returns the reference. ">mi::IRef::get_reference()</a>, which internally calls <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The MDL SDK currently supports only one transaction at a time. </dd></dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3e37d6996122404fc0a47bc39190d64a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mi::neuraylib::ITransaction::abort </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This operation is not supported. </p>

</div>
</div>
<a class="anchor" id="adafe2621ae719c43076b79a5677b4934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a>* mi::neuraylib::ITransaction::access </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an element from the database. </p>
<p>The database searches for the most recent version of the named DB element visible for the current transaction. That version will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element from the database, or <code>NULL</code> if <code>name</code> is invalid, no DB element with that name exists, or the transaction is already closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b3e21201f4a43bccd5d842dae34e16e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* mi::neuraylib::ITransaction::access </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an element from the database. </p>
<p>The database searches for the most recent version of the named DB element visible for the current transaction. That version will be returned.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a const pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element from the database, or <code>NULL</code> if <code>name</code> is invalid, no DB element with that name exists, the transaction is already closed, or the element is not of type <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ff8152107db238986b364273bceb0c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::ITransaction::commit </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Commits the transaction. </p>
<p>Note that a <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#aa4ff8152107db238986b364273bceb0c" title="Commits the transaction. ">commit()</a> implicitly closes the transaction. A closed transaction does not allow any future operations and needs to be released.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-1: Unspecified failure.</li>
<li>-3: The transaction is not open. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a0c19e2739eb47e51386aff339be2ee09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::ITransaction::copy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">Uint8</a>&#160;</td>
          <td class="paramname"><em>privacy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a copy of a database element. </p>
<p>Note that DB elements of type <a class="el" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> can not be copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The name of the element to be copied. </td></tr>
    <tr><td class="paramname">target</td><td>The desired name of the copy. </td></tr>
    <tr><td class="paramname">privacy</td><td>The desired privacy level of the copy (in the range from 0 to the privacy level of the scope of this transaction). In addition, the constant <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a59e2e7bc4226fffe5dabec10d13fe8a9" title="Symbolic privacy level for the privacy level of the scope of this transaction. ">LOCAL_SCOPE</a> can be used as a shortcut to indicate the privacy level of the scope of this transaction without supplying the actual value itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-2: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-3: The transaction is not open.</li>
<li>-4: There is no DB element named <code>source</code> visible in this transaction.</li>
<li>-5: Invalid privacy level.</li>
<li>-6: DB elements of this type cannot be copied.</li>
<li>-9: There is already an element of name <code>name</code> and overwriting elements of that type is not supported. This applies to elements of type <a class="el" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>. It also applies to elements of type <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a> and <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> that are used as defaults in an <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a> or <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ad1b8ce71d7a6fea1f59573325dba126c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a>* mi::neuraylib::ITransaction::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>argc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>argv</em>[] = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>type_name</code>. </p>
<p>Objects created with this method are typically <a class="el" href="group__mi__neuray__types.html">Types</a> and <a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a>. Note that most types can also be created via the API component <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html" title="This API component allows the creation, assignment, and cloning of instances of types. ">mi::neuraylib::IFactory</a> which does not require the context of a transaction.</p>
<p>This method can not be used to create MDL modules, definitions, or function calls. To create instances of <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>, use the method <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a19d59ab5c1a19eb45c28c287c01d9af3" title="Creates a new function call. ">mi::neuraylib::IFunction_definition::create_function_call()</a>.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the object to create. See <a class="el" href="group__mi__neuray__types.html">Types</a> for possible type names. In addition, <a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a> can be created by passing the name of the requested interfaces without namespace qualifiers and the leading <code>"I"</code>, e.g., <code>"Image"</code> for <a class="el" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>. Note that you can not create instances of <a class="el" href="classmi_1_1neuraylib_1_1IAttribute__set.html" title="The attribute set comprises all attributes attached to a database element. ">mi::neuraylib::IAttribute_set</a> or <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html" title="Common base interface for all scene elements. ">mi::neuraylib::IScene_element</a>, only instances of the derived interfaces . </td></tr>
    <tr><td class="paramname">argc</td><td>The number of elements in <code>argv</code>. Passed to the constructor of factory of the object to create. </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments passed to the constructor. Passed to the constructor of factory of the object to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object, or <code>NULL</code> if <code>type_name</code> is invalid (<code>NULL</code> pointer) or not a valid type name. </dd></dl>

</div>
</div>
<a class="anchor" id="a87d9ca3eeebb1b34a55e765de72751c6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::ITransaction::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>argc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>argv</em>[] = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>type_name</code>. </p>
<p>Objects created with this method are typically <a class="el" href="group__mi__neuray__types.html">Types</a> and <a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a>. Note that most types can also be created via the API component <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html" title="This API component allows the creation, assignment, and cloning of instances of types. ">mi::neuraylib::IFactory</a> which does not require the context of a transaction.</p>
<p>This method can not be used to create MDL modules, definitions, or function calls. To create instances of <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>, use the method <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a19d59ab5c1a19eb45c28c287c01d9af3" title="Creates a new function call. ">mi::neuraylib::IFunction_definition::create_function_call()</a>.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<p>Note that there are two versions of this templated member function, one that takes no arguments, and another one that takes one or three arguments (the type name, and two optional arguments passed to the constructor or factory). The version with no arguments can only be used to create a subset of supported types derived from <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>: it supports only those types where the type name can be deduced from the template parameter, i.e., it does not support arrays, structures, maps, and pointers. The version with one or three arguments can be used to create any type (but requires the type name as parameter, which is redundant for many types). Attempts to use the version with no arguments with a template parameter where the type name can not be deduced results in compiler errors.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the object to create. See <a class="el" href="group__mi__neuray__types.html">Types</a> for possible type names. In addition, <a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a> can be created by passing the name of the requested interfaces without namespace qualifiers and the leading <code>"I"</code>, e.g., <code>"Image"</code> for <a class="el" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>. Note that you can not create instances of <a class="el" href="classmi_1_1neuraylib_1_1IAttribute__set.html" title="The attribute set comprises all attributes attached to a database element. ">mi::neuraylib::IAttribute_set</a> or <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html" title="Common base interface for all scene elements. ">mi::neuraylib::IScene_element</a>, only instances of the derived interfaces . </td></tr>
    <tr><td class="paramname">argc</td><td>The number of elements in <code>argv</code>. Passed to the constructor of factory of the object to create. </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments passed to the constructor. Passed to the constructor of factory of the object to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the class to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object, or <code>NULL</code> if <code>type_name</code> is invalid (<code>NULL</code> pointer), not a valid type name, or does not create an object of type <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="abf3b188c45023f86faf2b831d7bf9b9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::ITransaction::create </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>T</code>. </p>
<p>Objects created with this method are typically <a class="el" href="group__mi__neuray__types.html">Types</a> and <a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a>. Note that most types can also be created via the API component <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html" title="This API component allows the creation, assignment, and cloning of instances of types. ">mi::neuraylib::IFactory</a> which does not require the context of a transaction.</p>
<p>This method can not be used to create MDL modules, definitions, or function calls. To create instances of <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>, use the method <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a19d59ab5c1a19eb45c28c287c01d9af3" title="Creates a new function call. ">mi::neuraylib::IFunction_definition::create_function_call()</a>.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<p>Note that there are two versions of this templated member function, one that takes no arguments, and another one that takes one or three arguments (the type name, and two optional arguments passed to the constructor or factory). The version with no arguments can only be used to create a subset of supported types derived from <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>: it supports only those types where the type name can be deduced from the template parameter, i.e., it does not support arrays, structures, maps, and pointers. The version with one or three arguments can be used to create any type (but requires the type name as parameter, which is redundant for many types). Attempts to use the version with no arguments with a template parameter where the type name can not be deduced results in compiler errors.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the class to create. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object. </dd></dl>

</div>
</div>
<a class="anchor" id="a35971d023789574ee31dd05768fc7fe1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a>* mi::neuraylib::ITransaction::edit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an element from the database and returns it ready for editing. </p>
<p>The database searches for the most recent version of the named DB element visible for the current transaction. It will then make a copy of that version and return the copy. The edited DB element will be committed to the database automatically, when the obtained interface is released. It is neither necessary nor possible to store the edited element manually in the database using the <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ae1c0cccf93ff990b7af8d0d0379f7c09" title="Stores the element db_element in the database under the name name and with the privacy level privacy...">store()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element from the database, or <code>NULL</code> if <code>name</code> is invalid, no DB element with that name exists, or the transaction is already closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a986e4b2b958009fa43c679214939bfa4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::ITransaction::edit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an element from the database and returns it ready for editing. </p>
<p>The database searches for the most recent version of the named database element visible for the current transaction. It will then make a copy of that version and return the copy. The edited DB element will be committed to the database automatically, when the obtained interface is released. It is neither necessary nor possible to store the edited element manually in the database using the <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ae1c0cccf93ff990b7af8d0d0379f7c09" title="Stores the element db_element in the database under the name name and with the privacy level privacy...">store()</a> method.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the element to retrieve. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element from the database, or <code>NULL</code> if <code>name</code> is invalid, no DB element with that name exists, the transaction is already closed, or the element is not of type <code>T</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a691790207395f02b1487e6f98f4a7c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mi::neuraylib::ITransaction::get_id </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the ID of this transaction. </p>
<p>The transaction ID is of most use when debugging an application as the value returned allows one to correlate log messages and admin HTTP server output with the API actions.</p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the transaction. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf6962667197b0806c1bf9c9964a765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::ITransaction::get_privacy_level </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the privacy level of the element with the name <code>name</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>&gt;= 0: Success. The privacy level of the element (in the range 0-255).</li>
<li>-2: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-3: The transaction is not open.</li>
<li>-4: There is no DB element named <code>name</code> visible in this transaction. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ab94f31ed9390cec1144c01a8347c0072"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1IScope.html">IScope</a>* mi::neuraylib::ITransaction::get_scope </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the scope of this transaction. </p>

</div>
</div>
<a class="anchor" id="a35439dc05ea91a5f6f67b261f1357062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mi::neuraylib::ITransaction::get_time_stamp </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time stamp describing the current "time". </p>
<dl class="section note"><dt>Note</dt><dd>The time stamp is not related to time in the classical meaning. It rather relates to the current transaction and the number of database changes since the start of the transaction.</dd>
<dd>
The time stamp is only meaningful for the current MDL SDK instance. It should not be put into external storage and re-used for different or later MDL SDK instances.</dd>
<dd>
The return value of this method is only valid until the next call of this method (or one of its overloads) on this instance.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a5d6461ac4d7be4211d107ad57a6869ca" title="Checks whether an element has been stored or changed in the database since a given time stamp...">has_changed_since_time_stamp()</a>, <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a885bf28a2ceb2efb079414fe1ea1e73d" title="Returns the time stamp of the last change of a database element. ">get_time_stamp(const char*)const </a> </dd></dl>

</div>
</div>
<a class="anchor" id="a885bf28a2ceb2efb079414fe1ea1e73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mi::neuraylib::ITransaction::get_time_stamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the time stamp of the last change of a database element. </p>
<dl class="section note"><dt>Note</dt><dd>The time stamp is not related to time in the classical meaning. It rather relates to the transaction and the number of database changes since the start of the transaction when the database element was changed last.</dd>
<dd>
The time stamp is only meaningful for the current MDL SDK instance. It should not be put into external storage and re-used for different or later MDL SDK instances.</dd>
<dd>
The return value of this method is only valid until the next call of this method (or one of its overloads) on this instance.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a5d6461ac4d7be4211d107ad57a6869ca" title="Checks whether an element has been stored or changed in the database since a given time stamp...">has_changed_since_time_stamp()</a>, <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35439dc05ea91a5f6f67b261f1357062" title="Returns the time stamp describing the current &quot;time&quot;. ">get_time_stamp()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5d6461ac4d7be4211d107ad57a6869ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::neuraylib::ITransaction::has_changed_since_time_stamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>time_stamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether an element has been stored or changed in the database since a given time stamp. </p>
<dl class="section note"><dt>Note</dt><dd><code>time_stamp</code> should not stem from another concurrent transaction. Such changes will never be visible in this transaction, but the method might still return <code>true</code> depending on the start order of the two transactions.</dd>
<dd>
In case of multiple overlapping transactions the returned answer may not list all changes due to the isolation of the transactions. If accurate results are required, transactions changing elements should be committed before transactions querying the journal for such changes are started.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35439dc05ea91a5f6f67b261f1357062" title="Returns the time stamp describing the current &quot;time&quot;. ">get_time_stamp()</a>, <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a885bf28a2ceb2efb079414fe1ea1e73d" title="Returns the time stamp of the last change of a database element. ">get_time_stamp(const char*)const</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>The name of the element. </td></tr>
    <tr><td class="paramname">time_stamp</td><td>The time stamp obtained from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35439dc05ea91a5f6f67b261f1357062" title="Returns the time stamp describing the current &quot;time&quot;. ">get_time_stamp()</a> or <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a885bf28a2ceb2efb079414fe1ea1e73d" title="Returns the time stamp of the last change of a database element. ">get_time_stamp(const char*)const</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the element has been stored or changed since the time stamp (or if <code>element</code> or <code>time_stamp</code> is invalid, or there is no element with that name), <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2166710b6da32edf42b89d1aace235e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::neuraylib::ITransaction::is_open </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether the transaction is open. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the transaction is still open, or <code>false</code> if the transaction is closed, i.e., it has been committed or aborted. </dd></dl>

</div>
</div>
<a class="anchor" id="a470eb1b7674345c4669bd9faff1029d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1IArray.html">IArray</a>* mi::neuraylib::ITransaction::list_elements </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>root_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name_pattern</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IArray.html">IArray</a> *&#160;</td>
          <td class="paramname"><em>type_names</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns scene elements of a subgraph originating at a given scene element. </p>
<p>The method iterates over all elements of a subgraph originating at the given scene element and returns their names. Optionally, the results can be filtered by a regular expression for the element names and a list for type names.</p>
<p>Note that the runtime of the method depends on the number of elements in the subgraph. It might be expensive to call this method for large subgraphs.</p>
<p>The returned scene elements are in such an order that all elements referenced by a given element are listed before that element ("before" in the sense of "using smaller array
indices").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root_element</td><td>The root of the subgraph to traverse. </td></tr>
    <tr><td class="paramname">name_pattern</td><td>An extended regular expression that acts as filter on the names of returned scene elements (see [<a class="el" href="mi_neuray_biblio.html#OGBS7">OGBS7</a>]). The regular expression is matched to <em>any</em> <em>part</em> of the scene element name, not just to the <em>entire</em> scene element name. The value <code>NULL</code> is handled as <code>".*"</code>. </td></tr>
    <tr><td class="paramname">type_names</td><td>A list of type names that acts as filter on the names of returned scene elements. Only scene elements with a matching type name pass the filter. The value <code>NULL</code> lets all scene elements pass the filter irrespective of their type name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of name of scene elements in the subgraph matching the given regular expression and type name filter, or <code>NULL</code> in case of an invalid root element name or an invalid regular expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a0db9733124735032153593b1a6710ebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mi::neuraylib::ITransaction::name_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>db_element</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of a database element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db_element</td><td>The DB element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the DB element, or <code>NULL</code> if <code>db_element</code> is invalid (<code>NULL</code> pointer), the object is not in the database, or the transaction is already closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a97632e9e40741b788c8c7ef599555789"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::ITransaction::remove </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>only_localized</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the element with the name <code>name</code> from the database. </p>
<p>Note that the element continues to be stored in the database as long as it is referenced by other elements. If it is no longer referenced, and the last transaction were it was referenced has been committed, it will be lazily removed by the garbage collection of the DB. There is no guarantee when this will happen.</p>
<p>This implies that a <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a97632e9e40741b788c8c7ef599555789" title="Removes the element with the name name from the database. ">remove()</a> call might actually remove an element that was stored later under the same name. This can potentially lead to invalid tag accesses. Those cases can be avoided by using <a class="el" href="classmi_1_1neuraylib_1_1IDatabase.html#a33930e1642e2391f2f61cbcee2647c62" title="Triggers a synchronous garbage collection run. ">mi::neuraylib::IDatabase::garbage_collection()</a> after a transaction was committed and before starting the next one to force garbage collection of all possible elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the element in the database to remove. </td></tr>
    <tr><td class="paramname">only_localized</td><td>Unused.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-1: There is no DB element named <code>name</code> visible in this transaction (<code>only_localize</code> is <code>false</code>) or there is no DB element named <code>name</code> in the scope of this transaction (<code>only_localized</code> is <code>true</code>).</li>
<li>-2: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-3: The transaction is not open. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae1c0cccf93ff990b7af8d0d0379f7c09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::ITransaction::store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>db_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">Uint8</a>&#160;</td>
          <td class="paramname"><em>privacy</em> = <code><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a59e2e7bc4226fffe5dabec10d13fe8a9">LOCAL_SCOPE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the element <code>db_element</code> in the database under the name <code>name</code> and with the privacy level <code>privacy</code>. </p>
<p>After a successful store operation the passed interface pointer must no longer be used, except for releasing it. This is due to the fact that after a <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ae1c0cccf93ff990b7af8d0d0379f7c09" title="Stores the element db_element in the database under the name name and with the privacy level privacy...">store()</a> the database retains ownership of the stored data. You can obtain the stored version from the database using the <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access()</a> or <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a35971d023789574ee31dd05768fc7fe1" title="Retrieves an element from the database and returns it ready for editing. ">edit()</a> methods.</p>
<dl class="section note"><dt>Note</dt><dd><b>Overwriting vs editing of existing DB elements</b> <br/>
 While it is possible to overwrite existing DB elements, for performance reasons it is often better to edit the already existing DB element instead. Editing a DB element allows the DB to keep track of the type of changes which might help render modes to update their data structures more efficiently. When overwriting an existing DB element such information is not available and pessimistic assumptions have to be made which may result in lower performance.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db_element</td><td>The <a class="el" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a> to store. </td></tr>
    <tr><td class="paramname">name</td><td>The name under which to store <code>db_element</code>. If there exists already a DB element with that name then it will be overwritten . </td></tr>
    <tr><td class="paramname">privacy</td><td>The privacy level under which to store <code>db_element</code> (in the range from 0 to the privacy level of the scope of this transaction). In addition, the constant <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a59e2e7bc4226fffe5dabec10d13fe8a9" title="Symbolic privacy level for the privacy level of the scope of this transaction. ">LOCAL_SCOPE</a> can be used as a shortcut to indicate the privacy level of the scope of this transaction without supplying the actual value itself. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-1: Unspecified failure.</li>
<li>-2: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-3: The transaction is not open.</li>
<li>-4: <code>db_element</code> is not a DB element.</li>
<li>-5: Invalid privacy level.</li>
<li>-6: <code>db_element</code> has already been stored previously.</li>
<li>-7: The element is to be stored in a transaction different from the one that was used to create it.</li>
<li>-8: The element is a user-defined class that has not been registered.</li>
<li>-9: There is already an element of name <code>name</code> and overwriting elements of that type is not supported. This applies to elements of type <a class="el" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>. It also applies to elements of type <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a> and <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> that are used as defaults in an <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a> or <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a59e2e7bc4226fffe5dabec10d13fe8a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__mi__base__types.html#ga7274a018d102cd4aaefc10d56b453c25">mi::Uint8</a> mi::neuraylib::ITransaction::LOCAL_SCOPE = 255</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Symbolic privacy level for the privacy level of the scope of this transaction. </p>
<p>This symbolic constant can be passed to <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#ae1c0cccf93ff990b7af8d0d0379f7c09" title="Stores the element db_element in the database under the name name and with the privacy level privacy...">store()</a> and <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a0c19e2739eb47e51386aff339be2ee09" title="Creates a copy of a database element. ">copy()</a> to indicate the privacy level of the scope of this transaction. It has the same affect as passing the result of <a class="el" href="classmi_1_1neuraylib_1_1IScope.html#ae9f3c1c2a63dc62c58696af3782ceb67" title="Returns the privacy level of the scope. ">mi::neuraylib::IScope::get_privacy_level()</a>, but is more convenient. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
