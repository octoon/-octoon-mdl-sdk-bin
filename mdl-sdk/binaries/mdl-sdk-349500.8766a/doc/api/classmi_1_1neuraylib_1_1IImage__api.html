<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>mi::neuraylib::IImage_api Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmi_1_1neuraylib_1_1IImage__api.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classmi_1_1neuraylib_1_1IImage__api-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mi::neuraylib::IImage_api Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__mi__neuray__mdl__sdk__misc.html">Miscellaneous Interfaces</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This interface provides various utilities related to canvases and buffers.  
 <a href="classmi_1_1neuraylib_1_1IImage__api.html#details"><span class="morelink">More...</span></a></p>
<div class="dynheader">
Inheritance diagram for mi::neuraylib::IImage_api:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmi_1_1neuraylib_1_1IImage__api.png" usemap="#mi::neuraylib::IImage_api_map" alt=""/>
  <map id="mi::neuraylib::IImage_api_map" name="mi::neuraylib::IImage_api_map">
<area href="classmi_1_1base_1_1Interface__declare.html" alt="mi::base::Interface_declare&lt; 0x4c25a4f0, 0x2bac, 0x4ce6, 0xb0, 0xab, 0x4d, 0x94, 0xbf, 0xfd, 0x97, 0xa5 &gt;" shape="rect" coords="0,56,635,80"/>
<area href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. " alt="mi::base::IInterface" shape="rect" coords="0,0,635,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Factory methods for canvases and tiles</div></td></tr>
<tr class="memitem:a9ad29f8c93cadf565777419cdb72ed66"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a9ad29f8c93cadf565777419cdb72ed66">create_tile</a> (const char *pixel_type, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> width, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> height) const =0</td></tr>
<tr class="memdesc:a9ad29f8c93cadf565777419cdb72ed66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a tile with given pixel type, width, and height.  <a href="#a9ad29f8c93cadf565777419cdb72ed66"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a9ad29f8c93cadf565777419cdb72ed66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f776e1c0271e6898a3585c0bf8099cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a4f776e1c0271e6898a3585c0bf8099cd">create_canvas</a> (const char *pixel_type, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> width, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> height, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> layers=1, bool is_cubemap=false, <a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a> gamma=0.0f) const =0</td></tr>
<tr class="memdesc:a4f776e1c0271e6898a3585c0bf8099cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a canvas with given pixel type, resolution, and layers.  <a href="#a4f776e1c0271e6898a3585c0bf8099cd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a4f776e1c0271e6898a3585c0bf8099cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794a8478f7dba1bb016eb46bd9821bfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a794a8478f7dba1bb016eb46bd9821bfd"></a>
virtual ICanvas_cuda *&#160;</td><td class="memItemRight" valign="bottom"><b>create_canvas_cuda</b> (<a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> cuda_device_id, const char *pixel_type, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> width, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> height, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> layers=1, <a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a> gamma=0.0f) const =0</td></tr>
<tr class="separator:a794a8478f7dba1bb016eb46bd9821bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb070d2b58cda51830236dccecf55210"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1IArray.html">IArray</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#abb070d2b58cda51830236dccecf55210">create_mipmaps</a> (const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, <a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a> gamma_override=0.0f) const =0</td></tr>
<tr class="memdesc:abb070d2b58cda51830236dccecf55210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates mipmaps from the given canvas.  <a href="#abb070d2b58cda51830236dccecf55210"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:abb070d2b58cda51830236dccecf55210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion between canvases and raw memory buffers</div></td></tr>
<tr class="memitem:ad0b501a0089b1c11bf6588e6e58938f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#ad0b501a0089b1c11bf6588e6e58938f0">read_raw_pixels</a> (<a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> width, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> height, const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_x, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_y, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_layer, void *buffer, bool buffer_topdown, const char *buffer_pixel_type, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> buffer_padding=0) const =0</td></tr>
<tr class="memdesc:ad0b501a0089b1c11bf6588e6e58938f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads raw pixel data from a canvas.  <a href="#ad0b501a0089b1c11bf6588e6e58938f0"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ad0b501a0089b1c11bf6588e6e58938f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f60678d57615c2ccdd19fb7ece5da16"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a8f60678d57615c2ccdd19fb7ece5da16">write_raw_pixels</a> (<a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> width, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> height, <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_x, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_y, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> canvas_layer, const void *buffer, bool buffer_topdown, const char *buffer_pixel_type, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> buffer_padding=0) const =0</td></tr>
<tr class="memdesc:a8f60678d57615c2ccdd19fb7ece5da16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes raw pixel data to a canvas.  <a href="#a8f60678d57615c2ccdd19fb7ece5da16"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a8f60678d57615c2ccdd19fb7ece5da16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion between canvases and encoded images</div></td></tr>
<tr class="memitem:aff16acde7a0ed018eaef927a255136ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1IBuffer.html">IBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#aff16acde7a0ed018eaef927a255136ea">create_buffer_from_canvas</a> (const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, const char *image_format, const char *pixel_type, const char *quality, bool force_default_gamma=false) const =0</td></tr>
<tr class="memdesc:aff16acde7a0ed018eaef927a255136ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the pixel data of a canvas into a memory buffer.  <a href="#aff16acde7a0ed018eaef927a255136ea"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aff16acde7a0ed018eaef927a255136ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa4c90c1651990199f3db13cfe0971"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a67aa4c90c1651990199f3db13cfe0971">create_canvas_from_buffer</a> (const <a class="el" href="classmi_1_1neuraylib_1_1IBuffer.html">IBuffer</a> *buffer, const char *image_format) const =0</td></tr>
<tr class="memdesc:a67aa4c90c1651990199f3db13cfe0971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the pixel data of a memory buffer into a canvas.  <a href="#a67aa4c90c1651990199f3db13cfe0971"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a67aa4c90c1651990199f3db13cfe0971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a24fb361955f9f4473049f37476d58"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a57a24fb361955f9f4473049f37476d58">create_canvas_from_reader</a> (<a class="el" href="classmi_1_1neuraylib_1_1IReader.html">IReader</a> *reader, const char *image_format) const =0</td></tr>
<tr class="memdesc:a57a24fb361955f9f4473049f37476d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes the pixel data from a reader into a canvas.  <a href="#a57a24fb361955f9f4473049f37476d58"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a57a24fb361955f9f4473049f37476d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6043fcc5dfa01b05b4c38cc441ddbd9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#ae6043fcc5dfa01b05b4c38cc441ddbd9">supports_format_for_decoding</a> (const char *image_format, <a class="el" href="classmi_1_1neuraylib_1_1IReader.html">IReader</a> *reader=0) const =0</td></tr>
<tr class="memdesc:ae6043fcc5dfa01b05b4c38cc441ddbd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a particular image format is supported for decoding.  <a href="#ae6043fcc5dfa01b05b4c38cc441ddbd9"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae6043fcc5dfa01b05b4c38cc441ddbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8745730328403649d2c3b35ffb66dacb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a8745730328403649d2c3b35ffb66dacb">supports_format_for_encoding</a> (const char *image_format) const =0</td></tr>
<tr class="memdesc:a8745730328403649d2c3b35ffb66dacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether a particular image format is supported for encoding.  <a href="#a8745730328403649d2c3b35ffb66dacb"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a8745730328403649d2c3b35ffb66dacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods for canvases</div></td></tr>
<tr class="memitem:a70bb55d4f633151d12664b078ddd6ebb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb">convert</a> (const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, const char *pixel_type) const =0</td></tr>
<tr class="memdesc:a70bb55d4f633151d12664b078ddd6ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a canvas to a different pixel type.  <a href="#a70bb55d4f633151d12664b078ddd6ebb"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a70bb55d4f633151d12664b078ddd6ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6f6c7994c60410b14d45a6cd0af7ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#aef6f6c7994c60410b14d45a6cd0af7ce">adjust_gamma</a> (<a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, <a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a> new_gamma) const =0</td></tr>
<tr class="memdesc:aef6f6c7994c60410b14d45a6cd0af7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gamma value of a canvas and adjusts the pixel data accordingly.  <a href="#aef6f6c7994c60410b14d45a6cd0af7ce"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aef6f6c7994c60410b14d45a6cd0af7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods for pixel type characteristics</div></td></tr>
<tr class="memitem:ac2c497f568a162560189221e8cd1d4df"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#ac2c497f568a162560189221e8cd1d4df">get_components_per_pixel</a> (const char *pixel_type) const =0</td></tr>
<tr class="memdesc:ac2c497f568a162560189221e8cd1d4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of components per pixel type.  <a href="#ac2c497f568a162560189221e8cd1d4df"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ac2c497f568a162560189221e8cd1d4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc441808ea7c6ead3715113caa78462"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a9fc441808ea7c6ead3715113caa78462">get_bytes_per_component</a> (const char *pixel_type) const =0</td></tr>
<tr class="memdesc:a9fc441808ea7c6ead3715113caa78462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes used per pixel component.  <a href="#a9fc441808ea7c6ead3715113caa78462"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a9fc441808ea7c6ead3715113caa78462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Utility methods for RGBA channels</div></td></tr>
<tr class="memitem:a53d05f5e836b1aa91893db9223b71258"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a53d05f5e836b1aa91893db9223b71258">get_pixel_type_for_channel</a> (const char *pixel_type, const char *selector) const =0</td></tr>
<tr class="memdesc:a53d05f5e836b1aa91893db9223b71258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pixel type of an RGBA channel.  <a href="#a53d05f5e836b1aa91893db9223b71258"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a53d05f5e836b1aa91893db9223b71258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee95d34ad776b5dd2a8c48123fd070d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a4ee95d34ad776b5dd2a8c48123fd070d">extract_channel</a> (const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *canvas, const char *selector) const =0</td></tr>
<tr class="memdesc:a4ee95d34ad776b5dd2a8c48123fd070d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an RGBA channel from a canvas.  <a href="#a4ee95d34ad776b5dd2a8c48123fd070d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a4ee95d34ad776b5dd2a8c48123fd070d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd9577699392e3ba5bf0550a2af0469"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#afcd9577699392e3ba5bf0550a2af0469">extract_channel</a> (const <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a> *tile, const char *selector) const =0</td></tr>
<tr class="memdesc:afcd9577699392e3ba5bf0550a2af0469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts an RGBA channel from a tile.  <a href="#afcd9577699392e3ba5bf0550a2af0469"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:afcd9577699392e3ba5bf0550a2af0469"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x4c25a4f0, 0x2bac, 0x4ce6, 0xb0, 0xab, 0x4d, 0x94, 0xbf, 0xfd, 0x97, 0xa5 &gt;</a></td></tr>
<tr class="memitem:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Interface__declare.html">Interface_declare</a>&lt; id1, <br class="typebreak"/>
id2, id3, id4, id5, id6, id7, <br class="typebreak"/>
id8, id9, id10, id11, <br class="typebreak"/>
<a class="el" href="classmi_1_1base_1_1IInterface.html">IInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#aaa2da9cb0b963fed938e3e19dcb912cd">Self</a></td></tr>
<tr class="memdesc:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Own type.  <a href="#aaa2da9cb0b963fed938e3e19dcb912cd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Uuid__t.html">Uuid_t</a>&lt; id1, id2, id3, <br class="typebreak"/>
id4, id5, id6, id7, id8, id9, <br class="typebreak"/>
id10, id11 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#a7ab89c594dc3cbbbb9aeffaf33b72a52">IID</a></td></tr>
<tr class="memdesc:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the interface ID (IID) of this interface.  <a href="#a7ab89c594dc3cbbbb9aeffaf33b72a52"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x4c25a4f0, 0x2bac, 0x4ce6, 0xb0, 0xab, 0x4d, 0x94, 0xbf, 0xfd, 0x97, 0xa5 &gt;</a></td></tr>
<tr class="memitem:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#ac18291e29369f959218926e0fe7d1667">compare_iid</a> (const <a class="el" href="structmi_1_1base_1_1Uuid.html">Uuid</a> &amp;iid)</td></tr>
<tr class="memdesc:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the interface ID <code>iid</code> against the interface ID of this interface and of its ancestors.  <a href="#ac18291e29369f959218926e0fe7d1667"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This interface provides various utilities related to canvases and buffers. </p>
<p>Note that <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#aff16acde7a0ed018eaef927a255136ea" title="Encodes the pixel data of a canvas into a memory buffer. ">create_buffer_from_canvas()</a> and <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a67aa4c90c1651990199f3db13cfe0971" title="Decodes the pixel data of a memory buffer into a canvas. ">create_canvas_from_buffer()</a> encode and decode pixel data to/from memory buffers. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aef6f6c7994c60410b14d45a6cd0af7ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void mi::neuraylib::IImage_api::adjust_gamma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a>&#160;</td>
          <td class="paramname"><em>new_gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gamma value of a canvas and adjusts the pixel data accordingly. </p>
<dl class="section note"><dt>Note</dt><dd>Gamma adjustments are always done in pixel type "Color" or "Rgb_fp". If necessary, the pixel data is converted forth and back automatically (which needs temporary buffers).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The canvas whose pixel data is to be adjusted. </td></tr>
    <tr><td class="paramname">new_gamma</td><td>The new gamma value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70bb55d4f633151d12664b078ddd6ebb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a>* mi::neuraylib::IImage_api::convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a canvas to a different pixel type. </p>
<dl class="section note"><dt>Note</dt><dd>This method creates a copy if the passed-in canvas already has the desired pixel type. (It cannot return the passed-in canvas since this would require a const cast.) If performance is critical, you should compare pixel types yourself and skip the method call if pixel type conversion is not needed.)</dd></dl>
<p>The conversion converts a given pixel as follows:</p>
<ul>
<li>Floating-point values are linearly mapped to integers as follows: 0.0f is mapped to 0 and 1.0f is mapped to 255 or 65535, respectively. Note that the pixel type <code>"Sint8"</code> is treated as the corresponding unsigned integer type <code>"Uint8"</code> here. Floating-point values are clamped to [0.0f, 1.0f] beforehand. The reverse conversion uses the corresponding inverse mapping.</li>
<li>Single-channel formats are converted to grey-scale RGB formats by duplicating the value in each channel.</li>
<li>RGB formats are converted to single-channel formats by mixing the RGB channels with weights 0.27f for red, 0.67f for green, and 0.06f for blue.</li>
<li>If an alpha channel is added, the values are set to 1.0f, 255, or 65535 respectively.</li>
<li>The pixel type <code>"Float32&lt;4&gt;"</code> is treated in the same way as <code>"Color"</code>, <code>"Float32&lt;3&gt;"</code> in the same way as <code>"Rgb_fp"</code>, and <code>"Sint32"</code> in the same way as <code>"Rgba"</code>.</li>
<li>The pixel type <code>"Rgbe"</code> is converted via <code>"Rgb_fp"</code>. Similarly, <code>"Rgbea"</code> is converted via <code>"Color"</code>.</li>
<li><code>"Float32&lt;2&gt;"</code> is converted to single-channel formats by averaging the two channels. If <code>"Float32&lt;2&gt;"</code> is converted to three- or four-channel formats, the blue channel is set to 0.0f, or 0, respectively. Conversion of single-channel formats to <code>"Float32&lt;2&gt;"</code> duplicates the channel. Conversion of three- or four-channel formats to <code>"Float32&lt;2&gt;"</code> drops the third and fourth channel.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The canvas to convert (or to copy). </td></tr>
    <tr><td class="paramname">pixel_type</td><td>The desired pixel type. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. If this pixel type is the same as the pixel type of <code>canvas</code>, then a copy of the canvas is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A canvas with the requested pixel type, or <code>NULL</code> in case of errors (<code>canvas</code> is <code>NULL</code>, or <code>pixel_type</code> is not valid). </dd></dl>

</div>
</div>
<a class="anchor" id="aff16acde7a0ed018eaef927a255136ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1IBuffer.html">IBuffer</a>* mi::neuraylib::IImage_api::create_buffer_from_canvas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>image_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_default_gamma</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes the pixel data of a canvas into a memory buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The canvas whose contents are to be used. </td></tr>
    <tr><td class="paramname">image_format</td><td>The desired image format of the image, e.g., <code>"jpg"</code>. Note that support for a given image format requires an image plugin capable of handling that format. </td></tr>
    <tr><td class="paramname">pixel_type</td><td>The desired pixel type. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. Not every image plugin supports every pixel type. If the requested pixel type is not supported, the argument is ignored and one of the supported formats is chosen instead. </td></tr>
    <tr><td class="paramname">quality</td><td>The compression quality is an integer in the range from 0 to 100, where 0 is the lowest quality, and 100 is the highest quality. </td></tr>
    <tr><td class="paramname">force_default_gamma</td><td>If enabled, adjusts the gamma value of the exported pixel data according to the pixel type chosen for export (1.0 for HDR pixel types, 2.2 for LDR pixel types). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created buffer, or <code>NULL</code> in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f776e1c0271e6898a3585c0bf8099cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a>* mi::neuraylib::IImage_api::create_canvas </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>layers</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cubemap</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a>&#160;</td>
          <td class="paramname"><em>gamma</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a canvas with given pixel type, resolution, and layers. </p>
<p>This factory function allows to create instances of the abstract interface <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> based on an internal default implementation. However, you are not obligated to use this factory function and the internal default implementation. It is absolutely fine to use your own (correct) implementation of the <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixel_type</td><td>The desired pixel type. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. </td></tr>
    <tr><td class="paramname">width</td><td>The desired width. </td></tr>
    <tr><td class="paramname">height</td><td>The desired height. </td></tr>
    <tr><td class="paramname">layers</td><td>The desired number of layers (depth). Must be 6 for cubemaps. </td></tr>
    <tr><td class="paramname">is_cubemap</td><td>Flag that indicates whether this canvas represents a cubemap. </td></tr>
    <tr><td class="paramname">gamma</td><td>The desired gamma value. The special value 0.0 represents the default gamma which is 1.0 for HDR pixel types and 2.2 for LDR pixel types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested canvas, or <code>NULL</code> in case of invalid pixel type, width, height, layers, or cubemap flag, or memory allocation failures. </dd></dl>

</div>
</div>
<a class="anchor" id="a67aa4c90c1651990199f3db13cfe0971"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a>* mi::neuraylib::IImage_api::create_canvas_from_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1IBuffer.html">IBuffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>image_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the pixel data of a memory buffer into a canvas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer that holds the encoded pixel data. </td></tr>
    <tr><td class="paramname">image_format</td><td>The image format of the buffer, e.g., <code>"jpg"</code>. Note that support for a given image format requires an image plugin capable of handling that format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The canvas with the decoded pixel data, or <code>NULL</code> in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="a57a24fb361955f9f4473049f37476d58"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a>* mi::neuraylib::IImage_api::create_canvas_from_reader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1neuraylib_1_1IReader.html">IReader</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>image_format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes the pixel data from a reader into a canvas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader that provides the data for the image. The reader needs to support absolute access. </td></tr>
    <tr><td class="paramname">image_format</td><td>The image format of the buffer, e.g., <code>"jpg"</code>. Note that support for a given image format requires an image plugin capable of handling that format. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The canvas with the decoded pixel data, or <code>NULL</code> in case of failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abb070d2b58cda51830236dccecf55210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1IArray.html">IArray</a>* mi::neuraylib::IImage_api::create_mipmaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7">Float32</a>&#160;</td>
          <td class="paramname"><em>gamma_override</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates mipmaps from the given canvas. </p>
<dl class="section note"><dt>Note</dt><dd>The base level (the canvas that is passed in) is not included in the returned canvas array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The canvas to create the mipmaps from. </td></tr>
    <tr><td class="paramname">gamma_override</td><td>If this parameter is different from zero, it is used instead of the canvas gamma during mipmap creation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array of type <a class="el" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a> containing pointers to the mipmaps of type <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a>. If no mipmaps could be created, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ad29f8c93cadf565777419cdb72ed66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a>* mi::neuraylib::IImage_api::create_tile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a tile with given pixel type, width, and height. </p>
<p>This factory function allows to create instances of the abstract interface <a class="el" href="classmi_1_1neuraylib_1_1ITile.html" title="Abstract interface for a tile. ">mi::neuraylib::ITile</a> based on an internal default implementation. However, you are not obligated to use this factory function and the internal default implementation. It is absolutely fine to use your own (correct) implementation of the <a class="el" href="classmi_1_1neuraylib_1_1ITile.html" title="Abstract interface for a tile. ">mi::neuraylib::ITile</a> interface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixel_type</td><td>The desired pixel type. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. </td></tr>
    <tr><td class="paramname">width</td><td>The desired width. </td></tr>
    <tr><td class="paramname">height</td><td>The desired height. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested tile, or <code>NULL</code> in case of invalid pixel type, width, or height, or memory allocation failures. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ee95d34ad776b5dd2a8c48123fd070d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a>* mi::neuraylib::IImage_api::extract_channel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an RGBA channel from a canvas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td>The canvas to extract a channel from. </td></tr>
    <tr><td class="paramname">selector</td><td>The RGBA channel selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted channel, or <code>NULL</code> in case of invalid pixel type/ channel selector combinations (see <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a53d05f5e836b1aa91893db9223b71258" title="Returns the pixel type of an RGBA channel. ">get_pixel_type_for_channel()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="afcd9577699392e3ba5bf0550a2af0469"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a>* mi::neuraylib::IImage_api::extract_channel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ITile.html">ITile</a> *&#160;</td>
          <td class="paramname"><em>tile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts an RGBA channel from a tile. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile</td><td>The tile to extract a channel from. </td></tr>
    <tr><td class="paramname">selector</td><td>The RGBA channel selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The extracted channel, or <code>NULL</code> in case of invalid pixel type/ channel selector combinations (see <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a53d05f5e836b1aa91893db9223b71258" title="Returns the pixel type of an RGBA channel. ">get_pixel_type_for_channel()</a>). </dd></dl>

</div>
</div>
<a class="anchor" id="a9fc441808ea7c6ead3715113caa78462"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> mi::neuraylib::IImage_api::get_bytes_per_component </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes used per pixel component. </p>
<p>For example, for the pixel type "Color" the method returns 4 because its components are of type <a class="el" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> which needs 4 bytes. Returns 0 in case of invalid pixel types.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#ac2c497f568a162560189221e8cd1d4df" title="Returns the number of components per pixel type. ">get_components_per_pixel()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2c497f568a162560189221e8cd1d4df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> mi::neuraylib::IImage_api::get_components_per_pixel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of components per pixel type. </p>
<p>For example, for the pixel type "Color" the method returns 4 because it consists of four components R, G, B, and A. Returns 0 in case of invalid pixel types.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a9fc441808ea7c6ead3715113caa78462" title="Returns the number of bytes used per pixel component. ">get_bytes_per_component()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53d05f5e836b1aa91893db9223b71258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* mi::neuraylib::IImage_api::get_pixel_type_for_channel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the pixel type of an RGBA channel. </p>
<p>Invalid pixel type/selector combinations are:</p>
<ul>
<li><code>pixel_type</code> is not an RGB or RGBA pixel type</li>
<li><code>selector</code> is not an RGBA channel selector</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixel_type</td><td>The pixel type of the mipmap/canvas/tile. </td></tr>
    <tr><td class="paramname">selector</td><td>The RGBA channel selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns PT_UNDEF for invalid pixel type/selector combinations. Otherwise, returns PT_SINT8 or PT_FLOAT32, depending on <code>pixel_type</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0b501a0089b1c11bf6588e6e58938f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::IImage_api::read_raw_pixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>buffer_topdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>buffer_padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads raw pixel data from a canvas. </p>
<p>Reads a rectangular area of pixels from a canvas (possibly spanning multiple tiles), converts the pixel type if needed, and writes the pixel data to buffer in memory. Management of the buffer memory is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the rectangular pixel area. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the rectangular pixel area. </td></tr>
    <tr><td class="paramname">canvas</td><td>The canvas to read the pixel data from. </td></tr>
    <tr><td class="paramname">canvas_x</td><td>The x-coordinate of the lower-left corner of the rectangle. </td></tr>
    <tr><td class="paramname">canvas_y</td><td>The y-coordinate of the lower-left corner of the rectangle. </td></tr>
    <tr><td class="paramname">canvas_layer</td><td>The layer of the canvas that holds the rectangular area. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to write the pixel data to. </td></tr>
    <tr><td class="paramname">buffer_topdown</td><td>Indicates whether the buffer stores the rows in top-down order. </td></tr>
    <tr><td class="paramname">buffer_pixel_type</td><td>The pixel type of the buffer. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. </td></tr>
    <tr><td class="paramname">buffer_padding</td><td>The padding between subsequent rows of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-1: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-2: <code>width</code> or <code>height</code> is zero.</li>
<li>-3: Invalid pixel type of the buffer.</li>
<li>-4: The rectangular area [<code>canvas_x</code>, <code>canvas_x</code> + <code>width</code>) x [<code>canvas_y</code>, <code>canvas_y</code> + <code>height</code>) exceeds the size of the canvas, or <code>canvas_layer</code> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae6043fcc5dfa01b05b4c38cc441ddbd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::neuraylib::IImage_api::supports_format_for_decoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>image_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1neuraylib_1_1IReader.html">IReader</a> *&#160;</td>
          <td class="paramname"><em>reader</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a particular image format is supported for decoding. </p>
<p>Support for a given image format requires an image plugin capable of handling that format. This method allows to check whether such a plugin has been loaded for a particular format.</p>
<p>Decoding is used when the image is converted into a canvas from a memory buffer or a file . Note that even if this method returns <code>true</code>, <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#a67aa4c90c1651990199f3db13cfe0971" title="Decodes the pixel data of a memory buffer into a canvas. ">create_canvas_from_buffer()</a> can still fail for a particular image if that image uses an unsupported feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_format</td><td>The image format in question, e.g., <code>"jpg"</code>. </td></tr>
    <tr><td class="paramname">reader</td><td>An optional reader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image format is supported, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8745730328403649d2c3b35ffb66dacb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool mi::neuraylib::IImage_api::supports_format_for_encoding </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>image_format</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates whether a particular image format is supported for encoding. </p>
<p>Support for a given image format requires an image plugin capable of handling that format. This method allows to check whether such a plugin has been loaded for a particular format.</p>
<p>Encoding is used when the image is converted from a canvas into a memory buffer or a file. . Note that even if this method returns <code>true</code>, <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html#aff16acde7a0ed018eaef927a255136ea" title="Encodes the pixel data of a canvas into a memory buffer. ">create_buffer_from_canvas()</a> can still fail if the given canvas uses an unsupported feature, e.g., multiple layers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_format</td><td>The image format in question, e.g., <code>"jpg"</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the image format is supported, <code>false</code> otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a8f60678d57615c2ccdd19fb7ece5da16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::IImage_api::write_raw_pixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html">ICanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>canvas_layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>buffer_topdown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buffer_pixel_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>buffer_padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes raw pixel data to a canvas. </p>
<p>Reads a rectangular area of pixels from a buffer in memory, converts the pixel type if needed, and writes the pixel data to a canvas (possibly spanning multiple tiles). Management of the buffer memory is the responsibility of the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the rectangular pixel area. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the rectangular pixel area. </td></tr>
    <tr><td class="paramname">canvas</td><td>The canvas to write the pixel data to. </td></tr>
    <tr><td class="paramname">canvas_x</td><td>The x-coordinate of the lower-left corner of the rectangle. </td></tr>
    <tr><td class="paramname">canvas_y</td><td>The y-coordinate of the lower-left corner of the rectangle. </td></tr>
    <tr><td class="paramname">canvas_layer</td><td>The layer of the canvas that holds the rectangular area. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to read the pixel data from. </td></tr>
    <tr><td class="paramname">buffer_topdown</td><td>Indicates whether the buffer stores the rows in top-down order. </td></tr>
    <tr><td class="paramname">buffer_pixel_type</td><td>The pixel type of the buffer. See <a class="el" href="group__mi__neuray__types.html">Types</a> for a list of supported pixel types. </td></tr>
    <tr><td class="paramname">buffer_padding</td><td>The padding between subsequent rows of the buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0: Success.</li>
<li>-1: Invalid parameters (<code>NULL</code> pointer).</li>
<li>-2: <code>width</code> or <code>height</code> is zero.</li>
<li>-3: Invalid pixel type of the buffer.</li>
<li>-4: The rectangular area [<code>canvas_x</code>, <code>canvas_x</code> + <code>width</code>) x [<code>canvas_y</code>, <code>canvas_y</code> + <code>height</code>) exceeds the size of the canvas, or <code>canvas_layer</code> is invalid. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
