<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Example for Compiled Distribution Functions (PTX)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mi_neuray_example_df_cuda.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Example for Compiled Distribution Functions (PTX) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="right"> [<a class="el" href="mi_neuray_example_execution_glsl.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_df_native.html">Next</a>] </div><p>This example shows how functions implementing BSDFs can be generated by the "PTX" backend. To illustrate the use of these functions in CUDA, it implements a small physically based renderer that computes direct lighting from an HDR environment map using BSDF evaluation and importance sampling.</p>
<h1><a class="anchor" id="example_df_cuda_new"></a>
New Topics</h1>
<ul>
<li>Generated BSDF functions</li>
<li>Changing compiled material arguments at runtime</li>
</ul>
<h1><a class="anchor" id="example_df_cuda_descr"></a>
Detailed Description</h1>
<dl>
<dt><b>BSDF functions</b> </dt>
<dd><p class="startdd"><br/>
 The generated functions for BSDFs implement</p>
<ul>
<li>An initialization function to prepare shared data per hit.</li>
<li>Evaluation of the BSDF for a given pair of incoming and outgoing directions.</li>
<li>Importance sampling of an incoming direction given an outgoing direction.</li>
<li>Probability density function (PDF) computation of generating an incoming for a given outgoing direction.</li>
</ul>
<p>Each function takes arguments for state, resources, and material arguments that are analogous to the material expression counterpart of the earlier examples and the latter three functions further take a specific input and output parameter <code>data</code>. The signatures of the functions look like this: </p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> void (<a class="code" href="group__mi__neuray__mdl__compiler.html#ga51739a4d22d4e745c1437ee0763ddd0d" title="Signature of the initialization function for material distribution functions created via mi::neurayli...">Bsdf_init_function</a>)    (Shading_state_material *state,</div>
<div class="line">                                      <span class="keyword">const</span> Resource_data *res_data,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *exception_state,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *arg_block_data);</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> void (<a class="code" href="group__mi__neuray__mdl__compiler.html#ga986445d0a97d751cfd1e26664d4e1613" title="Signature of the importance sampling function for material distribution functions created via mi::neu...">Bsdf_sample_function</a>)  (Bsdf_sample_data *data,</div>
<div class="line">                                      <span class="keyword">const</span> Shading_state_material *state,</div>
<div class="line">                                      <span class="keyword">const</span> Resource_data *res_data,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *exception_state,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *arg_block_data);</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> void (<a class="code" href="group__mi__neuray__mdl__compiler.html#ga04671962ad18856bfee1d7f24d325cdc" title="Signature of the evaluation function for material distribution functions created via mi::neuraylib::I...">Bsdf_evaluate_function</a>)(Bsdf_evaluate_data *data,</div>
<div class="line">                                      <span class="keyword">const</span> Shading_state_material *state,</div>
<div class="line">                                      <span class="keyword">const</span> Resource_data *res_data,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *exception_state,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *arg_block_data);</div>
<div class="line">                                      </div>
<div class="line"><span class="keyword">typedef</span> void (<a class="code" href="group__mi__neuray__mdl__compiler.html#ga96174ff556b7072f8cc9d55b619719f3" title="Signature of the probability density function for material distribution functions created via mi::neu...">Bsdf_pdf_function</a>)     (Bsdf_pdf_data *data,</div>
<div class="line">                                      <span class="keyword">const</span> Shading_state_material *state,</div>
<div class="line">                                      <span class="keyword">const</span> Resource_data *res_data,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">void</span> *exception_state,</div>
<div class="line">                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *arg_block_data);</div>
</div><!-- fragment --><p> The functions can be generated by <a class="el" href="group__mi__neuray__mdl__compiler.html#gad7f03dd16a39326eda22c86981530ac2" title="Transforms an MDL distribution function to target code. ">mi::neuraylib::IMdl_backend::translate_material_df()</a> or <a class="el" href="group__mi__neuray__mdl__compiler.html#gac02374a1f0604aa1804a75d59b6a5eee" title="Add an MDL distribution function to this link unit. ">mi::neuraylib::ILink_unit::add_material_df()</a>. Both functions have a parameter <code>include_geometry_normal</code> that can be specified to make the initialization function replace <code>state-&gt;normal</code> by the result of the expression connected to <code>geometry.normal</code> of the material. The final function names are specified by a base name that will suffixed by <code>_init</code>, <code>_sample</code>, <code>_evaluate</code>, and <code>_pdf</code>.</p>
<p>BSDF evaluation and PDF computation take a pair of directions and IORs (index of refraction) as input and produce a PDF and, in the case of <code>Bsdf_evaluate_function</code>, the value of the BSDF. The corresponding structs are</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Bsdf_evaluate_data {</div>
<div class="line">    <span class="comment">// Input fields</span></div>
<div class="line">    float3       ior1;           <span class="comment">// IOR current medium</span></div>
<div class="line">    float3       ior2;           <span class="comment">// IOR other side</span></div>
<div class="line">    float3       k1;             <span class="comment">// outgoing direction</span></div>
<div class="line">    float3       k2;             <span class="comment">// incoming direction</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output fields</span></div>
<div class="line">    float3       bsdf;           <span class="comment">// bsdf * dot(normal, k2)</span></div>
<div class="line">    <span class="keywordtype">float</span>        pdf;            <span class="comment">// pdf (non-projected hemisphere)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Bsdf_pdf_data {</div>
<div class="line">    <span class="comment">// Input fields</span></div>
<div class="line">    float3       ior1;           <span class="comment">// IOR current medium</span></div>
<div class="line">    float3       ior2;           <span class="comment">// IOR other side</span></div>
<div class="line">    float3       k1;             <span class="comment">// outgoing direction</span></div>
<div class="line">    float3       k2;             <span class="comment">// incoming direction</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output fields</span></div>
<div class="line">    <span class="keywordtype">float</span>        pdf;            <span class="comment">// pdf (non-projected hemisphere)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>The handling of the (color) IOR is generally up to the renderer, in particular this includes the decision if the evaluation should happen from within an object with refracting material or from the outer side. It is possible though, to just pass in one IOR (e.g. <code>ior1</code>) and make the functions fill the other with the IOR of the material by marking the <code>x</code> component of it with <code>MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR</code> (e.g. <code>ior2.x=MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR</code>).</p>
<p>For importance sampling, one direction and a set of pseudo-random numbers needs to be provided. The output values include the importance sampled direction, a PDF, a weight (the value of the BSDF divided by the PDF), and the type of the BSDF that was eventually sampled. Note that this may include an absorption event, in which case no direction has been generated.</p>
<div class="fragment"><div class="line"><span class="keyword">enum</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gac2c6881b8d60f83e0aa7a903963e93b6" title="The type of events created by BSDF importance sampling. ">Bsdf_event_type</a> {</div>
<div class="line">    BSDF_EVENT_ABSORB       = 0,</div>
<div class="line"></div>
<div class="line">    BSDF_EVENT_DIFFUSE      = 1,</div>
<div class="line">    BSDF_EVENT_GLOSSY       = 1 &lt;&lt; 1,</div>
<div class="line">    BSDF_EVENT_SPECULAR     = 1 &lt;&lt; 2,</div>
<div class="line">    BSDF_EVENT_REFLECTION   = 1 &lt;&lt; 3,</div>
<div class="line">    BSDF_EVENT_TRANSMISSION = 1 &lt;&lt; 4,</div>
<div class="line"></div>
<div class="line">    BSDF_EVENT_DIFFUSE_REFLECTION    = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_REFLECTION,</div>
<div class="line">    BSDF_EVENT_DIFFUSE_TRANSMISSION  = BSDF_EVENT_DIFFUSE  | BSDF_EVENT_TRANSMISSION,</div>
<div class="line">    BSDF_EVENT_GLOSSY_REFLECTION     = BSDF_EVENT_GLOSSY   | BSDF_EVENT_REFLECTION,</div>
<div class="line">    BSDF_EVENT_GLOSSY_TRANSMISSION   = BSDF_EVENT_GLOSSY   | BSDF_EVENT_TRANSMISSION,</div>
<div class="line">    BSDF_EVENT_SPECULAR_REFLECTION   = BSDF_EVENT_SPECULAR | BSDF_EVENT_REFLECTION,</div>
<div class="line">    BSDF_EVENT_SPECULAR_TRANSMISSION = BSDF_EVENT_SPECULAR | BSDF_EVENT_TRANSMISSION,</div>
<div class="line"></div>
<div class="line">    BSDF_EVENT_FORCE_32_BIT = 0xffffffffU</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Bsdf_sample_data {</div>
<div class="line">    <span class="comment">// Input fields</span></div>
<div class="line">    float3       ior1;           <span class="comment">// IOR current medium</span></div>
<div class="line">    float3       ior2;           <span class="comment">// IOR other side</span></div>
<div class="line">    float3       k1;             <span class="comment">// outgoing direction</span></div>
<div class="line">    float3       xi;             <span class="comment">// pseudo-random sample number</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Output fields</span></div>
<div class="line">    float3       k2;             <span class="comment">// incoming direction</span></div>
<div class="line">    <span class="keywordtype">float</span>        pdf;            <span class="comment">// pdf (non-projected hemisphere)</span></div>
<div class="line">    float3       bsdf_over_pdf;  <span class="comment">// bsdf * dot(normal, k2) / pdf</span></div>
<div class="line">    <a class="code" href="group__mi__neuray__mdl__compiler.html#gac2c6881b8d60f83e0aa7a903963e93b6" title="The type of events created by BSDF importance sampling. ">Bsdf_event_type</a>  event_type; <span class="comment">// the type of event for the generated sample</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>It often is the case that for a given shading point both evaluation and importance sampling need to be performed (possibly multiple times). To avoid re-computation of material expressions in each BSDF function call it is essential that the results are cached between multiple calls. This is accomplished by the initialization function <code>Bsdf_init_function</code> which stores computed results in an array passed by the <a class="el" href="structmi_1_1neuraylib_1_1Shading__state__material__impl.html#aed5ec70445ecfd586edfeffa6d41de05" title="The texture results lookup table. ">mi::neuraylib::Shading_state_material::text_results</a> field. The size of that array needs to be communicated to the backend using the <code>"num_texture_results"</code> option via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga1301dec05ba862ca7745814367811f15" title="Sets a backend option. ">mi::neuraylib::IMdl_backend::set_option()</a>. If the storage is insufficient (e.g. for a material with a high number of material expressions), non-cached expressions are automatically recomputed when they are needed. The initialization is generally not optional, i.e. even if the <code>text_results</code> array size is set to zero it may still perform some initialization, in particular it will update <code>state-&gt;normal</code> if requested. </p>
<p class="enddd"></p>
</dd>
<dt><b>EDF functions</b> </dt>
<dd><p class="startdd"><br/>
 Analogous to the generation of BSDF functions, emission distribution functions (EDFs) can be generated using the corresponding signatures and data structures. For more information see the example code and run the example application using materials that contain EDFs:</p>
<div class="fragment"><div class="line">df_cuda ::nvidia::sdk_examples::tutorials::example_edf</div>
<div class="line">df_cuda ::nvidia::sdk_examples::tutorials::example_measured_edf</div>
</div><!-- fragment --><p>Global distributions are not supported yet and result in no emission. Hence, the generated EDFs can currently be evaluated only in tangent space.</p>
<p></p>
<p class="enddd"></p>
</dd>
<dt><b>Changing arguments of class-compiled materials at runtime</b> </dt>
<dd><p class="startdd"><br/>
 As explained in <a class="el" href="mi_neuray_compiler.html#mi_neuray_compilation_modes">Instance-compilation and class-compilation</a>, the resulting <a class="el" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> object contains <a class="el" href="classmi_1_1neuraylib_1_1ITarget__value__layout.html" title="Represents the layout of an mi::neuraylib::ITarget_argument_block with support for nested elements...">mi::neuraylib::ITarget_value_layout</a> and <a class="el" href="classmi_1_1neuraylib_1_1ITarget__argument__block.html" title="Represents an argument block of a class-compiled material compiled for a specific target...">mi::neuraylib::ITarget_argument_block</a> objects for each material, when class-compiled materials are used for generating target code. Together with the corresponding <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>, you can already get some information about the arguments:</p>
<ul>
<li>the names via <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a46415cda96452bab97dbaeaaea5e8ce6" title="Returns the name of a parameter. ">mi::neuraylib::ICompiled_material::get_parameter_name()</a>,</li>
<li>the types by calling <a class="el" href="classmi_1_1neuraylib_1_1IValue.html#a88d8f733dd7b0590d4b78477f26f8225" title="Returns the type of this value. ">mi::neuraylib::IValue::get_type()</a> on the arguments returned by <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a592a6add4b9d93576f6b77bb3236cc25" title="Returns the value of an argument. ">mi::neuraylib::ICompiled_material::get_argument()</a>, and</li>
<li>the offsets in the argument block by calling <a class="el" href="group__mi__neuray__mdl__compiler.html#ga5e6285f96e35f47619ed06bee7b00215" title="Get the offset, the size and the kind of the argument / element inside the argument block at the give...">mi::neuraylib::ITarget_value_layout::get_layout()</a> with the states returned by <a class="el" href="group__mi__neuray__mdl__compiler.html#ga307d4a4ec571ae47e166b59ca6820465" title="Get the layout state for the i&#39;th argument / element inside the argument value block at the given lay...">mi::neuraylib::ITarget_value_layout::get_nested_state()</a>.</li>
</ul>
<p>The example uses this information to build a material editor GUI with the "Dear ImGui" framework (<a href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a>). The GUI controls are linked to the data of the target argument block using the offsets of the arguments. When ImGui reports any changes by the user, the target argument block is updated on the device for the current material.</p>
<p>When presenting material arguments to the user, additional information from parameter annotations may improve the user experience. To find the annotations for an argument of a compiled material, you have to look up the annotation block for a parameter of the corresponding <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> with the same name as the argument.</p>
<dl class="section note"><dt>Note</dt><dd>You will only find a parameter in a material definition with an exactly matching name for a compiled material argument, when non-struct constants were used as arguments during class-compilation. For other arguments you will get paths like "x.b" as parameter names.</dd></dl>
<p>In this example, the <code>anno::hard_range</code> annotation is used to determine the minimum and maximum values for value sliders, the <code>anno::display_name</code> annotation is used as a more user-friendly name for the arguments, and the <code>anno::in_group</code> annotation is used to group the arguments into categories.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="example_df_cuda"></a>
Example Source</h1>
<p>To compile the source code, you require CUDA, GLFW, and GLEW. For detailed instructions, please refer to the <a class="el" href="mi_neuray_getting_started.html">Getting Started </a> section.</p>
<p><b>Source Code Location:</b> <code>examples/mdl_sdk/df_cuda/example_df_cuda.cpp</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/df_cuda/example_df_cuda.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Simple renderer using compiled BSDFs with a material parameter editor GUI.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;list&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// shared example helpers</span></div>
<div class="line"><span class="preprocessor">#include &quot;example_df_cuda.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;lpe.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Enable this to dump the generated PTX code to stdout.</span></div>
<div class="line"><span class="comment">// #define DUMP_PTX</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define OPENGL_INTEROP</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &quot;example_cuda_shared.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;imgui.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;imgui_impl_glfw.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;imgui_impl_opengl3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GL/glew.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define GL_DISPLAY_CUDA</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &quot;utils/gl_display.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define terminate()          \</span></div>
<div class="line"><span class="preprocessor">    do {                     \</span></div>
<div class="line"><span class="preprocessor">        glfwTerminate();     \</span></div>
<div class="line"><span class="preprocessor">        exit_failure();      \</span></div>
<div class="line"><span class="preprocessor">    } while (0)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define WINDOW_TITLE &quot;MDL SDK DF CUDA Example&quot;</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Vector helper functions //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__mi__math__function.html#gaab1f278e40b1524c2c83b33e05fee81f" title="Returns the Euclidean norm of the scalar a (its absolute value). ">length</a>(<span class="keyword">const</span> float3 &amp;d)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> sqrtf(d.x * d.x + d.y * d.y + d.z * d.z);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> float3 normalize(<span class="keyword">const</span> float3 &amp;d)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_len = 1.0f / <a class="code" href="group__mi__math__function.html#gaab1f278e40b1524c2c83b33e05fee81f" title="Returns the Euclidean norm of the scalar a (its absolute value). ">length</a>(d);</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(d.x * inv_len, d.y * inv_len, d.z * inv_len);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__bbox.html#ga27657e606d65aa9dee41e1246542ab5c" title="Returns a bounding box that is a version of bbox divided by divisor, i.e., bbox.max and bbox...">operator/</a>(<span class="keyword">const</span> float3&amp; d, <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_s = 1.0f / s;</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(d.x * inv_s, d.y * inv_s, d.z * inv_s);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// OpenGL code //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// Initialize OpenGL and create a window with an associated OpenGL context.</span></div>
<div class="line"><span class="keyword">static</span> GLFWwindow *init_opengl(std::string&amp; version_string, <span class="keywordtype">int</span> res_x, <span class="keywordtype">int</span> res_y)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize GLFW</span></div>
<div class="line">    check_success(glfwInit());</div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</div>
<div class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</div>
<div class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</div>
<div class="line">    version_string = <span class="stringliteral">&quot;#version 330 core&quot;</span>; <span class="comment">// see top comments in &#39;imgui_impl_opengl3.cpp&#39;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create an OpenGL window and a context</span></div>
<div class="line">    GLFWwindow *window = glfwCreateWindow(</div>
<div class="line">        res_x, res_y, WINDOW_TITLE, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!window) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error creating OpenGL window!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        terminate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Attach context to window</span></div>
<div class="line">    glfwMakeContextCurrent(window);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize GLEW to get OpenGL extensions</span></div>
<div class="line">    GLenum res = glewInit();</div>
<div class="line">    <span class="keywordflow">if</span> (res != GLEW_OK) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;GLEW error: &quot;</span> &lt;&lt; glewGetErrorString(res) &lt;&lt; std::endl;</div>
<div class="line">        terminate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Disable VSync</span></div>
<div class="line">    glfwSwapInterval(0);</div>
<div class="line"></div>
<div class="line">    check_success(glGetError() == GL_NO_ERROR);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> window;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Application logic //</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">// Context structure for window callback functions.</span></div>
<div class="line"><span class="keyword">struct </span>Window_context</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> mouse_event, key_event;</div>
<div class="line">    <span class="keywordtype">bool</span> save_image;</div>
<div class="line">    <span class="keywordtype">int</span> zoom;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> mouse_button;            <span class="comment">// button from callback event plus one (0 = no event)</span></div>
<div class="line">    <span class="keywordtype">int</span> mouse_button_action;     <span class="comment">// action from mouse button callback event</span></div>
<div class="line">    <span class="keywordtype">int</span> mouse_wheel_delta;</div>
<div class="line">    <span class="keywordtype">bool</span> moving;</div>
<div class="line">    <span class="keywordtype">double</span> move_start_x, move_start_y;</div>
<div class="line">    <span class="keywordtype">double</span> move_dx, move_dy;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> material_index_delta;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> save_result;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> exposure_event;</div>
<div class="line">    <span class="keywordtype">float</span> exposure;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> std::string to_string(Display_buffer_options option)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (option)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> DISPLAY_BUFFER_LPE: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Selected LPE&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> DISPLAY_BUFFER_ALBEDO: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Albedo&quot;</span>;</div>
<div class="line">        <span class="keywordflow">case</span> DISPLAY_BUFFER_NORMAL: <span class="keywordflow">return</span> <span class="stringliteral">&quot;Normal&quot;</span>;</div>
<div class="line">        <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW scroll callback</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_scroll(GLFWwindow *window, <span class="keywordtype">double</span> xoffset, <span class="keywordtype">double</span> yoffset)</div>
<div class="line">{</div>
<div class="line">    Window_context *ctx = <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window));</div>
<div class="line">    <span class="keywordflow">if</span> (yoffset &gt; 0.0) {</div>
<div class="line">        ctx-&gt;mouse_wheel_delta = 1; ctx-&gt;mouse_event = <span class="keyword">true</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yoffset &lt; 0.0) {</div>
<div class="line">        ctx-&gt;mouse_wheel_delta = -1; ctx-&gt;mouse_event = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ImGui_ImplGlfw_ScrollCallback(window, xoffset, yoffset);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW keyboard callback</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_key(GLFWwindow *window, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> scancode, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle key press events</span></div>
<div class="line">    <span class="keywordflow">if</span> (action == GLFW_PRESS) {</div>
<div class="line">        Window_context *ctx = <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window));</div>
<div class="line">        <span class="keywordflow">switch</span> (key) {</div>
<div class="line">            <span class="comment">// Escape closes the window</span></div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_ESCAPE:</div>
<div class="line">                glfwSetWindowShouldClose(window, GLFW_TRUE);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_DOWN:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_RIGHT:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_PAGE_DOWN:</div>
<div class="line">                ctx-&gt;material_index_delta = 1;</div>
<div class="line">                ctx-&gt;key_event = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_UP:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_LEFT:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_PAGE_UP:</div>
<div class="line">                ctx-&gt;material_index_delta = -1;</div>
<div class="line">                ctx-&gt;key_event = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_ENTER:</div>
<div class="line">                ctx-&gt;save_result = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_KP_SUBTRACT:</div>
<div class="line">                ctx-&gt;exposure--;</div>
<div class="line">                ctx-&gt;exposure_event = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_KP_ADD:</div>
<div class="line">                ctx-&gt;exposure++;</div>
<div class="line">                ctx-&gt;exposure_event = <span class="keyword">true</span>;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    ImGui_ImplGlfw_KeyCallback(window, key, scancode, action, mods);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW mouse button callback</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_mouse_button(GLFWwindow *window, <span class="keywordtype">int</span> button, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)</div>
<div class="line">{</div>
<div class="line">    Window_context *ctx = <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window));</div>
<div class="line">    ctx-&gt;mouse_button = button + 1;</div>
<div class="line">    ctx-&gt;mouse_button_action = action;</div>
<div class="line"></div>
<div class="line">    ImGui_ImplGlfw_MouseButtonCallback(window, button, action, mods);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW mouse position callback</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> handle_mouse_pos(GLFWwindow *window, <span class="keywordtype">double</span> xpos, <span class="keywordtype">double</span> ypos)</div>
<div class="line">{</div>
<div class="line">    Window_context *ctx = <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window));</div>
<div class="line">    <span class="keywordflow">if</span> (ctx-&gt;moving)</div>
<div class="line">    {</div>
<div class="line">        ctx-&gt;move_dx += xpos - ctx-&gt;move_start_x;</div>
<div class="line">        ctx-&gt;move_dy += ypos - ctx-&gt;move_start_y;</div>
<div class="line">        ctx-&gt;move_start_x = xpos;</div>
<div class="line">        ctx-&gt;move_start_y = ypos;</div>
<div class="line">        ctx-&gt;mouse_event = <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Resize CUDA buffers for a given resolution</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> resize_buffers(CUdeviceptr *buffer_cuda, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Allocate CUDA buffer</span></div>
<div class="line">    <span class="keywordflow">if</span> (*buffer_cuda)</div>
<div class="line">        check_cuda_success(cuMemFree(*buffer_cuda));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (width == 0 || height == 0)</div>
<div class="line">        *buffer_cuda = 0;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        check_cuda_success(cuMemAlloc(buffer_cuda, width * height * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper for create_environment()</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">float</span> build_alias_map(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> *data,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size,</div>
<div class="line">    Env_accel *accel)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// create qs (normalized)</span></div>
<div class="line">    <span class="keywordtype">float</span> sum = 0.0f;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; ++i)</div>
<div class="line">        sum += data[i];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; ++i)</div>
<div class="line">        accel[i].q = (static_cast&lt;float&gt;(size) * data[i] / sum);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create partition table</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partition_table = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(</div>
<div class="line">        malloc(size * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)));</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0u, large = size;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; ++i)</div>
<div class="line">        partition_table[(accel[i].q &lt; 1.0f) ? (s++) : (--large)] = accel[i].alias = i;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create alias map</span></div>
<div class="line">    <span class="keywordflow">for</span> (s = 0; s &lt; large &amp;&amp; large &lt; size; ++s)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = partition_table[s], k = partition_table[large];</div>
<div class="line">        accel[j].alias = k;</div>
<div class="line">        accel[k].q += accel[j].q - 1.0f;</div>
<div class="line">        large = (accel[k].q &lt; 1.0f) ? (large + 1u) : large;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    free(partition_table);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> sum;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create environment map texture and acceleration data for importance sampling</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> create_environment(</div>
<div class="line">    cudaTextureObject_t *env_tex,</div>
<div class="line">    cudaArray_t *env_tex_data,</div>
<div class="line">    CUdeviceptr *env_accel,</div>
<div class="line">    uint2 *res,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a> transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a> image_api,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *envmap_name)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Load environment texture</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage&gt;</a>image(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#ad1b8ce71d7a6fea1f59573325dba126c" title="Creates an object of the type type_name. ">create</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(<span class="stringliteral">&quot;Image&quot;</span>));</div>
<div class="line">    check_success(image-&gt;reset_file(envmap_name) == 0);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas(0, 0, 0));</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> rx = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>();</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> ry = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>();</div>
<div class="line">    res-&gt;x = rx;</div>
<div class="line">    res-&gt;y = ry;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Check, whether we need to convert the image</span></div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *image_type = image-&gt;get_type(0, 0);</div>
<div class="line">    <span class="keywordflow">if</span> (strcmp(image_type, <span class="stringliteral">&quot;Color&quot;</span>) != 0 &amp;&amp; strcmp(image_type, <span class="stringliteral">&quot;Float32&lt;4&gt;&quot;</span>) != 0)</div>
<div class="line">        canvas = image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.get(), <span class="stringliteral">&quot;Color&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy the image data to a CUDA array</span></div>
<div class="line">    <span class="keyword">const</span> cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc&lt;float4&gt;();</div>
<div class="line">    check_cuda_success(cudaMallocArray(env_tex_data, &amp;channel_desc, rx, ry));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> *pixels = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cudaMemcpy2DToArray(</div>
<div class="line">        *env_tex_data, 0, 0, pixels,</div>
<div class="line">        rx * <span class="keyword">sizeof</span>(float4), rx * <span class="keyword">sizeof</span>(float4), ry, cudaMemcpyHostToDevice));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a CUDA texture</span></div>
<div class="line">    cudaResourceDesc res_desc;</div>
<div class="line">    memset(&amp;res_desc, 0, <span class="keyword">sizeof</span>(res_desc));</div>
<div class="line">    res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">    res_desc.res.array.array = *env_tex_data;</div>
<div class="line"></div>
<div class="line">    cudaTextureDesc tex_desc;</div>
<div class="line">    memset(&amp;tex_desc, 0, <span class="keyword">sizeof</span>(tex_desc));</div>
<div class="line">    tex_desc.addressMode[0]   = cudaAddressModeWrap;</div>
<div class="line">    tex_desc.addressMode[1]   = cudaAddressModeClamp;  <span class="comment">// don&#39;t sample beyond poles of env sphere</span></div>
<div class="line">    tex_desc.addressMode[2]   = cudaAddressModeWrap;</div>
<div class="line">    tex_desc.filterMode       = cudaFilterModeLinear;</div>
<div class="line">    tex_desc.readMode         = cudaReadModeElementType;</div>
<div class="line">    tex_desc.normalizedCoords = 1;</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cudaCreateTextureObject(env_tex, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create importance sampling data</span></div>
<div class="line">    Env_accel *env_accel_host = <span class="keyword">static_cast&lt;</span>Env_accel *<span class="keyword">&gt;</span>(malloc(rx * ry * <span class="keyword">sizeof</span>(Env_accel)));</div>
<div class="line">    <span class="keywordtype">float</span> *importance_data = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(malloc(rx * ry * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">    <span class="keywordtype">float</span> cos_theta0 = 1.0f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> step_phi = float(2.0 * M_PI) / float(rx);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> step_theta = float(M_PI) / float(ry);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = 0; y &lt; ry; ++y)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> theta1 = float(y + 1) * step_theta;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta1 = <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">std::cos</a>(theta1);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> area = (cos_theta0 - cos_theta1) * step_phi;</div>
<div class="line">        cos_theta0 = cos_theta1;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = 0; x &lt; rx; ++x) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = y * rx + x;</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx4 =  idx * 4;</div>
<div class="line">            importance_data[idx] =</div>
<div class="line">                area * std::max(pixels[idx4], std::max(pixels[idx4 + 1], pixels[idx4 + 2]));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_env_integral = 1.0f / build_alias_map(importance_data, rx * ry, env_accel_host);</div>
<div class="line">    free(importance_data);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; rx * ry; ++i) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx4 = i * 4;</div>
<div class="line">        env_accel_host[i].pdf =</div>
<div class="line">            std::max(pixels[idx4], std::max(pixels[idx4 + 1], pixels[idx4 + 2])) * inv_env_integral;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    *env_accel = gpu_mem_dup(env_accel_host, rx * ry * <span class="keyword">sizeof</span>(Env_accel));</div>
<div class="line">    free(env_accel_host);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> upload_lpe_state_machine(</div>
<div class="line">    Kernel_params&amp; kernel_params,</div>
<div class="line">    LPE_state_machine&amp; lpe_state_machine)</div>
<div class="line">{</div>
<div class="line">    uint32_t num_trans = lpe_state_machine.get_transition_count();</div>
<div class="line">    uint32_t num_states = lpe_state_machine.get_state_count();</div>
<div class="line">    kernel_params.lpe_num_transitions = num_trans;</div>
<div class="line">    kernel_params.lpe_num_states = num_states;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// free old data</span></div>
<div class="line">    <span class="keywordflow">if</span> (kernel_params.lpe_state_table)</div>
<div class="line">        check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(kernel_params.lpe_state_table)));</div>
<div class="line">    <span class="keywordflow">if</span> (kernel_params.lpe_final_mask)</div>
<div class="line">        check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(kernel_params.lpe_final_mask)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// state table</span></div>
<div class="line">    CUdeviceptr state_table = 0;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;state_table, num_states * num_trans * <span class="keyword">sizeof</span>(uint32_t)));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(state_table, lpe_state_machine.get_state_table().data(),</div>
<div class="line">                       num_states * num_trans * <span class="keyword">sizeof</span>(uint32_t)));</div>
<div class="line">    kernel_params.lpe_state_table = <span class="keyword">reinterpret_cast&lt;</span>uint32_t*<span class="keyword">&gt;</span>(state_table);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// final state masks</span></div>
<div class="line">    CUdeviceptr final_mask = 0;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;final_mask, num_states * <span class="keyword">sizeof</span>(uint32_t)));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(final_mask, lpe_state_machine.get_final_state_masks().data(),</div>
<div class="line">                       num_states * <span class="keyword">sizeof</span>(uint32_t)));</div>
<div class="line">    kernel_params.lpe_final_mask = <span class="keyword">reinterpret_cast&lt;</span>uint32_t*<span class="keyword">&gt;</span>(final_mask);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// tag ID for light sources as they don&#39;t store tags in this examples</span></div>
<div class="line">    kernel_params.default_gtag = lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">    kernel_params.point_light_gtag = lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;point_light&quot;</span>);</div>
<div class="line">    kernel_params.env_gtag = lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;env&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Save current result image to disk</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> save_result(</div>
<div class="line">    <span class="keyword">const</span> CUdeviceptr cuda_buffer,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height,</div>
<div class="line">    <span class="keyword">const</span> std::string &amp;filename,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a> image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> mdl_impexp_api)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> canvas(</div>
<div class="line">        image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a4f776e1c0271e6898a3585c0bf8099cd" title="Creates a canvas with given pixel type, resolution, and layers. ">create_canvas</a>(<span class="stringliteral">&quot;Rgb_fp&quot;</span>, width, height));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">    float3 *data = <span class="keyword">static_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line">    check_cuda_success(cuMemcpyDtoH(data, cuda_buffer, width * height * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line"></div>
<div class="line">    mdl_impexp_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a1b544c77874b97eae0003c39e27e2103" title="Exports a canvas to a file on disk. ">export_canvas</a>(filename.c_str(), canvas.get(), 100u, <span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Application options</span></div>
<div class="line"><span class="keyword">struct </span>Options {</div>
<div class="line">    <span class="keywordtype">int</span> cuda_device;</div>
<div class="line">    <span class="keywordtype">float</span> gui_scale;</div>
<div class="line">    <span class="keywordtype">bool</span> opengl;</div>
<div class="line">    <span class="keywordtype">bool</span> use_class_compilation;</div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordtype">bool</span> use_df_interpreter;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordtype">bool</span> no_aa;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_derivatives;</div>
<div class="line">    <span class="keywordtype">bool</span> fold_ternary_on_df;</div>
<div class="line">    <span class="keywordtype">bool</span> enable_auxiliary_output;</div>
<div class="line">    <span class="keywordtype">bool</span> use_adapt_normal;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> res_x, res_y;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iterations;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> samples_per_iteration;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mdl_test_type;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_path_length;</div>
<div class="line">    <span class="keywordtype">float</span> fov;</div>
<div class="line">    <span class="keywordtype">float</span> exposure;</div>
<div class="line">    float3 cam_pos;</div>
<div class="line">    float3 light_pos;</div>
<div class="line">    float3 light_intensity;</div>
<div class="line"></div>
<div class="line">    std::string hdrfile;</div>
<div class="line">    <span class="keywordtype">float</span> hdr_rot;</div>
<div class="line">    std::string outputfile;</div>
<div class="line">    std::vector&lt;std::string&gt; material_names;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Default constructor, sets default values.</span></div>
<div class="line">    Options()</div>
<div class="line">    : cuda_device(0)</div>
<div class="line">    , gui_scale(1.0f)</div>
<div class="line">    , opengl(true)</div>
<div class="line">    , use_class_compilation(true)</div>
<div class="line">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</div>
<div class="line">    , use_df_interpreter(false)</div>
<div class="line">#endif</div>
<div class="line">    , no_aa(false)</div>
<div class="line">    , enable_derivatives(false)</div>
<div class="line">    , fold_ternary_on_df(false)</div>
<div class="line">    , enable_auxiliary_output(true)</div>
<div class="line">    , use_adapt_normal(false)</div>
<div class="line">    , res_x(1024)</div>
<div class="line">    , res_y(1024)</div>
<div class="line">    , iterations(4096)</div>
<div class="line">    , samples_per_iteration(8)</div>
<div class="line">    , mdl_test_type(MDL_TEST_MIS)</div>
<div class="line">    , max_path_length(4)</div>
<div class="line">    , fov(96.0f)</div>
<div class="line">    , exposure(0.0f)</div>
<div class="line">    , cam_pos(make_float3(0, 0, 3))</div>
<div class="line">    , light_pos(make_float3(10, 0, 5))</div>
<div class="line">    , light_intensity(make_float3(0, 0, 0))</div>
<div class="line">    , hdrfile(<span class="stringliteral">&quot;nvidia/sdk_examples/resources/environment.hdr&quot;</span>)</div>
<div class="line">    , hdr_rot(0.0f)</div>
<div class="line">    , outputfile(<span class="stringliteral">&quot;output.exr&quot;</span>)</div>
<div class="line">    , material_names()</div>
<div class="line">    {}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Possible enum values if any.</span></div>
<div class="line"><span class="keyword">struct </span>Enum_value {</div>
<div class="line">    std::string name;</div>
<div class="line">    <span class="keywordtype">int</span>         value;</div>
<div class="line"></div>
<div class="line">    Enum_value(<span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> value)</div>
<div class="line">    : name(name), value(value)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Info for an enum type.</span></div>
<div class="line"><span class="keyword">struct </span>Enum_type_info {</div>
<div class="line">    std::vector&lt;Enum_value&gt; values;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Adds a enum value and its integer value to the enum type info.</span></div>
<div class="line">    <span class="keywordtype">void</span> add(<span class="keyword">const</span> std::string &amp;name, <span class="keywordtype">int</span> value) {</div>
<div class="line">        values.push_back(Enum_value(name, value));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Material parameter information structure.</span></div>
<div class="line"><span class="keyword">class </span>Param_info</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> Param_kind</div>
<div class="line">    {</div>
<div class="line">        PK_UNKNOWN,</div>
<div class="line">        PK_FLOAT,</div>
<div class="line">        PK_FLOAT2,</div>
<div class="line">        PK_FLOAT3,</div>
<div class="line">        PK_COLOR,</div>
<div class="line">        PK_ARRAY,</div>
<div class="line">        PK_BOOL,</div>
<div class="line">        PK_INT,</div>
<div class="line">        PK_ENUM,</div>
<div class="line">        PK_STRING,</div>
<div class="line">        PK_TEXTURE,</div>
<div class="line">        PK_LIGHT_PROFILE,</div>
<div class="line">        PK_BSDF_MEASUREMENT</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    Param_info(</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> index,</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> *name,</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> *display_name,</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> *group_name,</div>
<div class="line">        Param_kind kind,</div>
<div class="line">        Param_kind array_elem_kind,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>   array_size,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>   array_pitch,</div>
<div class="line">        <span class="keywordtype">char</span> *data_ptr,</div>
<div class="line">        <span class="keyword">const</span> Enum_type_info *enum_info = <span class="keyword">nullptr</span>)</div>
<div class="line">    : m_index(index)</div>
<div class="line">    , m_name(name)</div>
<div class="line">    , m_display_name(display_name)</div>
<div class="line">    , m_group_name(group_name)</div>
<div class="line">    , m_kind(kind)</div>
<div class="line">    , m_array_elem_kind(array_elem_kind)</div>
<div class="line">    , m_array_size(array_size)</div>
<div class="line">    , m_array_pitch(array_pitch)</div>
<div class="line">    , m_data_ptr(data_ptr)</div>
<div class="line">    , m_range_min(-100), m_range_max(100)</div>
<div class="line">    , m_enum_info(enum_info)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get data as T&amp;.</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    T &amp;data() { <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span>T *<span class="keyword">&gt;</span>(m_data_ptr); }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get data as const T&amp;.</span></div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keyword">const</span> T &amp;data()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>T *<span class="keyword">&gt;</span>(m_data_ptr); }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * &amp;display_name()     { <span class="keywordflow">return</span> m_display_name; }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *display_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_display_name; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> * &amp;group_name()     { <span class="keywordflow">return</span> m_group_name; }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *group_name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_group_name; }</div>
<div class="line"></div>
<div class="line">    Param_kind kind()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_kind; }</div>
<div class="line"></div>
<div class="line">    Param_kind array_elem_kind()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_array_elem_kind; }</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> array_size()<span class="keyword"> const        </span>{ <span class="keywordflow">return</span> m_array_size; }</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> array_pitch()<span class="keyword"> const       </span>{ <span class="keywordflow">return</span> m_array_pitch; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> &amp;range_min()      { <span class="keywordflow">return</span> m_range_min; }</div>
<div class="line">    <span class="keywordtype">float</span> range_min()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_range_min; }</div>
<div class="line">    <span class="keywordtype">float</span> &amp;range_max()      { <span class="keywordflow">return</span> m_range_max; }</div>
<div class="line">    <span class="keywordtype">float</span> range_max()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_range_max; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Enum_type_info *enum_info()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_enum_info; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>             m_index;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>           *m_name;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>           *m_display_name;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>           *m_group_name;</div>
<div class="line">    Param_kind           m_kind;</div>
<div class="line">    Param_kind           m_array_elem_kind;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>             m_array_size;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>             m_array_pitch;   <span class="comment">// the distance between two array elements</span></div>
<div class="line">    <span class="keywordtype">char</span>                 *m_data_ptr;</div>
<div class="line">    <span class="keywordtype">float</span>                m_range_min, m_range_max;</div>
<div class="line">    <span class="keyword">const</span> Enum_type_info *m_enum_info;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Material information structure.</span></div>
<div class="line"><span class="keyword">class </span>Material_info</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Material_info(<span class="keywordtype">char</span> <span class="keyword">const</span> *name)</div>
<div class="line">    : m_name(name)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add the parameter information as last entry of the corresponding group, or to the</span></div>
<div class="line">    <span class="comment">// end of the list, if no group name is available.</span></div>
<div class="line">    <span class="keywordtype">void</span> add_sorted_by_group(<span class="keyword">const</span> Param_info &amp;info) {</div>
<div class="line">        <span class="keywordtype">bool</span> group_found = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (info.group_name() != <span class="keyword">nullptr</span>) {</div>
<div class="line">            <span class="keywordflow">for</span> (std::list&lt;Param_info&gt;::iterator it = params().begin(); it != params().end(); ++it)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> same_group =</div>
<div class="line">                    it-&gt;group_name() != <span class="keyword">nullptr</span> &amp;&amp; strcmp(it-&gt;group_name(), info.group_name()) == 0;</div>
<div class="line">                <span class="keywordflow">if</span> (group_found &amp;&amp; !same_group) {</div>
<div class="line">                    m_params.insert(it, info);</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (same_group)</div>
<div class="line">                    group_found = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        m_params.push_back(info);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add a new enum type to the list of used enum types.</span></div>
<div class="line">    <span class="keywordtype">void</span> add_enum_type(<span class="keyword">const</span> std::string name, std::shared_ptr&lt;Enum_type_info&gt; enum_info) {</div>
<div class="line">        enum_types[name] = enum_info;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Lookup enum type info for a given enum type absolute MDL name.</span></div>
<div class="line">    <span class="keyword">const</span> Enum_type_info *get_enum_type(<span class="keyword">const</span> std::string name) {</div>
<div class="line">        Enum_type_map::const_iterator it = enum_types.find(name);</div>
<div class="line">        <span class="keywordflow">if</span> (it != enum_types.end())</div>
<div class="line">            <span class="keywordflow">return</span> it-&gt;second.get();</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the name of the material.</span></div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *name()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_name; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the parameters of this material.</span></div>
<div class="line">    std::list&lt;Param_info&gt; &amp;params() { <span class="keywordflow">return</span> m_params; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// name of the material</span></div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *m_name;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// parameters of the material</span></div>
<div class="line">    std::list&lt;Param_info&gt; m_params;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, std::shared_ptr&lt;Enum_type_info&gt; &gt; Enum_type_map;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// used enum types of the material</span></div>
<div class="line">    Enum_type_map enum_types;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper class to handle Resource tables of the target code.</span></div>
<div class="line"><span class="keyword">class </span>Resource_table</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, unsigned&gt; Resource_id_map;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">enum</span> Kind {</div>
<div class="line">        RESOURCE_TEXTURE,</div>
<div class="line">        RESOURCE_LIGHT_PROFILE,</div>
<div class="line">        RESOURCE_BSDF_MEASUREMENT</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    Resource_table(</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_code const&gt;</a> target_code,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">        Kind                                                kind)</div>
<div class="line">    : m_max_len(0u)</div>
<div class="line">    {</div>
<div class="line">        read_resources(target_code, transaction, kind);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the length of the longest URL in the resource table.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_max_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_max_len; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get all urls.</span></div>
<div class="line">    std::vector&lt;std::string&gt; <span class="keyword">const</span> &amp;get_urls()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_urls; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> read_resources(</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_code const&gt;</a> target_code,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">        Kind                                                kind)</div>
<div class="line">    {</div>
<div class="line">        m_urls.push_back(<span class="stringliteral">&quot;&lt;unset&gt;&quot;</span>);</div>
<div class="line">        <span class="keywordflow">switch</span> (kind) {</div>
<div class="line">        <span class="keywordflow">case</span> RESOURCE_TEXTURE:</div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1, n = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">get_texture_count</a>(); i &lt; n; ++i) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *s = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(i);</div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITexture const&gt;</a> tex(</div>
<div class="line">                    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(s));</div>
<div class="line">                <span class="keywordtype">char</span> <span class="keyword">const</span> *url = <span class="keyword">nullptr</span>;</div>
<div class="line">                <span class="keywordflow">if</span> (<span class="keywordtype">char</span> <span class="keyword">const</span> *img = tex-&gt;get_image()) {</div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage const&gt;</a> image(</div>
<div class="line">                        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(img));</div>
<div class="line">                    url = image-&gt;get_filename(0, 0);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (url == <span class="keyword">nullptr</span>)</div>
<div class="line">                    url = s;</div>
<div class="line">                <span class="keywordtype">size_t</span> l = strlen(url);</div>
<div class="line">                <span class="keywordflow">if</span> (l &gt; m_max_len)</div>
<div class="line">                    m_max_len = l;</div>
<div class="line">                m_resource_map[s] = (unsigned)i;</div>
<div class="line">                m_urls.push_back(url);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> RESOURCE_LIGHT_PROFILE:</div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1, n = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gaf0cee310f5957d93edff6c4b13bc8e92" title="Returns the number of light profile resources used by the target code. ">get_light_profile_count</a>(); i &lt; n; ++i) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *s = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9b21ee745bcf580cce3beef23fbfc6e6" title="Returns the name of a light profile resource used by the target code. ">get_light_profile</a>(i);</div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ILightprofile const&gt;</a> lp(</div>
<div class="line">                    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ILightprofile.html" title="This interface represents light profiles. ">mi::neuraylib::ILightprofile</a>&gt;(s));</div>
<div class="line">                <span class="keywordtype">char</span> <span class="keyword">const</span> *url = lp-&gt;get_filename();</div>
<div class="line">                <span class="keywordflow">if</span> (url == <span class="keyword">nullptr</span>)</div>
<div class="line">                    url = s;</div>
<div class="line">                <span class="keywordtype">size_t</span> l = strlen(url);</div>
<div class="line">                <span class="keywordflow">if</span> (l &gt; m_max_len)</div>
<div class="line">                    m_max_len = l;</div>
<div class="line">                m_resource_map[s] = (unsigned)i;</div>
<div class="line">                m_urls.push_back(url);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> RESOURCE_BSDF_MEASUREMENT:</div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1, n = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1c3669ca1523d2a98fcec3b049349f76" title="Returns the number of bsdf measurement resources used by the target code. ">get_bsdf_measurement_count</a>(); i &lt; n; ++i) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *s = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae001a474fbb738d2c5b0cd9805e456c8" title="Returns the name of a bsdf measurement resource used by the target code. ">get_bsdf_measurement</a>(i);</div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IBsdf_measurement const&gt;</a> bm(</div>
<div class="line">                    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html" title="A scene element that stores measured BSDF data. ">mi::neuraylib::IBsdf_measurement</a>&gt;(s));</div>
<div class="line">                <span class="keywordtype">char</span> <span class="keyword">const</span> *url = bm-&gt;get_filename();</div>
<div class="line">                <span class="keywordflow">if</span> (url == <span class="keyword">nullptr</span>)</div>
<div class="line">                    url = s;</div>
<div class="line">                <span class="keywordtype">size_t</span> l = strlen(url);</div>
<div class="line">                <span class="keywordflow">if</span> (l &gt; m_max_len)</div>
<div class="line">                    m_max_len = l;</div>
<div class="line">                m_resource_map[s] = (unsigned)i;</div>
<div class="line">                m_urls.push_back(url);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Resource_id_map          m_resource_map;</div>
<div class="line">    std::vector&lt;std::string&gt; m_urls;</div>
<div class="line">    <span class="keywordtype">size_t</span>                   m_max_len;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper class to handle the string table of a target code.</span></div>
<div class="line"><span class="keyword">class </span>String_constant_table</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, unsigned&gt; String_map;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    String_constant_table(<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_code const&gt;</a> target_code)</div>
<div class="line">    {</div>
<div class="line">        get_all_strings(target_code);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the ID for a given string, return 0 if the string does not exist in the table.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> get_id_for_string(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) {</div>
<div class="line">        String_map::const_iterator it(m_string_constants_map.find(name));</div>
<div class="line">        <span class="keywordflow">if</span> (it != m_string_constants_map.end())</div>
<div class="line">            <span class="keywordflow">return</span> it-&gt;second;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// the user adds a sting that is NOT in the code and we have not seen so far, add it</span></div>
<div class="line">        <span class="comment">// and assign a new id</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> n_id = <span class="keywordtype">unsigned</span>(m_string_constants_map.size() + 1);</div>
<div class="line"></div>
<div class="line">        m_string_constants_map[name] = n_id;</div>
<div class="line">        m_strings.reserve((n_id + 63) &amp; ~63);</div>
<div class="line">        m_strings.push_back(name);</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">size_t</span> l = strlen(name);</div>
<div class="line">        <span class="keywordflow">if</span> (l &gt; m_max_len)</div>
<div class="line">            m_max_len = l;</div>
<div class="line">        <span class="keywordflow">return</span> n_id;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the length of the longest string in the string constant table.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_max_length()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_max_len; }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the string for a given ID, or nullptr if this ID does not exist.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *get_string(<span class="keywordtype">unsigned</span> <span class="keywordtype">id</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == 0 || <span class="keywordtype">id</span> - 1 &gt;= m_strings.size())</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordflow">return</span> m_strings[<span class="keywordtype">id</span> - 1].c_str();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Get all string constants used inside a target code and their maximum length.</span></div>
<div class="line">    <span class="keywordtype">void</span> get_all_strings(</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_code const&gt;</a> target_code)</div>
<div class="line">    {</div>
<div class="line">        m_max_len = 0;</div>
<div class="line">        <span class="comment">// ignore the 0, it is the &quot;Not-a-known-string&quot; entry</span></div>
<div class="line">        m_strings.reserve(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga91838b4aa4bc7516de5da96cd66fe6c3" title="Returns the number of string constants used by the target code. ">get_string_constant_count</a>());</div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1, n = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga91838b4aa4bc7516de5da96cd66fe6c3" title="Returns the number of string constants used by the target code. ">get_string_constant_count</a>(); i &lt; n; ++i) {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">char</span> *s = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga45c6430b8be65a96e684f981e66ead6c" title="Returns the string constant used by the target code. ">get_string_constant</a>(i);</div>
<div class="line">            <span class="keywordtype">size_t</span> l = strlen(s);</div>
<div class="line">            <span class="keywordflow">if</span> (l &gt; m_max_len)</div>
<div class="line">                m_max_len = l;</div>
<div class="line">            m_string_constants_map[s] = (unsigned)i;</div>
<div class="line">            m_strings.push_back(s);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    String_map               m_string_constants_map;</div>
<div class="line">    std::vector&lt;std::string&gt; m_strings;</div>
<div class="line">    <span class="keywordtype">size_t</span>                   m_max_len;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the camera kernel parameters.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> update_camera(</div>
<div class="line">    Kernel_params &amp;kernel_params,</div>
<div class="line">    <span class="keywordtype">double</span> phi,</div>
<div class="line">    <span class="keywordtype">double</span> theta,</div>
<div class="line">    <span class="keywordtype">float</span> base_dist,</div>
<div class="line">    <span class="keywordtype">int</span> zoom)</div>
<div class="line">{</div>
<div class="line">    kernel_params.cam_dir.x = float(-<a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(phi) * <a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(theta));</div>
<div class="line">    kernel_params.cam_dir.y = float(-<a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(theta));</div>
<div class="line">    kernel_params.cam_dir.z = float(-<a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(phi) * <a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(theta));</div>
<div class="line"></div>
<div class="line">    kernel_params.cam_right.x = float(<a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(phi));</div>
<div class="line">    kernel_params.cam_right.y = 0.0f;</div>
<div class="line">    kernel_params.cam_right.z = float(-<a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(phi));</div>
<div class="line"></div>
<div class="line">    kernel_params.cam_up.x = float(-<a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(phi) * <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(theta));</div>
<div class="line">    kernel_params.cam_up.y = float(<a class="code" href="group__mi__math__color.html#ga78a748c2639c4c43df3e1085a0258891" title="Returns a color with the elementwise sine of the color c. ">sin</a>(theta));</div>
<div class="line">    kernel_params.cam_up.z = float(-<a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(phi) * <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(theta));</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dist = float(base_dist * <a class="code" href="group__mi__math__color.html#gacdaad24bbf75e76ff277a6c52adb4d8a" title="Returns the color a elementwise to the power of b. ">pow</a>(0.95, <span class="keywordtype">double</span>(zoom)));</div>
<div class="line">    kernel_params.cam_pos.x = -kernel_params.cam_dir.x * dist;</div>
<div class="line">    kernel_params.cam_pos.y = -kernel_params.cam_dir.y * dist;</div>
<div class="line">    kernel_params.cam_pos.z = -kernel_params.cam_dir.z * dist;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a combobox for the given resource parameter to the GUI</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> handle_resource(</div>
<div class="line">    Param_info           &amp;param,</div>
<div class="line">    Resource_table <span class="keyword">const</span> &amp;res_table)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line">    std::vector&lt;std::string&gt; <span class="keyword">const</span> &amp;urls = res_table.get_urls();</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keywordtype">id</span> = param.data&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">    std::string cur_url = urls[id];</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (ImGui::BeginCombo(param.display_name(), cur_url.c_str())) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, n = urls.size(); i &lt; n; ++i) {</div>
<div class="line">            <span class="keyword">const</span> std::string &amp;name = urls[i];</div>
<div class="line">            <span class="keywordtype">bool</span> is_selected = (cur_url == name);</div>
<div class="line">            <span class="keywordflow">if</span> (ImGui::Selectable(name.c_str(), is_selected)) {</div>
<div class="line">                param.data&lt;<span class="keywordtype">int</span>&gt;() = <span class="keywordtype">int</span>(i);</div>
<div class="line">                changed = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (is_selected)</div>
<div class="line">                ImGui::SetItemDefaultFocus();</div>
<div class="line">        }</div>
<div class="line">        ImGui::EndCombo();</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> changed;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Progressively render scene</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> render_scene(</div>
<div class="line">    <span class="keyword">const</span> Options &amp;options,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>         transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>           image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a>      mdl_impexp_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_code const&gt;</a>   target_code,</div>
<div class="line">    Material_compiler::Material_definition_list <span class="keyword">const</span>    &amp;material_defs,</div>
<div class="line">    Material_compiler::Compiled_material_list <span class="keyword">const</span>      &amp;compiled_materials,</div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span>                            &amp;arg_block_indices,</div>
<div class="line">    std::vector&lt;Df_cuda_material&gt; <span class="keyword">const</span>                  &amp;material_bundle,</div>
<div class="line">    LPE_state_machine                                    &amp;lpe_state_machine)</div>
<div class="line">{</div>
<div class="line">    Window_context window_context;</div>
<div class="line">    memset(&amp;window_context, 0, <span class="keyword">sizeof</span>(Window_context));</div>
<div class="line"></div>
<div class="line">    mi::examples::mdl::GL_display *gl_display = <span class="keyword">nullptr</span>;</div>
<div class="line">    GLFWwindow *window = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordtype">int</span> width = -1;</div>
<div class="line">    <span class="keywordtype">int</span> height = -1;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (options.opengl) {</div>
<div class="line">        <span class="comment">// Init OpenGL window</span></div>
<div class="line">        std::string version_string;</div>
<div class="line">        window = init_opengl(version_string, <span class="keywordtype">int</span>(options.res_x), <span class="keywordtype">int</span>(options.res_y));</div>
<div class="line">        glfwSetWindowUserPointer(window, &amp;window_context);</div>
<div class="line">        glfwSetKeyCallback(window, handle_key);</div>
<div class="line">        glfwSetScrollCallback(window, handle_scroll);</div>
<div class="line">        glfwSetCursorPosCallback(window, handle_mouse_pos);</div>
<div class="line">        glfwSetMouseButtonCallback(window, handle_mouse_button);</div>
<div class="line">        glfwSetCharCallback(window, ImGui_ImplGlfw_CharCallback);</div>
<div class="line"></div>
<div class="line">        IMGUI_CHECKVERSION();</div>
<div class="line">        ImGui::CreateContext();</div>
<div class="line"></div>
<div class="line">        ImGui_ImplGlfw_InitForOpenGL(window, <span class="keyword">false</span>);</div>
<div class="line">        ImGui_ImplOpenGL3_Init(version_string.c_str());</div>
<div class="line">        ImGui::GetIO().IniFilename = <span class="keyword">nullptr</span>;       <span class="comment">// disable creating imgui.ini</span></div>
<div class="line">        ImGui::StyleColorsDark();</div>
<div class="line">        ImGui::GetStyle().Alpha = 0.7f;</div>
<div class="line">        ImGui::GetStyle().ScaleAllSizes(options.gui_scale);</div>
<div class="line"></div>
<div class="line">        gl_display = <span class="keyword">new</span> mi::examples::mdl::GL_display(<span class="keywordtype">int</span>(options.res_x), <span class="keywordtype">int</span>(options.res_y));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize CUDA</span></div>
<div class="line">    CUcontext cuda_context = init_cuda(options.cuda_device, options.opengl);</div>
<div class="line"></div>
<div class="line">    CUdeviceptr accum_buffer = 0;</div>
<div class="line">    CUdeviceptr aux_albedo_buffer = 0; <span class="comment">// buffer for auxiliary output</span></div>
<div class="line">    CUdeviceptr aux_normal_buffer = 0; <span class="comment">//</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!options.opengl) {</div>
<div class="line">        width = options.res_x;</div>
<div class="line">        height = options.res_y;</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;accum_buffer, width * height * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;aux_albedo_buffer, width * height * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;aux_normal_buffer, width * height * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup initial CUDA kernel parameters</span></div>
<div class="line">    Kernel_params kernel_params;</div>
<div class="line">    memset(&amp;kernel_params, 0, <span class="keyword">sizeof</span>(Kernel_params));</div>
<div class="line">    kernel_params.cam_focal = 1.0f / tanf(options.fov / 2 * <span class="keywordtype">float</span>(2 * M_PI / 360));</div>
<div class="line">    kernel_params.light_pos = options.light_pos;</div>
<div class="line">    kernel_params.light_intensity = fmaxf(</div>
<div class="line">        options.light_intensity.x, fmaxf(options.light_intensity.y, options.light_intensity.z));</div>
<div class="line">    kernel_params.light_color = kernel_params.light_intensity &gt; 0.0f</div>
<div class="line">        ? options.light_intensity / kernel_params.light_intensity</div>
<div class="line">        : make_float3(1.0f, 0.9f, 0.5f);</div>
<div class="line">    kernel_params.env_intensity = 1.0f;</div>
<div class="line">    kernel_params.iteration_start = 0;</div>
<div class="line">    kernel_params.iteration_num = options.samples_per_iteration;</div>
<div class="line">    kernel_params.mdl_test_type = options.mdl_test_type;</div>
<div class="line">    kernel_params.max_path_length = options.max_path_length;</div>
<div class="line">    kernel_params.exposure_scale = powf(2.0f, options.exposure);</div>
<div class="line">    kernel_params.disable_aa = options.no_aa;</div>
<div class="line">    kernel_params.use_derivatives = options.enable_derivatives;</div>
<div class="line">    kernel_params.enable_auxiliary_output = options.enable_auxiliary_output;</div>
<div class="line">    kernel_params.display_buffer_index = 0;</div>
<div class="line"></div>
<div class="line">    kernel_params.lpe_ouput_expression = 0;</div>
<div class="line">    kernel_params.lpe_state_table = <span class="keyword">nullptr</span>;</div>
<div class="line">    kernel_params.lpe_final_mask = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line">    kernel_params.current_material = 0;</div>
<div class="line">    kernel_params.geometry = material_bundle[kernel_params.current_material].contains_hair_bsdf ?</div>
<div class="line">        GT_HAIR : GT_SPHERE;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup camera</span></div>
<div class="line">    <span class="keywordtype">float</span> base_dist = <a class="code" href="group__mi__math__function.html#gaab1f278e40b1524c2c83b33e05fee81f" title="Returns the Euclidean norm of the scalar a (its absolute value). ">length</a>(options.cam_pos);</div>
<div class="line">    <span class="keywordtype">double</span> theta, phi;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> float3 inv_dir = normalize(options.cam_pos);</div>
<div class="line">        phi = <a class="code" href="group__mi__math__color.html#ga75119f15fe6e0d3778aeaa8070a8fee7" title="Returns a color with the elementwise arc tangent of the color c / d. ">atan2</a>(inv_dir.x, inv_dir.z);</div>
<div class="line">        theta = <a class="code" href="group__mi__math__color.html#ga31db412f0b82cb287b663b7a427718db" title="Returns a color with the elementwise arc cosine of the color c. ">acos</a>(inv_dir.y);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    update_camera(kernel_params, phi, theta, base_dist, window_context.zoom);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Build the full CUDA kernel with all the generated code</span></div>
<div class="line">    std::vector&lt;mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt; &gt; target_codes;</div>
<div class="line">    target_codes.push_back(target_code);</div>
<div class="line">    CUfunction  cuda_function;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *ptx_name = options.enable_derivatives ?</div>
<div class="line">        <span class="stringliteral">&quot;example_df_cuda_derivatives.ptx&quot;</span> : <span class="stringliteral">&quot;example_df_cuda.ptx&quot;</span>;</div>
<div class="line">    CUmodule    cuda_module = build_linked_kernel(</div>
<div class="line">        target_codes,</div>
<div class="line">        (mi::examples::io::get_executable_folder() + <span class="stringliteral">&quot;/&quot;</span> + ptx_name).c_str(),</div>
<div class="line">        <span class="stringliteral">&quot;render_scene_kernel&quot;</span>,</div>
<div class="line">        &amp;cuda_function);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// copy materials of the scene to the device</span></div>
<div class="line">    CUdeviceptr material_buffer = 0;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;material_buffer,</div>
<div class="line">                                  material_bundle.size() * <span class="keyword">sizeof</span>(Df_cuda_material)));</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(material_buffer, material_bundle.data(),</div>
<div class="line">                                    material_bundle.size() * <span class="keyword">sizeof</span>(Df_cuda_material)));</div>
<div class="line">    kernel_params.material_buffer = <span class="keyword">reinterpret_cast&lt;</span>Df_cuda_material*<span class="keyword">&gt;</span>(material_buffer);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup environment map and acceleration</span></div>
<div class="line">    CUdeviceptr env_accel;</div>
<div class="line">    cudaArray_t env_tex_data;</div>
<div class="line">    create_environment(</div>
<div class="line">        &amp;kernel_params.env_tex, &amp;env_tex_data, &amp;env_accel, &amp;kernel_params.env_size, transaction,</div>
<div class="line">        image_api, options.hdrfile.c_str());</div>
<div class="line">    kernel_params.env_accel = <span class="keyword">reinterpret_cast&lt;</span>Env_accel *<span class="keyword">&gt;</span>(env_accel);</div>
<div class="line">    kernel_params.env_rotation = options.hdr_rot / 180.0f * float(M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup GPU runtime of the LPE state machine</span></div>
<div class="line">    upload_lpe_state_machine(kernel_params, lpe_state_machine);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup file name for nogl mode</span></div>
<div class="line">    std::string next_filename_base;</div>
<div class="line">    std::string filename_base, filename_ext;</div>
<div class="line">    <span class="keywordtype">size_t</span> dot_pos = options.outputfile.rfind(<span class="charliteral">&#39;.&#39;</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (dot_pos == std::string::npos) {</div>
<div class="line">        filename_base = options.outputfile;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        filename_base = options.outputfile.substr(0, dot_pos);</div>
<div class="line">        filename_ext = options.outputfile.substr(dot_pos);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (options.material_names.size() &gt; 1)</div>
<div class="line">        next_filename_base = filename_base + <span class="stringliteral">&quot;-0&quot;</span>;</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">        next_filename_base = filename_base;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Scope for material context resources</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Prepare the needed data of all target codes for the GPU</span></div>
<div class="line">        Material_gpu_context material_gpu_context(options.enable_derivatives);</div>
<div class="line">        <span class="keywordflow">if</span> (!material_gpu_context.prepare_target_code_data(</div>
<div class="line">                transaction.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), image_api.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), target_code.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), arg_block_indices))</div>
<div class="line">            terminate();</div>
<div class="line">        kernel_params.tc_data = <span class="keyword">reinterpret_cast&lt;</span>Target_code_data *<span class="keyword">&gt;</span>(</div>
<div class="line">            material_gpu_context.get_device_target_code_data_list());</div>
<div class="line">        kernel_params.arg_block_list = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">char</span> <span class="keyword">const </span>**<span class="keyword">&gt;</span>(</div>
<div class="line">            material_gpu_context.get_device_target_argument_block_list());</div>
<div class="line"></div>
<div class="line">        String_constant_table constant_table(target_code);</div>
<div class="line">        Resource_table texture_table(target_code, transaction, Resource_table::RESOURCE_TEXTURE);</div>
<div class="line">        Resource_table lp_table(target_code, transaction, Resource_table::RESOURCE_LIGHT_PROFILE);</div>
<div class="line">        Resource_table bm_table(</div>
<div class="line">            target_code, transaction, Resource_table::RESOURCE_BSDF_MEASUREMENT);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Collect information about the arguments of the compiled materials</span></div>
<div class="line">        std::vector&lt;Material_info&gt; mat_infos;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, num_mats = compiled_materials.size(); i &lt; num_mats; ++i) {</div>
<div class="line">            <span class="comment">// Get the compiled material and the parameter annotations</span></div>
<div class="line">            <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a> <span class="keyword">const</span> *cur_mat = compiled_materials[i].get();</div>
<div class="line">            <a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> <span class="keyword">const</span> *cur_def = material_defs[i].get();</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IAnnotation_list const&gt;</a> anno_list(</div>
<div class="line">                cur_def-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html#ab599d8ffaa4864efad775b742a53d621" title="Returns the annotations of all parameters. ">get_parameter_annotations</a>());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get the target argument block and its layout</span></div>
<div class="line">            <span class="keywordtype">size_t</span> arg_block_index = material_gpu_context.get_bsdf_argument_block_index(i);</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt;</a> layout(</div>
<div class="line">                material_gpu_context.get_argument_block_layout(arg_block_index));</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a> arg_block(</div>
<div class="line">                material_gpu_context.get_argument_block(arg_block_index));</div>
<div class="line">            <span class="keywordtype">char</span> *arg_block_data = arg_block != <span class="keyword">nullptr</span> ? arg_block-&gt;get_data() : <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line">            Material_info mat_info(cur_def-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a0fb5559a03a1213778934f7bd81d2657" title="Returns the MDL name of the function definition. ">get_mdl_name</a>());</div>
<div class="line">            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> j = 0, num_params = cur_mat-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a32fdd71c7faf888b402287857b1c4380" title="Returns the number of parameters used by this compiled material. ">get_parameter_count</a>(); j &lt; num_params; ++j) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *name = cur_mat-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a46415cda96452bab97dbaeaaea5e8ce6" title="Returns the name of a parameter. ">get_parameter_name</a>(j);</div>
<div class="line">                <span class="keywordflow">if</span> (name == <span class="keyword">nullptr</span>) <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Determine the type of the argument</span></div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IValue const&gt;</a> arg(cur_mat-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a592a6add4b9d93576f6b77bb3236cc25" title="Returns the value of an argument. ">get_argument</a>(j));</div>
<div class="line">                <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49" title="The possible kinds of values. ">mi::neuraylib::IValue::Kind</a> kind = arg-&gt;get_kind();</div>
<div class="line"></div>
<div class="line">                Param_info::Param_kind param_kind            = Param_info::PK_UNKNOWN;</div>
<div class="line">                Param_info::Param_kind param_array_elem_kind = Param_info::PK_UNKNOWN;</div>
<div class="line">                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>               param_array_size      = 0;</div>
<div class="line">                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>               param_array_pitch     = 0;</div>
<div class="line">                <span class="keyword">const</span> Enum_type_info   *enum_type            = <span class="keyword">nullptr</span>;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">switch</span> (kind) {</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a40a310d37d4392d50e0d68c93d7e0b52" title="A float value. See mi::neuraylib::IValue_float. ">mi::neuraylib::IValue::VK_FLOAT</a>:</div>
<div class="line">                    param_kind = Param_info::PK_FLOAT;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49af18388d2560342ebfebe401339c7ab62" title="A color value. See mi::neuraylib::IValue_color. ">mi::neuraylib::IValue::VK_COLOR</a>:</div>
<div class="line">                    param_kind = Param_info::PK_COLOR;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49ad7d9cba6852d030e675b403c3b85c35e" title="A boolean value. See mi::neuraylib::IValue_bool. ">mi::neuraylib::IValue::VK_BOOL</a>:</div>
<div class="line">                    param_kind = Param_info::PK_BOOL;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a67693bf25af6bb68f00501c4a6a72f89" title="An integer value. See mi::neuraylib::IValue_int. ">mi::neuraylib::IValue::VK_INT</a>:</div>
<div class="line">                    param_kind = Param_info::PK_INT;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49ab348cc0e2d54bd2c6c2066c454cc9539" title="A vector value. See mi::neuraylib::IValue_vector. ">mi::neuraylib::IValue::VK_VECTOR</a>:</div>
<div class="line">                    {</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IValue_vector const&gt;</a> val(</div>
<div class="line">                            arg.get_interface&lt;<a class="code" href="classmi_1_1neuraylib_1_1IValue__vector.html" title="A value of type vector. ">mi::neuraylib::IValue_vector</a> <span class="keyword">const</span>&gt;());</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_vector const&gt;</a> val_type(</div>
<div class="line">                            val-&gt;get_type());</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_atomic const&gt;</a> elem_type(</div>
<div class="line">                            val_type-&gt;get_element_type());</div>
<div class="line">                        <span class="keywordflow">if</span> (elem_type-&gt;get_kind() == <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9af1747123a14e15ab9dc7deb24f6544fb" title="The float type. See mi::neuraylib::IType_float. ">mi::neuraylib::IType::TK_FLOAT</a>) {</div>
<div class="line">                            <span class="keywordflow">switch</span> (val_type-&gt;get_size()) {</div>
<div class="line">                            <span class="keywordflow">case</span> 2: param_kind = Param_info::PK_FLOAT2; <span class="keywordflow">break</span>;</div>
<div class="line">                            <span class="keywordflow">case</span> 3: param_kind = Param_info::PK_FLOAT3; <span class="keywordflow">break</span>;</div>
<div class="line">                            <span class="keywordflow">default</span>: assert(<span class="keyword">false</span> || <span class="stringliteral">&quot;Vector Size invalid or unhandled.&quot;</span>);</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a2cc9b579a46315e8ca72a42c45de0c2f" title="An array value. See mi::neuraylib::IValue_array. ">mi::neuraylib::IValue::VK_ARRAY</a>:</div>
<div class="line">                    {</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IValue_array const&gt;</a> val(</div>
<div class="line">                            arg.get_interface&lt;<a class="code" href="classmi_1_1neuraylib_1_1IValue__array.html" title="A value of type array. ">mi::neuraylib::IValue_array</a> <span class="keyword">const</span>&gt;());</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_array const&gt;</a> val_type(</div>
<div class="line">                            val-&gt;get_type());</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType const&gt;</a> elem_type(</div>
<div class="line">                            val_type-&gt;get_element_type());</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// we currently only support arrays of some values</span></div>
<div class="line">                        <span class="keywordflow">switch</span> (elem_type-&gt;get_kind()) {</div>
<div class="line">                        <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9af1747123a14e15ab9dc7deb24f6544fb" title="The float type. See mi::neuraylib::IType_float. ">mi::neuraylib::IType::TK_FLOAT</a>:</div>
<div class="line">                            param_array_elem_kind = Param_info::PK_FLOAT;</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9a461ccd687cfbbb05cd3f2a168035367e" title="The color type. See mi::neuraylib::IType_color. ">mi::neuraylib::IType::TK_COLOR</a>:</div>
<div class="line">                            param_array_elem_kind = Param_info::PK_COLOR;</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9a43c944c64ebe79774fb71cdb6ec6ee6b" title="The boolean type. See mi::neuraylib::IType_bool. ">mi::neuraylib::IType::TK_BOOL</a>:</div>
<div class="line">                            param_array_elem_kind = Param_info::PK_BOOL;</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9a8b805519b351430b36bb8686de44770d" title="The integer type. See mi::neuraylib::IType_int. ">mi::neuraylib::IType::TK_INT</a>:</div>
<div class="line">                            param_array_elem_kind = Param_info::PK_INT;</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9a6848ca375f15496f56ce316a2559bc83" title="A vector type. See mi::neuraylib::IType_vector. ">mi::neuraylib::IType::TK_VECTOR</a>:</div>
<div class="line">                            {</div>
<div class="line">                                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_vector const&gt;</a> val_type(</div>
<div class="line">                                    elem_type.get_interface&lt;</div>
<div class="line">                                        <a class="code" href="classmi_1_1neuraylib_1_1IType__vector.html" title="The type of kind vector. ">mi::neuraylib::IType_vector</a> <span class="keyword">const</span>&gt;());</div>
<div class="line">                                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_atomic const&gt;</a> velem_type(</div>
<div class="line">                                    val_type-&gt;get_element_type());</div>
<div class="line">                                <span class="keywordflow">if</span> (velem_type-&gt;get_kind() == <a class="code" href="classmi_1_1neuraylib_1_1IType.html#a1bb7485ef5c5685572dcff9a674b9dd9af1747123a14e15ab9dc7deb24f6544fb" title="The float type. See mi::neuraylib::IType_float. ">mi::neuraylib::IType::TK_FLOAT</a>) {</div>
<div class="line">                                    <span class="keywordflow">switch</span> (val_type-&gt;get_size()) {</div>
<div class="line">                                    <span class="keywordflow">case</span> 2:</div>
<div class="line">                                        param_array_elem_kind = Param_info::PK_FLOAT2;</div>
<div class="line">                                        <span class="keywordflow">break</span>;</div>
<div class="line">                                    <span class="keywordflow">case</span> 3:</div>
<div class="line">                                        param_array_elem_kind = Param_info::PK_FLOAT3;</div>
<div class="line">                                        <span class="keywordflow">break</span>;</div>
<div class="line">                                    <span class="keywordflow">default</span>:</div>
<div class="line">                                        assert(<span class="keyword">false</span> || <span class="stringliteral">&quot;Vector Size invalid or unhandled.&quot;</span>);</div>
<div class="line">                                    }</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line">                            <span class="keywordflow">break</span>;</div>
<div class="line">                        <span class="keywordflow">default</span>:</div>
<div class="line">                            assert(<span class="keyword">false</span> || <span class="stringliteral">&quot;Array element type invalid or unhandled.&quot;</span>);</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">if</span> (param_array_elem_kind != Param_info::PK_UNKNOWN) {</div>
<div class="line">                            param_kind = Param_info::PK_ARRAY;</div>
<div class="line">                            param_array_size = val_type-&gt;get_size();</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// determine pitch of array if there are at least two elements</span></div>
<div class="line">                            <span class="keywordflow">if</span> (param_array_size &gt; 1) {</div>
<div class="line">                                <a class="code" href="structmi_1_1neuraylib_1_1Target__value__layout__state.html" title="Structure representing the state during traversal of the nested layout. ">mi::neuraylib::Target_value_layout_state</a> array_state(</div>
<div class="line">                                    layout-&gt;get_nested_state(j));</div>
<div class="line">                                <a class="code" href="structmi_1_1neuraylib_1_1Target__value__layout__state.html" title="Structure representing the state during traversal of the nested layout. ">mi::neuraylib::Target_value_layout_state</a> next_elem_state(</div>
<div class="line">                                    layout-&gt;get_nested_state(1, array_state));</div>
<div class="line"></div>
<div class="line">                                <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49" title="The possible kinds of values. ">mi::neuraylib::IValue::Kind</a> kind;</div>
<div class="line">                                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> param_size;</div>
<div class="line">                                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> start_offset = layout-&gt;get_layout(</div>
<div class="line">                                    kind, param_size, array_state);</div>
<div class="line">                                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> next_offset = layout-&gt;get_layout(</div>
<div class="line">                                    kind, param_size, next_elem_state);</div>
<div class="line">                                param_array_pitch = next_offset - start_offset;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a6650261e99a4bf06f96b8ff2e665b576" title="An enum value. See mi::neuraylib::IValue_enum. ">mi::neuraylib::IValue::VK_ENUM</a>:</div>
<div class="line">                    {</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IValue_enum const&gt;</a> val(</div>
<div class="line">                            arg.get_interface&lt;<a class="code" href="classmi_1_1neuraylib_1_1IValue__enum.html" title="A value of type enum. ">mi::neuraylib::IValue_enum</a> <span class="keyword">const</span>&gt;());</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IType_enum const&gt;</a> val_type(</div>
<div class="line">                            val-&gt;get_type());</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// prepare info for this enum type if not seen so far</span></div>
<div class="line">                        <span class="keyword">const</span> Enum_type_info *info = mat_info.get_enum_type(val_type-&gt;get_symbol());</div>
<div class="line">                        <span class="keywordflow">if</span> (info == <span class="keyword">nullptr</span>) {</div>
<div class="line">                            std::shared_ptr&lt;Enum_type_info&gt; p(<span class="keyword">new</span> Enum_type_info());</div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0, n = val_type-&gt;get_size(); i &lt; n; ++i) {</div>
<div class="line">                                p-&gt;add(val_type-&gt;get_value_name(i), val_type-&gt;get_value_code(i));</div>
<div class="line">                            }</div>
<div class="line">                            mat_info.add_enum_type(val_type-&gt;get_symbol(), p);</div>
<div class="line">                            info = p.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>();</div>
<div class="line">                        }</div>
<div class="line">                        enum_type = <a class="code" href="group__mi__base__ilogger.html#ga8a3f930a48b91468c97b023f20a32682" title="Manipulator for mi::base::Log_stream. ">info</a>;</div>
<div class="line"></div>
<div class="line">                        param_kind = Param_info::PK_ENUM;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49ae5c46734d11a735e06d32592029cf431" title="A string value. See mi::neuraylib::IValue_string. ">mi::neuraylib::IValue::VK_STRING</a>:</div>
<div class="line">                    param_kind = Param_info::PK_STRING;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a0f895e312abdc4b60a6daf839201ffdf" title="A texture value. See mi::neuraylib::IValue_texture. ">mi::neuraylib::IValue::VK_TEXTURE</a>:</div>
<div class="line">                    param_kind = Param_info::PK_TEXTURE;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a20b13c863c24f6abb95789b4304f0306" title="A light_profile value. See mi::neuraylib::IValue_light_profile. ">mi::neuraylib::IValue::VK_LIGHT_PROFILE</a>:</div>
<div class="line">                    param_kind = Param_info::PK_LIGHT_PROFILE;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49a5e9099894cb1808ecbd25bcdac813654" title="A bsdf_measurement value. See mi::neuraylib::IValue_bsdf_measurement. ">mi::neuraylib::IValue::VK_BSDF_MEASUREMENT</a>:</div>
<div class="line">                    param_kind = Param_info::PK_BSDF_MEASUREMENT;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    <span class="comment">// Unsupported? -&gt; skip</span></div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Get the offset of the argument within the target argument block</span></div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__value__layout__state.html" title="Structure representing the state during traversal of the nested layout. ">mi::neuraylib::Target_value_layout_state</a> state(layout-&gt;get_nested_state(j));</div>
<div class="line">                <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49" title="The possible kinds of values. ">mi::neuraylib::IValue::Kind</a> kind2;</div>
<div class="line">                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> param_size;</div>
<div class="line">                <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> offset = layout-&gt;get_layout(kind2, param_size, state);</div>
<div class="line">                check_success(kind == kind2);</div>
<div class="line"></div>
<div class="line">                Param_info param_info(</div>
<div class="line">                    j,</div>
<div class="line">                    name,</div>
<div class="line">                    name,</div>
<div class="line">                    <span class="comment">/*group_name=*/</span> <span class="keyword">nullptr</span>,</div>
<div class="line">                    param_kind,</div>
<div class="line">                    param_array_elem_kind,</div>
<div class="line">                    param_array_size,</div>
<div class="line">                    param_array_pitch,</div>
<div class="line">                    arg_block_data + offset,</div>
<div class="line">                    enum_type);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Check for annotation info</span></div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IAnnotation_block const&gt;</a> anno_block(</div>
<div class="line">                    anno_list-&gt;get_annotation_block(name));</div>
<div class="line">                <span class="keywordflow">if</span> (anno_block) {</div>
<div class="line">                    <a class="code" href="classmi_1_1neuraylib_1_1Annotation__wrapper.html" title="A wrapper around the interfaces for MDL annotations. ">mi::neuraylib::Annotation_wrapper</a> annos(anno_block.get());</div>
<div class="line">                    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> anno_index =</div>
<div class="line">                        annos.<a class="code" href="classmi_1_1neuraylib_1_1Annotation__wrapper.html#a1aa81843b704d77147143a049d44cd14" title="Get the index of an annotation based on its name for one of the annotations. ">get_annotation_index</a>(<span class="stringliteral">&quot;::anno::soft_range(float,float)&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">if</span> (anno_index == <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(-1)) {</div>
<div class="line">                        anno_index = annos.get_annotation_index(<span class="stringliteral">&quot;::anno::hard_range(float,float)&quot;</span>);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">if</span> (anno_index != <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(-1)) {</div>
<div class="line">                        annos.get_annotation_param_value(anno_index, 0, param_info.range_min());</div>
<div class="line">                        annos.get_annotation_param_value(anno_index, 1, param_info.range_max());</div>
<div class="line">                    }</div>
<div class="line">                    anno_index = annos.get_annotation_index(<span class="stringliteral">&quot;::anno::display_name(string)&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">if</span> (anno_index != <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(-1)) {</div>
<div class="line">                        annos.get_annotation_param_value(anno_index, 0, param_info.display_name());</div>
<div class="line">                    }</div>
<div class="line">                    anno_index = annos.get_annotation_index(<span class="stringliteral">&quot;::anno::in_group(string)&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">if</span> (anno_index != <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(-1)) {</div>
<div class="line">                        annos.get_annotation_param_value(anno_index, 0, param_info.group_name());</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                mat_info.add_sorted_by_group(param_info);</div>
<div class="line">            }</div>
<div class="line">            mat_infos.push_back(mat_info);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        std::chrono::duration&lt;double&gt; state_update_time( 0.0 );</div>
<div class="line">        std::chrono::duration&lt;double&gt; render_time( 0.0 );</div>
<div class="line">        std::chrono::duration&lt;double&gt; display_time( 0.0 );</div>
<div class="line">        <span class="keywordtype">char</span> stats_text[128];</div>
<div class="line">        <span class="keywordtype">int</span> last_update_frames = -1;</div>
<div class="line">        <span class="keyword">auto</span> last_update_time = std::chrono::steady_clock::now();</div>
<div class="line">        <span class="keyword">const</span> std::chrono::duration&lt;double&gt; update_min_interval( 0.5 );</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Main render loop</span></div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            std::chrono::time_point&lt;std::chrono::steady_clock&gt; t0;</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!options.opengl)</div>
<div class="line">            {</div>
<div class="line">                kernel_params.resolution.x = width;</div>
<div class="line">                kernel_params.resolution.y = height;</div>
<div class="line">                kernel_params.accum_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(accum_buffer);</div>
<div class="line">                kernel_params.albedo_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(aux_albedo_buffer);</div>
<div class="line">                kernel_params.normal_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(aux_normal_buffer);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                <span class="comment">// Check if desired number of samples is reached</span></div>
<div class="line">                <span class="keywordflow">if</span> (kernel_params.iteration_start &gt;= options.iterations) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;rendering done&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                    save_result(</div>
<div class="line">                        accum_buffer, width, height,</div>
<div class="line">                        next_filename_base + filename_ext,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line"></div>
<div class="line">                    save_result(</div>
<div class="line">                        aux_albedo_buffer, width, height,</div>
<div class="line">                        next_filename_base +  <span class="stringliteral">&quot;_albedo&quot;</span> + filename_ext,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line"></div>
<div class="line">                    save_result(</div>
<div class="line">                        aux_normal_buffer, width, height,</div>
<div class="line">                        next_filename_base + <span class="stringliteral">&quot;_normal&quot;</span> + filename_ext,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line"></div>
<div class="line">                    std::cout &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// All materials have been rendered? -&gt; done</span></div>
<div class="line">                    <span class="keywordflow">if</span> (kernel_params.current_material + 1 &gt;= material_bundle.size())</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (material_bundle[kernel_params.current_material].contains_hair_bsdf == 0)</div>
<div class="line">                        kernel_params.geometry = GT_SPHERE;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        kernel_params.geometry = GT_HAIR;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Start new image with next material</span></div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line">                    ++kernel_params.current_material;</div>
<div class="line">                    next_filename_base =</div>
<div class="line">                        filename_base + <span class="stringliteral">&quot;-&quot;</span> + to_string(kernel_params.current_material);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                std::cout</div>
<div class="line">                    &lt;&lt; <span class="stringliteral">&quot;rendering iterations &quot;</span> &lt;&lt; kernel_params.iteration_start &lt;&lt; <span class="stringliteral">&quot; to &quot;</span></div>
<div class="line">                    &lt;&lt; kernel_params.iteration_start + kernel_params.iteration_num &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                t0 = std::chrono::steady_clock::now();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Check for termination</span></div>
<div class="line">                <span class="keywordflow">if</span> (glfwWindowShouldClose(window))</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Poll for events and process them</span></div>
<div class="line">                glfwPollEvents();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Check if buffers need to be resized</span></div>
<div class="line">                <span class="keywordtype">int</span> nwidth, nheight;</div>
<div class="line">                glfwGetFramebufferSize(window, &amp;nwidth, &amp;nheight);</div>
<div class="line">                <span class="keywordflow">if</span> (nwidth != width || nheight != height)</div>
<div class="line">                {</div>
<div class="line">                    width = nwidth;</div>
<div class="line">                    height = nheight;</div>
<div class="line"></div>
<div class="line">                    gl_display-&gt;resize(width, height);</div>
<div class="line"></div>
<div class="line">                    resize_buffers(</div>
<div class="line">                        &amp;accum_buffer, width, height);</div>
<div class="line">                    kernel_params.accum_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(accum_buffer);</div>
<div class="line"></div>
<div class="line">                    resize_buffers(&amp;aux_albedo_buffer, width, height);</div>
<div class="line">                    kernel_params.albedo_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(aux_albedo_buffer);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">                    resize_buffers(&amp;aux_normal_buffer, width, height);</div>
<div class="line">                    kernel_params.normal_buffer = <span class="keyword">reinterpret_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(aux_normal_buffer);</div>
<div class="line"></div>
<div class="line">                    kernel_params.resolution.x = width;</div>
<div class="line">                    kernel_params.resolution.y = height;</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Don&#39;t render anything, if minimized</span></div>
<div class="line">                <span class="keywordflow">if</span> (width == 0 || height == 0) {</div>
<div class="line">                    <span class="comment">// Wait until something happens</span></div>
<div class="line">                    glfwWaitEvents();</div>
<div class="line">                    <span class="keywordflow">continue</span>;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ImGui_ImplOpenGL3_NewFrame();</div>
<div class="line">                ImGui_ImplGlfw_NewFrame();</div>
<div class="line">                ImGui::NewFrame();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Create material parameter editor window</span></div>
<div class="line"></div>
<div class="line">                ImGui::SetNextWindowPos(ImVec2(10, 100), ImGuiCond_FirstUseEver);</div>
<div class="line">                ImGui::SetNextWindowSize(</div>
<div class="line">                    ImVec2(360 * options.gui_scale, 600 * options.gui_scale),</div>
<div class="line">                    ImGuiCond_FirstUseEver);</div>
<div class="line">                ImGui::Begin(<span class="stringliteral">&quot;Settings&quot;</span>);</div>
<div class="line">                ImGui::SetWindowFontScale(options.gui_scale);</div>
<div class="line">                ImGui::PushItemWidth(-200 * options.gui_scale);</div>
<div class="line">                <span class="keywordflow">if</span> (options.use_class_compilation)</div>
<div class="line">                    ImGui::Text(<span class="stringliteral">&quot;CTRL + Click to manually enter numbers&quot;</span>);</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    ImGui::Text(<span class="stringliteral">&quot;Parameter editing requires class compilation.&quot;</span>);</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (kernel_params.enable_auxiliary_output)</div>
<div class="line">                {</div>
<div class="line">                    ImGui::Dummy(ImVec2(0.0f, 3.0f));</div>
<div class="line">                    ImGui::Text(<span class="stringliteral">&quot;Display options&quot;</span>);</div>
<div class="line">                    ImGui::Separator();</div>
<div class="line"></div>
<div class="line">                    std::string current_lpe_name = lpe_state_machine.get_expression_name(</div>
<div class="line">                        kernel_params.lpe_ouput_expression);</div>
<div class="line">                    <span class="keywordflow">if</span> (ImGui::BeginCombo(<span class="stringliteral">&quot;LPE&quot;</span>, current_lpe_name.c_str()))</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; lpe_state_machine.get_expression_count(); ++i)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">char</span>* name = lpe_state_machine.get_expression_name(i);</div>
<div class="line">                            <span class="keywordtype">bool</span> is_selected = (i == kernel_params.lpe_ouput_expression);</div>
<div class="line">                            <span class="keywordflow">if</span> (ImGui::Selectable(name, is_selected))</div>
<div class="line">                            {</div>
<div class="line">                                kernel_params.lpe_ouput_expression = i;</div>
<div class="line">                                kernel_params.iteration_start = 0;</div>
<div class="line">                            }</div>
<div class="line">                            <span class="keywordflow">if</span> (is_selected)</div>
<div class="line">                                ImGui::SetItemDefaultFocus();</div>
<div class="line">                        }</div>
<div class="line">                        ImGui::EndCombo();</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    std::string current_display_buffer =</div>
<div class="line">                        to_string((Display_buffer_options) kernel_params.display_buffer_index);</div>
<div class="line">                    <span class="keywordflow">if</span> (ImGui::BeginCombo(<span class="stringliteral">&quot;buffer&quot;</span>, current_display_buffer.c_str()))</div>
<div class="line">                    {</div>
<div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; (unsigned) DISPLAY_BUFFER_COUNT; ++i)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keyword">const</span> std::string &amp;name = to_string((Display_buffer_options) i);</div>
<div class="line">                            <span class="keywordtype">bool</span> is_selected = (current_display_buffer == name);</div>
<div class="line">                            <span class="keywordflow">if</span> (ImGui::Selectable(name.c_str(), is_selected))</div>
<div class="line">                            {</div>
<div class="line">                                kernel_params.display_buffer_index = i;</div>
<div class="line">                                kernel_params.iteration_start = 0;</div>
<div class="line">                            }</div>
<div class="line">                            <span class="keywordflow">if</span> (is_selected)</div>
<div class="line">                                ImGui::SetItemDefaultFocus();</div>
<div class="line">                        }</div>
<div class="line">                        ImGui::EndCombo();</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ImGui::Dummy(ImVec2(0.0f, 3.0f));</div>
<div class="line">                ImGui::Text(<span class="stringliteral">&quot;Light parameters&quot;</span>);</div>
<div class="line">                ImGui::Separator();</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (ImGui::ColorEdit3(<span class="stringliteral">&quot;Point Light Color&quot;</span>, &amp;kernel_params.light_color.x))</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (ImGui::SliderFloat(<span class="stringliteral">&quot;Point Light Intensity&quot;</span>,</div>
<div class="line">                    &amp;kernel_params.light_intensity, 0.0f, 50000.0f))</div>
<div class="line">                        kernel_params.iteration_start = 0;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (ImGui::SliderFloat(<span class="stringliteral">&quot;Environment Intensity Scale&quot;</span>,</div>
<div class="line">                    &amp;kernel_params.env_intensity, 0.0f, 10.0f))</div>
<div class="line">                        kernel_params.iteration_start = 0;</div>
<div class="line"></div>
<div class="line">                <span class="keywordtype">float</span> env_rot_degree = kernel_params.env_rotation / float(M_PI) * 180.0f;</div>
<div class="line">                <span class="keywordflow">if</span> (ImGui::SliderFloat(<span class="stringliteral">&quot;Environment Rotation&quot;</span>,</div>
<div class="line">                    &amp;env_rot_degree, 0.0f, 360.0f))</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// wrap in case of negative input</span></div>
<div class="line">                    <span class="comment">// we don&#39;t want fmodf behavior for negative values</span></div>
<div class="line">                    env_rot_degree -= floorf(env_rot_degree / 360.0f) * 360.f;</div>
<div class="line">                    kernel_params.env_rotation = fmodf(env_rot_degree, 360.0f) / 180.0f * float(M_PI);</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ImGui::Dummy(ImVec2(0.0f, 3.0f));</div>
<div class="line">                ImGui::Text(<span class="stringliteral">&quot;Material parameters&quot;</span>);</div>
<div class="line">                ImGui::Separator();</div>
<div class="line"></div>
<div class="line">                Material_info &amp;mat_info = mat_infos[</div>
<div class="line">                    material_bundle[kernel_params.current_material].compiled_material_index];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Print material name</span></div>
<div class="line">                ImGui::Text(<span class="stringliteral">&quot;%s&quot;</span>, mat_info.name());</div>
<div class="line"></div>
<div class="line">                <span class="keywordtype">bool</span> changed = <span class="keyword">false</span>;</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">char</span> *group_name = <span class="keyword">nullptr</span>;</div>
<div class="line">                <span class="keywordtype">int</span> <span class="keywordtype">id</span> = 0;</div>
<div class="line">                <span class="keywordflow">for</span> (std::list&lt;Param_info&gt;::iterator it = mat_info.params().begin(),</div>
<div class="line">                    end = mat_info.params().end(); it != end; ++it, ++id)</div>
<div class="line">                {</div>
<div class="line">                    Param_info &amp;param = *it;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Ensure unique ID even for parameters with same display names</span></div>
<div class="line">                    ImGui::PushID(<span class="keywordtype">id</span>);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Group name changed? -&gt; Start new group with new header</span></div>
<div class="line">                    <span class="keywordflow">if</span> ((!param.group_name() != !group_name) ||</div>
<div class="line">                        (param.group_name() &amp;&amp;</div>
<div class="line">                            (!group_name || strcmp(group_name, param.group_name()) != 0)))</div>
<div class="line">                    {</div>
<div class="line">                        ImGui::Separator();</div>
<div class="line">                        <span class="keywordflow">if</span> (param.group_name() != <span class="keyword">nullptr</span>)</div>
<div class="line">                            ImGui::Text(<span class="stringliteral">&quot;%s&quot;</span>, param.group_name());</div>
<div class="line">                        group_name = param.group_name();</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Choose proper edit control depending on the parameter kind</span></div>
<div class="line">                    <span class="keywordflow">switch</span> (param.kind()) {</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_FLOAT:</div>
<div class="line">                        changed |= ImGui::SliderFloat(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">float</span>&gt;(),</div>
<div class="line">                            param.range_min(),</div>
<div class="line">                            param.range_max());</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_FLOAT2:</div>
<div class="line">                        changed |= ImGui::SliderFloat2(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">float</span>&gt;(),</div>
<div class="line">                            param.range_min(),</div>
<div class="line">                            param.range_max());</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_FLOAT3:</div>
<div class="line">                        changed |= ImGui::SliderFloat3(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">float</span>&gt;(),</div>
<div class="line">                            param.range_min(),</div>
<div class="line">                            param.range_max());</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_COLOR:</div>
<div class="line">                        changed |= ImGui::ColorEdit3(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">float</span>&gt;());</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_BOOL:</div>
<div class="line">                        changed |= ImGui::Checkbox(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">bool</span>&gt;());</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_INT:</div>
<div class="line">                        changed |= ImGui::SliderInt(</div>
<div class="line">                            param.display_name(),</div>
<div class="line">                            &amp;param.data&lt;<span class="keywordtype">int</span>&gt;(),</div>
<div class="line">                            <span class="keywordtype">int</span>(param.range_min()),</div>
<div class="line">                            <span class="keywordtype">int</span>(param.range_max()));</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_ARRAY:</div>
<div class="line">                        {</div>
<div class="line">                            ImGui::Text(<span class="stringliteral">&quot;%s&quot;</span>, param.display_name());</div>
<div class="line">                            ImGui::Indent(16.0f * options.gui_scale);</div>
<div class="line">                            <span class="keywordtype">char</span> *ptr = &amp;param.data&lt;<span class="keywordtype">char</span>&gt;();</div>
<div class="line">                            <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0, n = param.array_size(); i &lt; n; ++i) {</div>
<div class="line">                                std::string idx_str = to_string(i);</div>
<div class="line">                                <span class="keywordflow">switch</span> (param.array_elem_kind()) {</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_FLOAT:</div>
<div class="line">                                    changed |= ImGui::SliderFloat(</div>
<div class="line">                                        idx_str.c_str(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(ptr),</div>
<div class="line">                                        param.range_min(),</div>
<div class="line">                                        param.range_max());</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_FLOAT2:</div>
<div class="line">                                    changed |= ImGui::SliderFloat2(</div>
<div class="line">                                        idx_str.c_str(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(ptr),</div>
<div class="line">                                        param.range_min(),</div>
<div class="line">                                        param.range_max());</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_FLOAT3:</div>
<div class="line">                                    changed |= ImGui::SliderFloat3(</div>
<div class="line">                                        idx_str.c_str(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(ptr),</div>
<div class="line">                                        param.range_min(),</div>
<div class="line">                                        param.range_max());</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_COLOR:</div>
<div class="line">                                    changed |= ImGui::ColorEdit3(</div>
<div class="line">                                        idx_str.c_str(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span> *<span class="keyword">&gt;</span>(ptr));</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_BOOL:</div>
<div class="line">                                    changed |= ImGui::Checkbox(</div>
<div class="line">                                        param.display_name(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">bool</span> *<span class="keyword">&gt;</span>(ptr));</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">case</span> Param_info::PK_INT:</div>
<div class="line">                                    changed |= ImGui::SliderInt(</div>
<div class="line">                                        param.display_name(),</div>
<div class="line">                                        <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(ptr),</div>
<div class="line">                                        <span class="keywordtype">int</span>(param.range_min()),</div>
<div class="line">                                        <span class="keywordtype">int</span>(param.range_max()));</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                <span class="keywordflow">default</span>:</div>
<div class="line">                                    assert(<span class="keyword">false</span> || <span class="stringliteral">&quot;Array element type invalid or unhandled.&quot;</span>);</div>
<div class="line">                                }</div>
<div class="line">                                ptr += param.array_pitch();</div>
<div class="line">                            }</div>
<div class="line">                            ImGui::Unindent(16.0f * options.gui_scale);</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_ENUM:</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keywordtype">int</span> value = param.data&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">                            std::string curr_value;</div>
<div class="line"></div>
<div class="line">                            <span class="keyword">const</span> Enum_type_info *info = param.enum_info();</div>
<div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, n = info-&gt;values.size(); i &lt; n; ++i) {</div>
<div class="line">                                <span class="keywordflow">if</span> (info-&gt;values[i].value == value) {</div>
<div class="line">                                    curr_value = info-&gt;values[i].name;</div>
<div class="line">                                    <span class="keywordflow">break</span>;</div>
<div class="line">                                }</div>
<div class="line">                            }</div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">if</span> (ImGui::BeginCombo(param.display_name(), curr_value.c_str())) {</div>
<div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, n = info-&gt;values.size(); i &lt; n; ++i) {</div>
<div class="line">                                    <span class="keyword">const</span> std::string &amp;name = info-&gt;values[i].name;</div>
<div class="line">                                    <span class="keywordtype">bool</span> is_selected = (curr_value == name);</div>
<div class="line">                                    <span class="keywordflow">if</span> (ImGui::Selectable(</div>
<div class="line">                                        info-&gt;values[i].name.c_str(), is_selected)) {</div>
<div class="line">                                        param.data&lt;<span class="keywordtype">int</span>&gt;() = info-&gt;values[i].value;</div>
<div class="line">                                        changed = <span class="keyword">true</span>;</div>
<div class="line">                                    }</div>
<div class="line">                                    <span class="keywordflow">if</span> (is_selected)</div>
<div class="line">                                        ImGui::SetItemDefaultFocus();</div>
<div class="line">                                }</div>
<div class="line">                                ImGui::EndCombo();</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_STRING:</div>
<div class="line">                        {</div>
<div class="line">                            std::vector&lt;char&gt; buf;</div>
<div class="line"></div>
<div class="line">                            <span class="keywordtype">size_t</span> max_len = constant_table.get_max_length();</div>
<div class="line">                            max_len = max_len &gt; 63 ? max_len + 1 : 64;</div>
<div class="line"></div>
<div class="line">                            buf.resize(max_len);</div>
<div class="line"></div>
<div class="line">                            <span class="comment">// fill the current value</span></div>
<div class="line">                            <span class="keywordtype">unsigned</span> curr_index = param.data&lt;<span class="keywordtype">unsigned</span>&gt;();</div>
<div class="line">                            <span class="keyword">const</span> <span class="keywordtype">char</span> *opt = constant_table.get_string(curr_index);</div>
<div class="line">                            strcpy(buf.data(), opt != <span class="keyword">nullptr</span> ? opt : <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line"></div>
<div class="line">                            <span class="keywordflow">if</span> (ImGui::InputText(</div>
<div class="line">                                param.display_name(),</div>
<div class="line">                                buf.data(), buf.size(),</div>
<div class="line">                                ImGuiInputTextFlags_EnterReturnsTrue))</div>
<div class="line">                            {</div>
<div class="line">                                <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = constant_table.get_id_for_string(buf.data());</div>
<div class="line"></div>
<div class="line">                                param.data&lt;<span class="keywordtype">unsigned</span>&gt;() = <span class="keywordtype">id</span>;</div>
<div class="line">                                changed = <span class="keyword">true</span>;</div>
<div class="line">                            }</div>
<div class="line">                        }</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_TEXTURE:</div>
<div class="line">                        changed |= handle_resource(param, texture_table);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_LIGHT_PROFILE:</div>
<div class="line">                        changed |= handle_resource(param, lp_table);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_BSDF_MEASUREMENT:</div>
<div class="line">                        changed |= handle_resource(param, bm_table);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    <span class="keywordflow">case</span> Param_info::PK_UNKNOWN:</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    ImGui::PopID();</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (options.enable_derivatives) {</div>
<div class="line">                    ImGui::Separator();</div>
<div class="line">                    <span class="keywordtype">bool</span> b = kernel_params.use_derivatives != 0;</div>
<div class="line">                    <span class="keywordflow">if</span> (ImGui::Checkbox(<span class="stringliteral">&quot;Use derivatives&quot;</span>, &amp;b)) {</div>
<div class="line">                        kernel_params.iteration_start = 0;</div>
<div class="line">                        kernel_params.use_derivatives = b;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ImGui::PopItemWidth();</div>
<div class="line">                ImGui::End();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// If any material argument changed, update the target argument block on the device</span></div>
<div class="line">                <span class="keywordflow">if</span> (changed) {</div>
<div class="line">                    material_gpu_context.update_device_argument_block(</div>
<div class="line">                        material_bundle[kernel_params.current_material].argument_block_index);</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Handle events</span></div>
<div class="line">                Window_context *ctx =</div>
<div class="line">                    <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(glfwGetWindowUserPointer(window));</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;save_result &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {</div>
<div class="line">                    save_result(</div>
<div class="line">                        accum_buffer,</div>
<div class="line">                        width, height,</div>
<div class="line">                        options.outputfile,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line"></div>
<div class="line">                    save_result(</div>
<div class="line">                        aux_albedo_buffer,</div>
<div class="line">                        width, height,</div>
<div class="line">                        filename_base + <span class="stringliteral">&quot;_albedo&quot;</span> + filename_ext,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line"></div>
<div class="line">                    save_result(</div>
<div class="line">                        aux_normal_buffer,</div>
<div class="line">                        width, height,</div>
<div class="line">                        filename_base + <span class="stringliteral">&quot;_normal&quot;</span> + filename_ext,</div>
<div class="line">                        image_api, mdl_impexp_api);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;exposure_event &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {</div>
<div class="line">                    kernel_params.exposure_scale = powf(2.0f, ctx-&gt;exposure);</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;key_event &amp;&amp; !ImGui::GetIO().WantCaptureKeyboard) {</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Update change material</span></div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> num_materials = unsigned(material_bundle.size());</div>
<div class="line">                    kernel_params.current_material = (kernel_params.current_material +</div>
<div class="line">                        ctx-&gt;material_index_delta + num_materials) % num_materials;</div>
<div class="line">                    ctx-&gt;material_index_delta = 0;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (material_bundle[kernel_params.current_material].contains_hair_bsdf == 0)</div>
<div class="line">                        kernel_params.geometry = GT_SPHERE;</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        kernel_params.geometry = GT_HAIR;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;mouse_button - 1 == GLFW_MOUSE_BUTTON_LEFT) {</div>
<div class="line">                    <span class="comment">// Only accept button press when not hovering GUI window</span></div>
<div class="line">                    <span class="keywordflow">if</span> (ctx-&gt;mouse_button_action == GLFW_PRESS &amp;&amp;</div>
<div class="line">                            !ImGui::GetIO().WantCaptureMouse) {</div>
<div class="line">                        ctx-&gt;moving = <span class="keyword">true</span>;</div>
<div class="line">                        glfwGetCursorPos(window, &amp;ctx-&gt;move_start_x, &amp;ctx-&gt;move_start_y);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        ctx-&gt;moving = <span class="keyword">false</span>;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;mouse_wheel_delta &amp;&amp; !ImGui::GetIO().WantCaptureMouse) {</div>
<div class="line">                    ctx-&gt;zoom += ctx-&gt;mouse_wheel_delta;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">if</span> (ctx-&gt;mouse_event &amp;&amp; !ImGui::GetIO().WantCaptureMouse) {</div>
<div class="line">                    kernel_params.iteration_start = 0;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Update camera</span></div>
<div class="line">                    phi -= ctx-&gt;move_dx * 0.001 * M_PI;</div>
<div class="line">                    theta -= ctx-&gt;move_dy * 0.001 * M_PI;</div>
<div class="line">                    theta = std::max(theta, 0.00 * M_PI);</div>
<div class="line">                    theta = std::min(theta, 1.00 * M_PI);</div>
<div class="line">                    ctx-&gt;move_dx = ctx-&gt;move_dy = 0.0;</div>
<div class="line"></div>
<div class="line">                    update_camera(kernel_params, phi, theta, base_dist, ctx-&gt;zoom);</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Clear all events</span></div>
<div class="line">                ctx-&gt;save_result = <span class="keyword">false</span>;</div>
<div class="line">                ctx-&gt;key_event = <span class="keyword">false</span>;</div>
<div class="line">                ctx-&gt;mouse_event = <span class="keyword">false</span>;</div>
<div class="line">                ctx-&gt;exposure_event = <span class="keyword">false</span>;</div>
<div class="line">                ctx-&gt;mouse_wheel_delta = 0;</div>
<div class="line">                ctx-&gt;mouse_button = 0;</div>
<div class="line"></div>
<div class="line">                <span class="keyword">auto</span> t1 = std::chrono::steady_clock::now();</div>
<div class="line">                state_update_time += t1 - t0;</div>
<div class="line">                t0 = t1;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Map GL buffer for access with CUDA</span></div>
<div class="line">                kernel_params.display_buffer =</div>
<div class="line">                    <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(gl_display-&gt;map(0));</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="comment">// Launch kernel</span></div>
<div class="line">            dim3 threads_per_block(16, 16);</div>
<div class="line">            dim3 num_blocks((width + 15) / 16, (height + 15) / 16);</div>
<div class="line">            <span class="keywordtype">void</span> *params[] = { &amp;kernel_params };</div>
<div class="line">            check_cuda_success(cuLaunchKernel(</div>
<div class="line">                cuda_function,</div>
<div class="line">                num_blocks.x, num_blocks.y, num_blocks.z,</div>
<div class="line">                threads_per_block.x, threads_per_block.y, threads_per_block.z,</div>
<div class="line">                0, <span class="keyword">nullptr</span>, params, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            kernel_params.iteration_start += kernel_params.iteration_num;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Make sure, any debug::print()s are written to the console</span></div>
<div class="line">            check_cuda_success(cuStreamSynchronize(0));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (options.opengl)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Unmap GL buffer</span></div>
<div class="line">                gl_display-&gt;unmap(0);</div>
<div class="line"></div>
<div class="line">                <span class="keyword">auto</span> t1 = std::chrono::steady_clock::now();</div>
<div class="line">                render_time += t1 - t0;</div>
<div class="line">                t0 = t1;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Render GL buffer</span></div>
<div class="line">                gl_display-&gt;update_display();</div>
<div class="line"></div>
<div class="line">                t1 = std::chrono::steady_clock::now();</div>
<div class="line">                display_time += t1 - t0;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Render stats window</span></div>
<div class="line">                ImGui::SetNextWindowPos(ImVec2(10, 10));</div>
<div class="line">                ImGui::Begin(<span class="stringliteral">&quot;##notitle&quot;</span>, <span class="keyword">nullptr</span>,</div>
<div class="line">                    ImGuiWindowFlags_NoDecoration |</div>
<div class="line">                    ImGuiWindowFlags_AlwaysAutoResize |</div>
<div class="line">                    ImGuiWindowFlags_NoSavedSettings |</div>
<div class="line">                    ImGuiWindowFlags_NoFocusOnAppearing |</div>
<div class="line">                    ImGuiWindowFlags_NoNav);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Update stats only every 0.5s</span></div>
<div class="line">                ++last_update_frames;</div>
<div class="line">                <span class="keywordflow">if</span> (t1 - last_update_time &gt; update_min_interval || last_update_frames == 0) {</div>
<div class="line">                    <span class="keyword">typedef</span> std::chrono::duration&lt;double, std::milli&gt; durationMs;</div>
<div class="line"></div>
<div class="line">                    snprintf(stats_text, <span class="keyword">sizeof</span>(stats_text),</div>
<div class="line">                        <span class="stringliteral">&quot;%5.1f fps\n\n&quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;state update: %8.1f ms\n&quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;render:       %8.1f ms\n&quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;display:      %8.1f ms\n&quot;</span>,</div>
<div class="line">                        last_update_frames / std::chrono::duration&lt;double&gt;(</div>
<div class="line">                            t1 - last_update_time).count(),</div>
<div class="line">                        (durationMs(state_update_time) / last_update_frames).count(),</div>
<div class="line">                        (durationMs(render_time) / last_update_frames).count(),</div>
<div class="line">                        (durationMs(display_time) / last_update_frames).count());</div>
<div class="line"></div>
<div class="line">                    last_update_time = t1;</div>
<div class="line">                    last_update_frames = 0;</div>
<div class="line">                    state_update_time = render_time = display_time =</div>
<div class="line">                        std::chrono::duration&lt;double&gt;::zero();</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                ImGui::TextUnformatted(stats_text);</div>
<div class="line">                ImGui::End();</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Show the GUI</span></div>
<div class="line">                ImGui::Render();</div>
<div class="line">                ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Swap front and back buffers</span></div>
<div class="line">                glfwSwapBuffers(window);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup CUDA</span></div>
<div class="line">    check_cuda_success(cudaDestroyTextureObject(kernel_params.env_tex));</div>
<div class="line">    check_cuda_success(cudaFreeArray(env_tex_data));</div>
<div class="line">    check_cuda_success(cuMemFree(env_accel));</div>
<div class="line">    check_cuda_success(cuMemFree(accum_buffer));</div>
<div class="line">    check_cuda_success(cuMemFree(aux_albedo_buffer));</div>
<div class="line">    check_cuda_success(cuMemFree(aux_normal_buffer));</div>
<div class="line">    check_cuda_success(cuMemFree(material_buffer));</div>
<div class="line">    check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(kernel_params.lpe_state_table)));</div>
<div class="line">    check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(kernel_params.lpe_final_mask)));</div>
<div class="line">    check_cuda_success(cuModuleUnload(cuda_module));</div>
<div class="line">    uninit_cuda(cuda_context);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup OpenGL</span></div>
<div class="line">    <span class="keywordflow">if</span> (options.opengl) {</div>
<div class="line">        <span class="keyword">delete</span> gl_display;</div>
<div class="line">        gl_display = <span class="keyword">nullptr</span>;</div>
<div class="line">        ImGui_ImplOpenGL3_Shutdown();</div>
<div class="line">        ImGui_ImplGlfw_Shutdown();</div>
<div class="line">        ImGui::DestroyContext();</div>
<div class="line">        glfwDestroyWindow(window);</div>
<div class="line">        glfwTerminate();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns true, if the string str starts with the given prefix, false otherwise.</span></div>
<div class="line"><span class="keywordtype">bool</span> starts_with(std::string <span class="keyword">const</span> &amp;str, std::string <span class="keyword">const</span> &amp;prefix)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> str.size() &gt;= prefix.size() &amp;&amp; str.compare(0, prefix.size(), prefix) == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create application material representation for use in our CUDA kernel</span></div>
<div class="line">Df_cuda_material create_cuda_material(</div>
<div class="line">    <span class="keywordtype">size_t</span> target_code_index,</div>
<div class="line">    <span class="keywordtype">size_t</span> compiled_material_index,</div>
<div class="line">    std::vector&lt;mi::neuraylib::Target_function_description&gt; <span class="keyword">const</span>&amp; descs,</div>
<div class="line">    <span class="keywordtype">bool</span> use_hair_bsdf)</div>
<div class="line">{</div>
<div class="line">    Df_cuda_material mat;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// shared by all generated functions of the same material</span></div>
<div class="line">    <span class="comment">// used here to alter the materials parameter set</span></div>
<div class="line">    mat.compiled_material_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(compiled_material_index);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Note: the same argument_block_index is filled into all function descriptions of a</span></div>
<div class="line">    <span class="comment">//       material, if any function uses it</span></div>
<div class="line">    mat.argument_block_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[0].argument_block_index);</div>
<div class="line"></div>
<div class="line">    mat.init.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">    mat.init.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[0].function_index);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (!use_hair_bsdf)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// identify the BSDF function by target_code_index (i&#39;th link unit)</span></div>
<div class="line">        <span class="comment">// and the function_index inside this target_code.</span></div>
<div class="line">        <span class="comment">// same for the EDF and the intensity expression.</span></div>
<div class="line"></div>
<div class="line">        mat.bsdf.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.bsdf.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[1].function_index);</div>
<div class="line"></div>
<div class="line">        mat.edf.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.edf.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[2].function_index);</div>
<div class="line"></div>
<div class="line">        mat.emission_intensity.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.emission_intensity.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[3].function_index);</div>
<div class="line"></div>
<div class="line">        mat.volume_absorption.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.volume_absorption.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[4].function_index);</div>
<div class="line"></div>
<div class="line">        mat.thin_walled.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.thin_walled.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[5].function_index);</div>
<div class="line"></div>
<div class="line">        mat.cutout_opacity.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.cutout_opacity.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[6].function_index);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        mat.bsdf.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(target_code_index);</div>
<div class="line">        mat.bsdf.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(descs[7].function_index);</div>
<div class="line">        mat.contains_hair_bsdf = 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// init tag maps with zeros (optional)</span></div>
<div class="line">    memset(mat.bsdf_mtag_to_gtag_map, 0, MAX_DF_HANDLES * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>));</div>
<div class="line">    memset(mat.edf_mtag_to_gtag_map, 0, MAX_DF_HANDLES * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>));</div>
<div class="line">    <span class="keywordflow">return</span> mat;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> create_cuda_material_handles(</div>
<div class="line">    Df_cuda_material&amp; mat,</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a>* target_code,</div>
<div class="line">    LPE_state_machine&amp; lpe_state_machine)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// fill tag ID list.</span></div>
<div class="line">    <span class="comment">// allows to map from local per material Tag IDs to global per scene Tag IDs</span></div>
<div class="line">    <span class="comment">// Note, calling &#39;LPE_state_machine::handle_to_global_tag(...)&#39; registers the string handles</span></div>
<div class="line">    <span class="comment">// present in the MDL in our &#39;scene&#39;</span></div>
<div class="line">    mat.bsdf_mtag_to_gtag_map_size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(</div>
<div class="line">        target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gaf2faaf71b687166198dc396836430e29" title="Get the number of distribution function handles referenced by a callable function. ">get_callable_function_df_handle_count</a>(mat.bsdf.y));</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0; i &lt; mat.bsdf_mtag_to_gtag_map_size; ++i)</div>
<div class="line">        mat.bsdf_mtag_to_gtag_map[i] = lpe_state_machine.handle_to_global_tag(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1eb67b48636a7d55f272a0c7b5e01bea" title="Get the name of a distribution function handle referenced by a callable function. ...">get_callable_function_df_handle</a>(mat.bsdf.y, i));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// same for all other distribution functions</span></div>
<div class="line">    mat.edf_mtag_to_gtag_map_size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span><span class="keyword">&gt;</span>(</div>
<div class="line">        target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gaf2faaf71b687166198dc396836430e29" title="Get the number of distribution function handles referenced by a callable function. ">get_callable_function_df_handle_count</a>(mat.edf.y));</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0; i &lt; mat.edf_mtag_to_gtag_map_size; ++i)</div>
<div class="line">        mat.edf_mtag_to_gtag_map[i] = lpe_state_machine.handle_to_global_tag(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1eb67b48636a7d55f272a0c7b5e01bea" title="Get the name of a distribution function handle referenced by a callable function. ...">get_callable_function_df_handle</a>(mat.edf.y, i));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// checks if a compiled material contains none-invalid hair BSDF</span></div>
<div class="line"><span class="keywordtype">bool</span> contains_hair_bsdf(<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* compiled_material)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_direct_call&gt;</a> body(</div>
<div class="line">        compiled_material-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html#a3dd4bc11edb0ce29f2e70cfb4914ffe9" title="Returns the direct call expression that represents the body of the compiled material. ">get_body</a>());</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_list&gt;</a> body_args(body-&gt;get_arguments());</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0, n = body_args-&gt;get_size(); i &lt; n; ++i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* name = body_args-&gt;get_name(i);</div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">&quot;hair&quot;</span>) == 0)</div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression&gt;</a> hair_exp(</div>
<div class="line">                body_args-&gt;get_expression(i));</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (hair_exp-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IExpression.html#a7ebbfc1f9ceee07cd8721b3cb6e20032ab563823691ce8b3c99a9a58bde726cef" title="A constant expression. See mi::neuraylib::IExpression_constant. ">mi::neuraylib::IExpression::EK_CONSTANT</a>)</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_constant&gt;</a> hair_exp_const(</div>
<div class="line">                hair_exp-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IExpression__constant.html" title="A constant expression. ">mi::neuraylib::IExpression_constant</a>&gt;());</div>
<div class="line"></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IValue&gt;</a> hair_exp_const_value(</div>
<div class="line">                hair_exp_const-&gt;get_value());</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">return</span> hair_exp_const_value-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49aba28f3daeca795fd8b60317637fb2e6a" title="An invalid distribution function value. See mi::neuraylib::IValue_invalid_df. ">mi::neuraylib::IValue::VK_INVALID_DF</a>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> usage(<span class="keyword">const</span> <span class="keywordtype">char</span> *name)</div>
<div class="line">{</div>
<div class="line">    std::cout</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; [options] [&lt;material_name1|full_mdle_path1&gt; ...]\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-h|--help                   print this text and exit\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-v|--version                print the MDL SDK version string and exit\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--device &lt;id&gt;               run on CUDA device &lt;id&gt; (default: 0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--nogl                      don&#39;t open interactive display\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--nocc                      don&#39;t use class-compilation\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--noaux                     don&#39;t generate code for albedo and normal buffers\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--an                        use adapt normal function\n&quot;</span></div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>        &lt;&lt; <span class="stringliteral">&quot;--interpreter               use the DF interpreter (if possible)\n&quot;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>        &lt;&lt; <span class="stringliteral">&quot;--gui_scale &lt;factor&gt;        GUI scaling factor (default: 1.0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--res &lt;res_x&gt; &lt;res_y&gt;       resolution (default: 1024x1024)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--hdr &lt;filename&gt;            HDR environment map &quot;</span></div>
<div class="line">           <span class="stringliteral">&quot;(default: nvidia/sdk_examples/resources/environment.hdr)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--hdr_rot &lt;degrees&gt;         rotation of the environment in degrees (default: 0.0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-o &lt;outputfile&gt;             image file to write result to (default: output.exr).\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                            With multiple materials \&quot;-&lt;material index&gt;\&quot; will be\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                            added in front of the extension\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--spp &lt;num&gt;                 samples per pixel, only active for --nogl (default: 4096)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--spi &lt;num&gt;                 samples per render call (default: 8)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-t &lt;type&gt;                   0: eval, 1: sample, 2: mis, 3: mis + pdf, 4: no env\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                            (default: 2)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-e &lt;exposure&gt;               exposure for interactive display (default: 0.0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-f &lt;fov&gt;                    the camera field of view in degree (default: 96.0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-p &lt;x&gt; &lt;y&gt; &lt;z&gt;              set the camera position (default 0 0 3).\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                            The camera will always look towards (0, 0, 0).\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-l &lt;x&gt; &lt;y&gt; &lt;z&gt; &lt;r&gt; &lt;g&gt; &lt;b&gt;  add an isotropic point light with given coordinates and &quot;</span></div>
<div class="line">           <span class="stringliteral">&quot;intensity (flux)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--mdl_path &lt;path&gt;           MDL search path, can occur multiple times.\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--max_path_length &lt;num&gt;     maximum path length, default 4 (up to one total internal\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                            reflection), clamped to 2..100\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--noaa                      disable pixel oversampling\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;-d                          enable use of derivatives\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;--fold_ternary_on_df        fold all ternary operators on *df types (default: false)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Note: material names can end with an &#39;*&#39; as a wildcard\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;      and alternatively, full MDLE file paths can be passed as material name\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    exit(EXIT_FAILURE);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> MAIN_UTF8(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parse commandline options</span></div>
<div class="line">    Options options;</div>
<div class="line">    mi::examples::mdl::Configure_options configure_options;</div>
<div class="line">    <span class="keywordtype">bool</span> print_version_and_exit = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; argc; ++i) {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *opt = argv[i];</div>
<div class="line">        <span class="keywordflow">if</span> (opt[0] == <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--device&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.cuda_device = atoi(argv[++i]);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--nogl&quot;</span>) == 0) {</div>
<div class="line">                options.opengl = <span class="keyword">false</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--nocc&quot;</span>) == 0) {</div>
<div class="line">                options.use_class_compilation = <span class="keyword">false</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--noaux&quot;</span>) == 0) {</div>
<div class="line">                options.enable_auxiliary_output = <span class="keyword">false</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--an&quot;</span>) == 0) {</div>
<div class="line">                options.use_adapt_normal = <span class="keyword">false</span>;</div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--interpreter&quot;</span>) == 0) {</div>
<div class="line">                options.use_df_interpreter = <span class="keyword">true</span>;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--gui_scale&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.gui_scale = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--res&quot;</span>) == 0 &amp;&amp; i &lt; argc - 2) {</div>
<div class="line">                options.res_x = std::max(atoi(argv[++i]), 1);</div>
<div class="line">                options.res_y = std::max(atoi(argv[++i]), 1);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--hdr&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.hdrfile = argv[++i];</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--hdr_rot&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.hdr_rot = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                <span class="comment">// wrap in case of negative input</span></div>
<div class="line">                <span class="comment">// we don&#39;t want fmodf behavior for negative values</span></div>
<div class="line">                options.hdr_rot -= floorf(options.hdr_rot / 360.0f) * 360.f;</div>
<div class="line">                options.hdr_rot = fmodf(options.hdr_rot, 360.0f);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-o&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.outputfile = argv[++i];</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--spp&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.iterations = std::max(atoi(argv[++i]), 1);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--spi&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.samples_per_iteration = std::max(atoi(argv[++i]), 1);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-t&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">int</span> type = atoi(argv[++i]);</div>
<div class="line">                <span class="keywordflow">if</span> (type &lt; 0 || type &gt;= MDL_TEST_COUNT) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Invalid type for \&quot;-t\&quot; option!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    usage(argv[0]);</div>
<div class="line">                }</div>
<div class="line">                options.mdl_test_type = type;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-e&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.exposure = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-f&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.fov = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-p&quot;</span>) == 0 &amp;&amp; i &lt; argc - 3) {</div>
<div class="line">                options.cam_pos.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.cam_pos.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.cam_pos.z = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-l&quot;</span>) == 0 &amp;&amp; i &lt; argc - 6) {</div>
<div class="line">                options.light_pos.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.light_pos.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.light_pos.z = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.light_intensity.x = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.light_intensity.y = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">                options.light_intensity.z = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(atof(argv[++i]));</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--mdl_path&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                configure_options.additional_mdl_paths.push_back(argv[++i]);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--max_path_length&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.max_path_length = std::min(std::max(atoi(argv[++i]), 2), 100);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--noaa&quot;</span>) == 0) {</div>
<div class="line">                options.no_aa = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-d&quot;</span>) == 0) {</div>
<div class="line">                options.enable_derivatives = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--fold_ternary_on_df&quot;</span>) == 0) {</div>
<div class="line">                options.fold_ternary_on_df = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-v&quot;</span>) == 0 || strcmp(opt, <span class="stringliteral">&quot;--version&quot;</span>) == 0) {</div>
<div class="line">                print_version_and_exit = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-h&quot;</span>) != 0 &amp;&amp; strcmp(opt, <span class="stringliteral">&quot;--help&quot;</span>) != 0)</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown option: \&quot;&quot;</span> &lt;&lt; opt &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                usage(argv[0]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            options.material_names.push_back(std::string(opt));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use default material, if none was provided via command line</span></div>
<div class="line">    <span class="keywordflow">if</span> (options.material_names.empty())</div>
<div class="line">        options.material_names.push_back(<span class="stringliteral">&quot;::nvidia::sdk_examples::tutorials::example_df&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Access the MDL SDK</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::INeuray&gt;</a> neuray(mi::examples::mdl::load_and_get_ineuray());</div>
<div class="line">    <span class="keywordflow">if</span> (!neuray.is_valid_interface())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to load the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle the --version flag</span></div>
<div class="line">    <span class="keywordflow">if</span> (print_version_and_exit) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// print library version information.</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IVersion&gt;</a> version(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IVersion.html" title="Abstract interface for accessing version information. ">mi::neuraylib::IVersion</a>&gt;());</div>
<div class="line">        fprintf(stdout, <span class="stringliteral">&quot;%s\n&quot;</span>, version-&gt;get_string());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// free the handles and unload the MDL SDK</span></div>
<div class="line">        version = <span class="keyword">nullptr</span>;</div>
<div class="line">        neuray = <span class="keyword">nullptr</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (!mi::examples::mdl::unload())</div>
<div class="line">            exit_failure(<span class="stringliteral">&quot;Failed to unload the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">        exit_success();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Configure the MDL SDK</span></div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::configure(neuray.get(), configure_options))</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Start the MDL SDK</span></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> ret = neuray-&gt;start();</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK. Result code: %d&quot;</span>, ret);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// LPE state machine for rendering into multiple buffers</span></div>
<div class="line">    LPE_state_machine lpe_state_machine;</div>
<div class="line">    lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;point_light&quot;</span>);  <span class="comment">// register handles before building</span></div>
<div class="line">    lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;env&quot;</span>);          <span class="comment">// the state machine</span></div>
<div class="line"></div>
<div class="line">     <span class="comment">// register other handles in the scene, e.g.: for object instances</span></div>
<div class="line">    lpe_state_machine.handle_to_global_tag(<span class="stringliteral">&quot;sphere&quot;</span>);       <span class="comment">// for illustration, not used currently</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add some common and custom LPEs</span></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty&quot;</span>, LPE::create_common(LPE::Common::Beauty));</div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Diffuse&quot;</span>, LPE::create_common(LPE::Common::Diffuse));</div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Glossy&quot;</span>, LPE::create_common(LPE::Common::Glossy));</div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Specular&quot;</span>, LPE::create_common(LPE::Common::Specular));</div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;SSS&quot;</span>, LPE::create_common(LPE::Common::SSS));</div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Transmission&quot;</span>, LPE::create_common(LPE::Common::Transmission));</div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-Env&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter()),</div>
<div class="line">        LPE::light(<span class="stringliteral">&quot;env&quot;</span>) }));  <span class="comment">// only light with the name &#39;env&#39;</span></div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-PointLight&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter()),</div>
<div class="line">        LPE::light(<span class="stringliteral">&quot;point_light&quot;</span>) })); <span class="comment">// only light with the name &#39;point_light&#39;</span></div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-Emission&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter()),</div>
<div class="line">        LPE::emission() })); <span class="comment">// only emission</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-Base&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter(<span class="stringliteral">&quot;base&quot;</span>)),</div>
<div class="line">        LPE::light()})); <span class="comment">// no emission</span></div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-Coat&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter(<span class="stringliteral">&quot;coat&quot;</span>)),</div>
<div class="line">        LPE::light()})); <span class="comment">// no emission</span></div>
<div class="line"></div>
<div class="line">    lpe_state_machine.add_expression(<span class="stringliteral">&quot;Beauty-^Coat&quot;</span>, LPE::sequence({</div>
<div class="line">        LPE::camera(),</div>
<div class="line">        LPE::zero_or_more(LPE::any_scatter(<span class="stringliteral">&quot;coat&quot;</span>, <span class="keyword">false</span>)),</div>
<div class="line">        LPE::any_light()})); <span class="comment">// emission or light source</span></div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create a transaction</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IDatabase&gt;</a> database(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IDatabase.html" title="This interface is used to interact with the distributed database. ">mi::neuraylib::IDatabase</a>&gt;());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IScope&gt;</a> scope(database-&gt;get_global_scope());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a> transaction(scope-&gt;create_transaction());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Access needed API components</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a> mdl_factory(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>&gt;());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> mdl_impexp_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend_api&gt;</a> mdl_backend_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>&gt;());</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Initialize the material compiler with 16 result buffer slots (&quot;texture results&quot;)</span></div>
<div class="line">            Material_compiler mc(</div>
<div class="line">                mdl_impexp_api.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(),</div>
<div class="line">                mdl_backend_api.get(),</div>
<div class="line">                mdl_factory.get(),</div>
<div class="line">                transaction.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(),</div>
<div class="line">                16,</div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>                options.use_df_interpreter,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>                options.enable_derivatives,</div>
<div class="line">                options.fold_ternary_on_df,</div>
<div class="line">                options.enable_auxiliary_output,</div>
<div class="line">                options.use_adapt_normal,</div>
<div class="line">                <span class="comment">/*df_handle_mode=*/</span> <span class="stringliteral">&quot;pointer&quot;</span>);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// List of materials in the scene</span></div>
<div class="line">            std::vector&lt;Df_cuda_material&gt; material_bundle;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Select the functions to translate</span></div>
<div class="line">            std::vector&lt;mi::neuraylib::Target_function_description&gt; descs;</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;init&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;surface.scattering&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;surface.emission.emission&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;surface.emission.intensity&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;volume.absorption_coefficient&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;thin_walled&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;geometry.cutout_opacity&quot;</span>));</div>
<div class="line">            descs.push_back(</div>
<div class="line">                <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>(<span class="stringliteral">&quot;hair&quot;</span>));</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Generate code for all materials</span></div>
<div class="line">            std::vector&lt;std::string&gt; used_material_names;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; options.material_names.size(); ++i) {</div>
<div class="line">                std::string&amp; opt_material_name = options.material_names[i];</div>
<div class="line"></div>
<div class="line">                <span class="comment">// split module and material name</span></div>
<div class="line">                std::string module_qualified_name, material_simple_name;</div>
<div class="line">                <span class="keywordflow">if</span> (!mi::examples::mdl::parse_cmd_argument_material_name(</div>
<div class="line">                    opt_material_name, module_qualified_name, material_simple_name, <span class="keyword">true</span>))</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Provided material name &#39;%s&#39; is invalid.&quot;</span>,</div>
<div class="line">                            opt_material_name.c_str());</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Is this a material name pattern? (not applicable to mdle)</span></div>
<div class="line">                <span class="keywordflow">if</span> (!mi::examples::strings::ends_with(module_qualified_name, <span class="stringliteral">&quot;.mdle&quot;</span>) &amp;&amp;</div>
<div class="line">                    opt_material_name.size() &gt; 1 &amp;&amp;</div>
<div class="line">                    opt_material_name.back() == <span class="charliteral">&#39;*&#39;</span>) {</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// prepare the pattern for matching</span></div>
<div class="line">                    std::string pattern = opt_material_name.substr(0, opt_material_name.size() - 1);</div>
<div class="line">                    <span class="keywordflow">if</span> (!starts_with(pattern, <span class="stringliteral">&quot;::&quot;</span>))</div>
<div class="line">                        pattern = <span class="stringliteral">&quot;::&quot;</span> + pattern;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// load the module</span></div>
<div class="line">                    std::string module_db_name = mc.load_module(module_qualified_name);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// iterate over all materials in that module</span></div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IModule&gt;</a> loaded_module(</div>
<div class="line">                        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>&gt;(module_db_name.c_str()));</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> j = 0, n = loaded_module-&gt;get_material_count(); j &lt; n; ++j) {</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// get the j`th material</span></div>
<div class="line">                        <span class="keyword">const</span> <span class="keywordtype">char</span>* material_db_name = loaded_module-&gt;get_material(j);</div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> mat_def(</div>
<div class="line">                            transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(</div>
<div class="line">                                material_db_name));</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// make sure the material name starts with the pattern</span></div>
<div class="line">                        std::string material_qualified_name = mat_def-&gt;get_mdl_name();</div>
<div class="line">                        <span class="keywordflow">if</span> (!mi::examples::strings::starts_with(material_qualified_name, pattern))</div>
<div class="line">                            <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;Adding material \&quot;&quot;</span> &lt;&lt; material_qualified_name &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Add functions of the material to the link unit</span></div>
<div class="line">                        check_success(mc.add_material(</div>
<div class="line">                            module_qualified_name, material_db_name,</div>
<div class="line">                            descs.data(), descs.size(),</div>
<div class="line">                            options.use_class_compilation));</div>
<div class="line"></div>
<div class="line">                        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">                            mc.get_compiled_materials().back());</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// Create application material representation</span></div>
<div class="line">                        material_bundle.push_back(create_cuda_material(</div>
<div class="line">                            0, material_bundle.size(), descs,</div>
<div class="line">                            contains_hair_bsdf(compiled_material.get())));</div>
<div class="line">                        used_material_names.push_back(material_qualified_name);</div>
<div class="line">                    }</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// Load the module</span></div>
<div class="line">                    std::string module_db_name = mc.load_module(module_qualified_name);</div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IModule&gt;</a> module(</div>
<div class="line">                        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>&gt;(module_db_name.c_str()));</div>
<div class="line">                    <span class="keywordflow">if</span> (!module)</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Failed to access the loaded module.&quot;</span>);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Construct the material name</span></div>
<div class="line">                    std::string material_db_name</div>
<div class="line">                        = module_db_name + <span class="stringliteral">&quot;::&quot;</span> + material_simple_name;</div>
<div class="line">                    material_db_name = mi::examples::mdl::add_missing_material_signature(</div>
<div class="line">                        module.get(), material_db_name);</div>
<div class="line">                    <span class="keywordflow">if</span> (material_db_name.empty())</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Failed to find the material %s in the module %s.&quot;</span>,</div>
<div class="line">                            material_simple_name.c_str(), module_qualified_name.c_str());</div>
<div class="line"></div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Adding material \&quot;&quot;</span> &lt;&lt; material_db_name &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Add functions of the material to the link unit</span></div>
<div class="line">                    check_success(mc.add_material(</div>
<div class="line">                        module_qualified_name, material_db_name,</div>
<div class="line">                        descs.data(), descs.size(),</div>
<div class="line">                        options.use_class_compilation));</div>
<div class="line"></div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">                        mc.get_compiled_materials().back());</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Create application material representation</span></div>
<div class="line">                    material_bundle.push_back(create_cuda_material(</div>
<div class="line">                        0, material_bundle.size(), descs,</div>
<div class="line">                        contains_hair_bsdf(compiled_material.get())));</div>
<div class="line">                    used_material_names.push_back(material_db_name);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Update the material names with the actually used names</span></div>
<div class="line">            options.material_names = used_material_names;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Generate the CUDA PTX code for the link unit</span></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code(</div>
<div class="line">                mc.generate_cuda_ptx());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// convert handles to tag IDs</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; mat : material_bundle)</div>
<div class="line">                create_cuda_material_handles(mat, target_code.get(), lpe_state_machine);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Acquire image API needed to prepare the textures</span></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a> image_api(</div>
<div class="line">                neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// when all scene elements that have handles are loaded and all handles as well as</span></div>
<div class="line">            <span class="comment">// light path expressions are registered, the state machine can be constructed.</span></div>
<div class="line">            lpe_state_machine.build();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Render</span></div>
<div class="line">            render_scene(</div>
<div class="line">                options,</div>
<div class="line">                transaction,</div>
<div class="line">                image_api,</div>
<div class="line">                mdl_impexp_api,</div>
<div class="line">                target_code,</div>
<div class="line">                mc.get_material_defs(),</div>
<div class="line">                mc.get_compiled_materials(),</div>
<div class="line">                mc.get_argument_block_indices(),</div>
<div class="line">                material_bundle,</div>
<div class="line">                lpe_state_machine);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#aa4ff8152107db238986b364273bceb0c" title="Commits the transaction. ">commit</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shut down the MDL SDK</span></div>
<div class="line">    <span class="keywordflow">if</span> (neuray-&gt;shutdown() != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to shutdown the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Unload the MDL SDK</span></div>
<div class="line">    neuray = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::unload())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to unload the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    exit_success();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Convert command line arguments to UTF8 on Windows</span></div>
<div class="line">COMMANDLINE_TO_UTF8</div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/df_cuda/example_df_cuda.h</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_DF_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define EXAMPLE_DF_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector_types.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;texture_types.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Target_code_data;</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> Mdl_test_type {</div>
<div class="line">    MDL_TEST_EVAL    = 0,  <span class="comment">// only use BSDF evaluation</span></div>
<div class="line">    MDL_TEST_SAMPLE  = 1,  <span class="comment">// only use BSDF sampling</span></div>
<div class="line">    MDL_TEST_MIS     = 2,  <span class="comment">// multiple importance sampling</span></div>
<div class="line">    MDL_TEST_MIS_PDF = 3,  <span class="comment">// multiple importance sampling, but use BSDF explicit pdf computation</span></div>
<div class="line">    MDL_TEST_NO_ENV  = 4,  <span class="comment">// no environment sampling</span></div>
<div class="line">    MDL_TEST_COUNT</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> MAX_DF_HANDLES = 8;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Env_accel {</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> alias;</div>
<div class="line">    <span class="keywordtype">float</span> q;</div>
<div class="line">    <span class="keywordtype">float</span> pdf;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">    #if defined(__CUDA_ARCH__)</span></div>
<div class="line"><span class="preprocessor"></span>    __host__ __device__</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">inline</span> uint2 make_invalid()</div>
<div class="line">    {</div>
<div class="line">        uint2 index_pair;</div>
<div class="line">        index_pair.x = ~0;</div>
<div class="line">        index_pair.y = ~0;</div>
<div class="line">        <span class="keywordflow">return</span> index_pair;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Df_cuda_material</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">    #if defined(__CUDA_ARCH__)</span></div>
<div class="line"><span class="preprocessor"></span>    __host__ __device__</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>    Df_cuda_material()</div>
<div class="line">        : compiled_material_index(0)</div>
<div class="line">        , argument_block_index(~0)</div>
<div class="line">        , init(make_invalid())</div>
<div class="line">        , bsdf(make_invalid())</div>
<div class="line">        , edf(make_invalid())</div>
<div class="line">        , emission_intensity(make_invalid())</div>
<div class="line">        , volume_absorption(make_invalid())</div>
<div class="line">        , thin_walled(make_invalid())</div>
<div class="line">        , cutout_opacity(make_invalid())</div>
<div class="line">        , contains_hair_bsdf(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// used on host side only</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> compiled_material_index;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// the argument block index of this material (~0 if not used)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> argument_block_index;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index to identify the init function</span></div>
<div class="line">    uint2 init;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index to identify the bsdf</span></div>
<div class="line">    uint2 bsdf;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index to identify the edf</span></div>
<div class="line">    uint2 edf;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index for intensity</span></div>
<div class="line">    uint2 emission_intensity;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index for volume absorption</span></div>
<div class="line">    uint2 volume_absorption;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index for thin_walled</span></div>
<div class="line">    uint2 thin_walled;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pair of target_code_index and function_index for cutout_opacity</span></div>
<div class="line">    uint2 cutout_opacity;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// maps &#39;material tags&#39; to &#39;global tags&#39; for the surface scattering distribution function</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bsdf_mtag_to_gtag_map[MAX_DF_HANDLES];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bsdf_mtag_to_gtag_map_size;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// maps &#39;material tags&#39; to &#39;global tags&#39; for the emission distribution function</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edf_mtag_to_gtag_map[MAX_DF_HANDLES];</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> edf_mtag_to_gtag_map_size;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> contains_hair_bsdf;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> Geometry_type</div>
<div class="line">{</div>
<div class="line">    GT_SPHERE = 0,  <span class="comment">// Intersect a sphere with unit radius located at the (0,0,0)</span></div>
<div class="line">    GT_HAIR = 1,    <span class="comment">// Intersect an infinite cylinder at (0,0,0) oriented in y-direction</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Kernel_params {</div>
<div class="line">    <span class="comment">// display</span></div>
<div class="line">    uint2         resolution;</div>
<div class="line">    <span class="keywordtype">float</span>         exposure_scale;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *display_buffer;</div>
<div class="line">    float3       *accum_buffer;</div>
<div class="line">    float3       *albedo_buffer;</div>
<div class="line">    float3       *normal_buffer;</div>
<div class="line">    <span class="keywordtype">bool</span>          enable_auxiliary_output;</div>
<div class="line">    <span class="keywordtype">unsigned</span>      display_buffer_index;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// parameters</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration_start;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iteration_num;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mdl_test_type;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_path_length;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> use_derivatives;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> disable_aa;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// camera</span></div>
<div class="line">    float3 cam_pos;</div>
<div class="line">    float3 cam_dir;</div>
<div class="line">    float3 cam_right;</div>
<div class="line">    float3 cam_up;</div>
<div class="line">    <span class="keywordtype">float</span>  cam_focal;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// geometry</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> geometry;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// environment</span></div>
<div class="line">    uint2                env_size;</div>
<div class="line">    cudaTextureObject_t  env_tex;</div>
<div class="line">    Env_accel           *env_accel;</div>
<div class="line">    <span class="keywordtype">float</span>                env_intensity;         <span class="comment">// scaling factor</span></div>
<div class="line">    uint32_t             env_gtag;              <span class="comment">// global light group tag for handle &#39;env&#39;</span></div>
<div class="line">    <span class="keywordtype">float</span>                env_rotation;          <span class="comment">// rotation of the environment</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// point light</span></div>
<div class="line">    float3 light_pos;</div>
<div class="line">    float3 light_color;</div>
<div class="line">    <span class="keywordtype">float</span> light_intensity;</div>
<div class="line">    uint32_t point_light_gtag;                  <span class="comment">// global light group tag for handle &#39;point_light&#39;</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// material data</span></div>
<div class="line">    Target_code_data   *tc_data;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>        **arg_block_list;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>        current_material;</div>
<div class="line">    Df_cuda_material   *material_buffer;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// LPE state machine</span></div>
<div class="line">    uint32_t            lpe_num_states;         <span class="comment">// number of states in the state machine</span></div>
<div class="line">    uint32_t            lpe_num_transitions;    <span class="comment">// number of possible transitions between 2 states</span></div>
<div class="line">    uint32_t           *lpe_state_table;        <span class="comment">// actual machine; size: #states x #transitions</span></div>
<div class="line">    uint32_t           *lpe_final_mask;         <span class="comment">// encodes final states; size: #states</span></div>
<div class="line">    uint32_t            default_gtag;           <span class="comment">// tag ID for the empty string</span></div>
<div class="line">    uint32_t            lpe_ouput_expression;   <span class="comment">// the LPE evaluated for output</span></div>
<div class="line">                                                <span class="comment">// only one here, but additional one analogously</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">enum</span> Display_buffer_options</div>
<div class="line">{</div>
<div class="line">    DISPLAY_BUFFER_LPE = 0,</div>
<div class="line">    DISPLAY_BUFFER_ALBEDO,</div>
<div class="line">    DISPLAY_BUFFER_NORMAL,</div>
<div class="line"></div>
<div class="line">    DISPLAY_BUFFER_COUNT</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // EXAMPLE_DF_CUDA_H</span></div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/shared/texture_support_cuda.h</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/shared/texture_support_cuda.h</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This file contains the implementations and the vtables of the texture access functions.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEXTURE_SUPPORT_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define TEXTURE_SUPPORT_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;cuda.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="target__code__types_8h.html" title="Types required for execution of generated native and CUDA code. ">mi/neuraylib/target_code_types.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define USE_SMOOTHERSTEP_FILTER</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#ifndef M_PI</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define M_PI            3.14159265358979323846</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define M_ONE_OVER_PI       0.318309886183790671538</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga69137bb7a93d941a5a8578ca4c772fbf" title="A float with derivatives. ">mi::neuraylib::tct_deriv_float</a>                     <a class="code" href="group__mi__neuray__mdl__compiler.html#ga69137bb7a93d941a5a8578ca4c772fbf" title="A float with derivatives. ">tct_deriv_float</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga067809015fbce254f57a2d1de28a7a14" title="A float2 with derivatives. ">mi::neuraylib::tct_deriv_float2</a>                    <a class="code" href="group__mi__neuray__mdl__compiler.html#ga067809015fbce254f57a2d1de28a7a14" title="A float2 with derivatives. ">tct_deriv_float2</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_2</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#ga955d747a7ae62b5e18e9f4359743136d" title="A float[2] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_2</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_3</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#gac1f3572aefe12967db565ec2b2dc0a07" title="A float[3] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_3</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_4</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#ga4213c9623560d5dc3839c8c6ebb097ac" title="A float[4] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_4</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Shading__state__material__impl.html" title="The MDL material state structure inside the MDL SDK is a representation of the renderer state as defi...">mi::neuraylib::Shading_state_material_with_derivs</a>  <a class="code" href="group__mi__neuray__mdl__compiler.html#ga8ffb20982d3063f617cb7fbeccdf7f36" title="The MDL material state structure with derivatives for the texture coordinates. ">Shading_state_material_with_derivs</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Shading__state__material__impl.html" title="The MDL material state structure inside the MDL SDK is a representation of the renderer state as defi...">mi::neuraylib::Shading_state_material</a>              <a class="code" href="group__mi__neuray__mdl__compiler.html#ga8a42cb80b6772ce4b266f2311b0561c1" title="The MDL material state structure. ">Shading_state_material</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__base.html" title="The texture handler structure that is passed to the texturing functions. ">mi::neuraylib::Texture_handler_base</a>                Texture_handler_base;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga852d194e585ada01cc272e85e367ca9b" title="The texture wrap modes as defined by tex::wrap_mode in the MDL specification. ">mi::neuraylib::Tex_wrap_mode</a>                       <a class="code" href="group__mi__neuray__mdl__compiler.html#ga852d194e585ada01cc272e85e367ca9b" title="The texture wrap modes as defined by tex::wrap_mode in the MDL specification. ">Tex_wrap_mode</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a>                          <a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">Mbsdf_part</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom structure representing an MDL texture, containing filtered and unfiltered CUDA texture</span></div>
<div class="line"><span class="comment">// objects and the size of the texture.</span></div>
<div class="line"><span class="keyword">struct </span>Texture</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Texture()</div>
<div class="line">        : filtered_object(0)</div>
<div class="line">        , unfiltered_object(0)</div>
<div class="line">        , size(make_uint3(0, 0, 0))</div>
<div class="line">        , inv_size(make_float3(0.0f, 0.0f, 0.0f))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">explicit</span> Texture(</div>
<div class="line">        cudaTextureObject_t  filtered_object,</div>
<div class="line">        cudaTextureObject_t  unfiltered_object,</div>
<div class="line">        uint3                size)</div>
<div class="line">        : filtered_object(filtered_object)</div>
<div class="line">        , unfiltered_object(unfiltered_object)</div>
<div class="line">        , size(size)</div>
<div class="line">        , inv_size(make_float3(1.0f / size.x, 1.0f / size.y, 1.0f / size.z))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t  filtered_object;    <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    cudaTextureObject_t  unfiltered_object;  <span class="comment">// uses filter mode cudaFilterModePoint</span></div>
<div class="line">    uint3                size;               <span class="comment">// size of the texture, needed for texel access</span></div>
<div class="line">    float3               inv_size;           <span class="comment">// the inverse values of the size of the texture</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom structure representing an MDL BSDF measurement.</span></div>
<div class="line"><span class="keyword">struct </span>Mbsdf</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span>            has_data[2];            <span class="comment">// true if there is a measurement for this part</span></div>
<div class="line">    cudaTextureObject_t eval_data[2];           <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    <span class="keywordtype">float</span>               max_albedo[2];          <span class="comment">// max albedo used to limit the multiplier</span></div>
<div class="line">    <span class="keywordtype">float</span>*              sample_data[2];         <span class="comment">// CDFs for sampling a BSDF measurement</span></div>
<div class="line">    <span class="keywordtype">float</span>*              albedo_data[2];         <span class="comment">// max albedo for each theta (isotropic)</span></div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution[2];      <span class="comment">// size of the dataset, needed for texel access</span></div>
<div class="line">    float2          inv_angular_resolution[2];  <span class="comment">// the inverse values of the size of the dataset</span></div>
<div class="line">    <span class="keywordtype">unsigned</span>        num_channels[2];            <span class="comment">// number of color channels (1 or 3)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing a Light Profile</span></div>
<div class="line"><span class="keyword">struct </span>Lightprofile</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Lightprofile()</div>
<div class="line">        : angular_resolution(make_uint2(0, 0))</div>
<div class="line">        , inv_angular_resolution(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_start(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_inv_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">        , candela_multiplier(0.0f)</div>
<div class="line">        , total_power(0.0f)</div>
<div class="line">        , eval_data(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution;     <span class="comment">// angular resolution of the grid</span></div>
<div class="line">    float2          inv_angular_resolution; <span class="comment">// inverse angular resolution of the grid</span></div>
<div class="line">    float2          theta_phi_start;        <span class="comment">// start of the grid</span></div>
<div class="line">    float2          theta_phi_delta;        <span class="comment">// angular step size</span></div>
<div class="line">    float2          theta_phi_inv_delta;    <span class="comment">// inverse step size</span></div>
<div class="line">    <span class="keywordtype">float</span>           candela_multiplier;     <span class="comment">// factor to rescale the normalized data</span></div>
<div class="line">    <span class="keywordtype">float</span>           total_power;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t eval_data;          <span class="comment">// normalized data sampled on grid</span></div>
<div class="line">    <span class="keywordtype">float</span>*              cdf_data;           <span class="comment">// CDFs for sampling a light profile</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The texture handler structure required by the MDL SDK with custom additional fields.</span></div>
<div class="line"><span class="keyword">struct </span>Texture_handler : Texture_handler_base {</div>
<div class="line">    <span class="comment">// additional data for the texture access functions can be provided here</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_textures;        <span class="comment">// the number of textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Texture <span class="keyword">const</span> *textures;            <span class="comment">// the textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_mbsdfs;          <span class="comment">// the number of mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid mbsdf)</span></div>
<div class="line">    Mbsdf <span class="keyword">const</span>    *mbsdfs;             <span class="comment">// the mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid mbsdf)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>          num_lightprofiles;  <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">    Lightprofile <span class="keyword">const</span> *lightprofiles;  <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The texture handler structure required by the MDL SDK with custom additional fields.</span></div>
<div class="line"><span class="keyword">struct </span>Texture_handler_deriv : <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__deriv__base.html" title="The texture handler structure that is passed to the texturing functions with derivative support...">mi::neuraylib::Texture_handler_deriv_base</a> {</div>
<div class="line">    <span class="comment">// additional data for the texture access functions can be provided here</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_textures;        <span class="comment">// the number of textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Texture <span class="keyword">const</span> *textures;            <span class="comment">// the textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_mbsdfs;          <span class="comment">// the number of mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Mbsdf <span class="keyword">const</span>    *mbsdfs;             <span class="comment">// the mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>          num_lightprofiles;  <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">    Lightprofile <span class="keyword">const</span> *lightprofiles;  <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if defined(__CUDACC__)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Stores a float4 in a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(<span class="keywordtype">float</span> res[4], <span class="keyword">const</span> float4 &amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">    res[3] = v.w;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float in all elements of a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(<span class="keywordtype">float</span> res[4], <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    res[0] = res[1] = res[2] = res[3] = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the given float values in a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(</div>
<div class="line">    <span class="keywordtype">float</span> res[4], <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2, <span class="keywordtype">float</span> v3)</div>
<div class="line">{</div>
<div class="line">    res[0] = v0;</div>
<div class="line">    res[1] = v1;</div>
<div class="line">    res[2] = v2;</div>
<div class="line">    res[3] = v3;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float3 in a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], float3 <span class="keyword">const</span>&amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float4 in a float[3] array, ignoring v.w.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keyword">const</span> float4 &amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float in all elements of a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    res[0] = res[1] = res[2] = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the given float values in a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2)</div>
<div class="line">{</div>
<div class="line">    res[0] = v0;</div>
<div class="line">    res[1] = v1;</div>
<div class="line">    res[2] = v2;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the luminance if a given float[3] in a float.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, float3 <span class="keyword">const</span>&amp; v)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// store luminance</span></div>
<div class="line">    *res = 0.212671 * v.x + 0.715160 * v.y + 0.072169 * v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the luminance if a given float[3] in a float.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// store luminance</span></div>
<div class="line">    *res = 0.212671 * v0 + 0.715160 * v1 + 0.072169 * v2;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a given float in a float</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    *res = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Textures</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Applies wrapping and cropping to the given coordinate.</span></div>
<div class="line"><span class="comment">// Note: This macro returns if wrap mode is clip and the coordinate is out of range.</span></div>
<div class="line"><span class="preprocessor">#define WRAP_AND_CROP_OR_RETURN_BLACK(val, inv_dim, wrap_mode, crop_vals, store_res_func)    \</span></div>
<div class="line"><span class="preprocessor">  do {                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_REPEAT &amp;&amp;                                    \</span></div>
<div class="line"><span class="preprocessor">        (crop_vals)[0] == 0.0f &amp;&amp; (crop_vals)[1] == 1.0f ) {                                 \</span></div>
<div class="line"><span class="preprocessor">      </span><span class="comment">/* Do nothing, use texture sampler default behavior */</span><span class="preprocessor">                                 \</span></div>
<div class="line"><span class="preprocessor">    }                                                                                        \</span></div>
<div class="line"><span class="preprocessor">    else                                                                                     \</span></div>
<div class="line"><span class="preprocessor">    {                                                                                        \</span></div>
<div class="line"><span class="preprocessor">      if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_REPEAT )                                   \</span></div>
<div class="line"><span class="preprocessor">        val = val - floorf(val);                                                             \</span></div>
<div class="line"><span class="preprocessor">      else {                                                                                 \</span></div>
<div class="line"><span class="preprocessor">        if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_CLIP &amp;&amp; (val &lt; 0.0f || val &gt;= 1.0f) ) {  \</span></div>
<div class="line"><span class="preprocessor">          store_res_func(result, 0.0f);                                                      \</span></div>
<div class="line"><span class="preprocessor">          return;                                                                            \</span></div>
<div class="line"><span class="preprocessor">        }                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        else if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_MIRRORED_REPEAT ) {                 \</span></div>
<div class="line"><span class="preprocessor">          float floored_val = floorf(val);                                                   \</span></div>
<div class="line"><span class="preprocessor">          if ( (int(floored_val) &amp; 1) != 0 )                                                 \</span></div>
<div class="line"><span class="preprocessor">            val = 1.0f - (val - floored_val);                                                \</span></div>
<div class="line"><span class="preprocessor">          else                                                                               \</span></div>
<div class="line"><span class="preprocessor">            val = val - floored_val;                                                         \</span></div>
<div class="line"><span class="preprocessor">        }                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        float inv_hdim = 0.5f * (inv_dim);                                                   \</span></div>
<div class="line"><span class="preprocessor">        val = fminf(fmaxf(val, inv_hdim), 1.f - inv_hdim);                                   \</span></div>
<div class="line"><span class="preprocessor">      }                                                                                      \</span></div>
<div class="line"><span class="preprocessor">      val = val * ((crop_vals)[1] - (crop_vals)[0]) + (crop_vals)[0];                        \</span></div>
<div class="line"><span class="preprocessor">    }                                                                                        \</span></div>
<div class="line"><span class="preprocessor">  } while ( 0 )</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SMOOTHERSTEP_FILTER</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// Modify texture coordinates to get better texture filtering,</span></div>
<div class="line"><span class="comment">// see http://www.iquilezles.org/www/articles/texture/texture.htm</span></div>
<div class="line"><span class="preprocessor">#define APPLY_SMOOTHERSTEP_FILTER()                                                         \</span></div>
<div class="line"><span class="preprocessor">    do {                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        u = u * tex.size.x + 0.5f;                                                          \</span></div>
<div class="line"><span class="preprocessor">        v = v * tex.size.y + 0.5f;                                                          \</span></div>
<div class="line"><span class="preprocessor">                                                                                            \</span></div>
<div class="line"><span class="preprocessor">        float u_i = floorf(u), v_i = floorf(v);                                             \</span></div>
<div class="line"><span class="preprocessor">        float u_f = u - u_i;                                                                \</span></div>
<div class="line"><span class="preprocessor">        float v_f = v - v_i;                                                                \</span></div>
<div class="line"><span class="preprocessor">        u_f = u_f * u_f * u_f * (u_f * (u_f * 6.f - 15.f) + 10.f);                          \</span></div>
<div class="line"><span class="preprocessor">        v_f = v_f * v_f * v_f * (v_f * (v_f * 6.f - 15.f) + 10.f);                          \</span></div>
<div class="line"><span class="preprocessor">        u = u_i + u_f;                                                                      \</span></div>
<div class="line"><span class="preprocessor">        v = v_i + v_f;                                                                      \</span></div>
<div class="line"><span class="preprocessor">                                                                                            \</span></div>
<div class="line"><span class="preprocessor">        u = (u - 0.5f) * tex.inv_size.x;                                                    \</span></div>
<div class="line"><span class="preprocessor">        v = (v - 0.5f) * tex.inv_size.y;                                                    \</span></div>
<div class="line"><span class="preprocessor">    } while ( 0 )</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define APPLY_SMOOTHERSTEP_FILTER()</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[2],</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2D&lt;float4&gt;(tex.filtered_object, u, v));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_deriv_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    tct_deriv_float2 <span class="keyword">const</span>     *coord,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord-&gt;val.x, v = coord-&gt;val.y;</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2DGrad&lt;float4&gt;(tex.filtered_object, u, v, coord-&gt;dx, coord-&gt;dy));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[2],</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex2D&lt;float4&gt;(tex.filtered_object, u, v));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_deriv_float3_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    tct_deriv_float2 <span class="keyword">const</span>     *coord,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord-&gt;val.x, v = coord-&gt;val.y;</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex2DGrad&lt;float4&gt;(tex.filtered_object, u, v, coord-&gt;dx, coord-&gt;dy));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::texel_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="comment">// Note: uvtile and/or animated textures are not supported</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_texel_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   coord[2],</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   <span class="comment">/*uv_tile*/</span>[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2D&lt;float4&gt;(</div>
<div class="line">        tex.unfiltered_object,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[0]) * tex.inv_size.x,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[1]) * tex.inv_size.y));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3],</div>
<div class="line">    Tex_wrap_mode               wrap_u,</div>
<div class="line">    Tex_wrap_mode               wrap_v,</div>
<div class="line">    Tex_wrap_mode               wrap_w,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_w[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1], w = coord[2];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(w, tex.inv_size.z, wrap_w, crop_w, store_result4);</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex3D&lt;float4&gt;(tex.filtered_object, u, v, w));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3],</div>
<div class="line">    Tex_wrap_mode               wrap_u,</div>
<div class="line">    Tex_wrap_mode               wrap_v,</div>
<div class="line">    Tex_wrap_mode               wrap_w,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_w[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1], w = coord[2];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(w, tex.inv_size.z, wrap_w, crop_w, store_result3);</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex3D&lt;float4&gt;(tex.filtered_object, u, v, w));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::texel_float4() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_texel_float4_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>                   coord[3],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex3D&lt;float4&gt;(</div>
<div class="line">        tex.unfiltered_object,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[0]) * tex.inv_size.x,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[1]) * tex.inv_size.y,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[2]) * tex.inv_size.z));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_cube texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_cube(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, texCubemap&lt;float4&gt;(tex.filtered_object, coord[0], coord[1], coord[2]));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_cube texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_cube(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result3(result, texCubemap&lt;float4&gt;(tex.filtered_object, coord[0], coord[1], coord[2]));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of resolution_2d function needed by generated code.</span></div>
<div class="line"><span class="comment">// Note: uvtile and/or animated textures are not supported</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_resolution_2d(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   <span class="comment">/*uv_tile*/</span>[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    result[0] = tex.size.x;</div>
<div class="line">    result[1] = tex.size.y;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of resolution_3d function needed by generated code.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_resolution_3d(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span>* <span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler const*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span>&amp; tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    result[0] = tex.size.x;</div>
<div class="line">    result[1] = tex.size.y;</div>
<div class="line">    result[2] = tex.size.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of texture_isvalid().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> tex_texture_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> texture_idx != 0 &amp;&amp; texture_idx - 1 &lt; <span class="keyword">self</span>-&gt;num_textures;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of frame function needed by generated code.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_frame(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span>* <span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler const*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Texture const&amp; tex = self-&gt;textures[texture_idx - 1];</span></div>
<div class="line">    result[0] = 0;</div>
<div class="line">    result[1] = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Light Profiles</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_power() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_power(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    <span class="keywordflow">return</span> lp.total_power;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_maximum() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_maximum(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    <span class="keywordflow">return</span> lp.candela_multiplier;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_isvalid() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> df_light_profile_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">return</span> light_profile_idx != 0 &amp;&amp; light_profile_idx - 1 &lt; <span class="keyword">self</span>-&gt;num_lightprofiles;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// binary search through CDF</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> sample_cdf(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf,</div>
<div class="line">    <span class="keywordtype">unsigned</span> cdf_size,</div>
<div class="line">    <span class="keywordtype">float</span> xi)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> li = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> ri = cdf_size - 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> m = (li + ri) / 2;</div>
<div class="line">    <span class="keywordflow">while</span> (ri &gt; li)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (xi &lt; cdf[m])</div>
<div class="line">            ri = m;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            li = m + 1;</div>
<div class="line"></div>
<div class="line">        m = (li + ri) / 2;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> m;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_evaluate() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_evaluate(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// map theta to 0..1 range</span></div>
<div class="line">    <span class="keywordtype">float</span> u = (theta_phi[0] - lp.theta_phi_start.x) *</div>
<div class="line">        lp.theta_phi_inv_delta.x * lp.inv_angular_resolution.x;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// converting input phi from -pi..pi to 0..2pi</span></div>
<div class="line">    <span class="keywordtype">float</span> phi = (theta_phi[1] &gt; 0.0f) ? theta_phi[1] : (float(2.0 * M_PI) + theta_phi[1]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// floorf wraps phi range into 0..2pi</span></div>
<div class="line">    phi = phi - lp.theta_phi_start.y -</div>
<div class="line">        floorf((phi - lp.theta_phi_start.y) * <span class="keywordtype">float</span>(0.5 / M_PI)) * float(2.0 * M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// (phi &lt; 0.0f) is no problem, this is handle by the (black) border</span></div>
<div class="line">    <span class="comment">// since it implies lp.theta_phi_start.y &gt; 0 (and we really have &quot;no data&quot; below that)</span></div>
<div class="line">    <span class="keywordtype">float</span> v = phi * lp.theta_phi_inv_delta.y * lp.inv_angular_resolution.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// half pixel offset</span></div>
<div class="line">    <span class="comment">// see https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#linear-filtering</span></div>
<div class="line">    u += 0.5f * lp.inv_angular_resolution.x;</div>
<div class="line">    v += 0.5f * lp.inv_angular_resolution.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wrap_mode: border black would be an alternative (but it produces artifacts at low res)</span></div>
<div class="line">    <span class="keywordflow">if</span> (u &lt; 0.0f || u &gt; 1.0f || v &lt; 0.0f || v &gt; 1.0f) <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> tex2D&lt;float&gt;(lp.eval_data, u, v) * lp.candela_multiplier;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_sample() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_light_profile_sample(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],          <span class="comment">// output: theta, phi, pdf</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 xi[3])              <span class="comment">// uniform random values</span></div>
<div class="line">{</div>
<div class="line">    result[0] = -1.0f;  <span class="comment">// negative theta means no emission</span></div>
<div class="line">    result[1] = -1.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    uint2 res = lp.angular_resolution;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample theta_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi0 = xi[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_theta = lp.cdf_data;                          <span class="comment">// CDF theta</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta = sample_cdf(cdf_data_theta, res.x - 1, xi0);    <span class="comment">// binary search</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_data_theta[idx_theta];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_theta[idx_theta - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">        xi0 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi0 /= prob_theta;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample phi_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi1 = xi[1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_phi = cdf_data_theta + (res.x - 1)            <span class="comment">// CDF theta block</span></div>
<div class="line">                              + (idx_theta * (res.y - 1));              <span class="comment">// selected CDF for phi</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idx_phi = sample_cdf(cdf_data_phi, res.y - 1, xi1);        <span class="comment">// binary search</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_data_phi[idx_phi];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_phi[idx_phi - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">        xi1 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi1 /= prob_phi;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute theta and phi</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="comment">// sample uniformly within the patch (grid cell)</span></div>
<div class="line">    <span class="keyword">const</span> float2 start = lp.theta_phi_start;</div>
<div class="line">    <span class="keyword">const</span> float2 delta = lp.theta_phi_delta;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(start.x + <span class="keywordtype">float</span>(idx_theta)      * delta.x);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(start.x + <span class="keywordtype">float</span>(idx_theta + 1u) * delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//               n = \int_{\theta_0}^{\theta_1} \sin{\theta} \delta \theta</span></div>
<div class="line">    <span class="comment">//                 = 1 / (\cos{\theta_0} - \cos{\theta_1})</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//             \xi = n * \int_{\theta_0}^{\theta_1} \sin{\theta} \delta \theta</span></div>
<div class="line">    <span class="comment">// =&gt; \cos{\theta} = (1 - \xi) \cos{\theta_0} + \xi \cos{\theta_1}</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta = (1.0f - xi1) * cos_theta_0 + xi1 * cos_theta_1;</div>
<div class="line">    result[0] = acosf(cos_theta);</div>
<div class="line">    result[1] = start.y + (float(idx_phi) + xi0) * delta.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// align phi</span></div>
<div class="line">    if (result[1] &gt; <span class="keywordtype">float</span>(2.0 * M_PI)) result[1] -= <span class="keywordtype">float</span>(2.0 * M_PI);              <span class="comment">// wrap</span></div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) result[1] = <span class="keywordtype">float</span>(-2.0 * M_PI) + result[1];  <span class="comment">// to [-pi, pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute pdf</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    result[2] = prob_theta * prob_phi / (delta.y * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_pdf() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_pdf(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;  <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data</span></div>
<div class="line">    <span class="keyword">const</span> uint2 res = lp.angular_resolution;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_theta = lp.cdf_data;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// map theta to 0..1 range</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> theta = theta_phi[0] - lp.theta_phi_start.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> idx_theta = int(theta * lp.theta_phi_inv_delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// converting input phi from -pi..pi to 0..2pi</span></div>
<div class="line">    <span class="keywordtype">float</span> phi = (theta_phi[1] &gt; 0.0f) ? theta_phi[1] : (<span class="keywordtype">float</span>(2.0 * M_PI) + theta_phi[1]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// floorf wraps phi range into 0..2pi</span></div>
<div class="line">    phi = phi - lp.theta_phi_start.y -</div>
<div class="line">        floorf((phi - lp.theta_phi_start.y) * <span class="keywordtype">float</span>(0.5 / M_PI)) * float(2.0 * M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// (phi &lt; 0.0f) is no problem, this is handle by the (black) border</span></div>
<div class="line">    <span class="comment">// since it implies lp.theta_phi_start.y &gt; 0 (and we really have &quot;no data&quot; below that)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> idx_phi = int(phi * lp.theta_phi_inv_delta.y);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wrap_mode: border black would be an alternative (but it produces artifacts at low res)</span></div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &lt; 0 || idx_theta &gt; (res.x - 2) || idx_phi &lt; 0 || idx_phi &gt;(res.x - 2))</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability for theta</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_data_theta[idx_theta];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_theta[idx_theta - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability for phi</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_phi = cdf_data_theta</div>
<div class="line">        + (res.x - 1)                             <span class="comment">// CDF theta block</span></div>
<div class="line">        + (idx_theta * (res.y - 1));              <span class="comment">// selected CDF for phi</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_data_phi[idx_phi];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_phi[idx_phi - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute probability to select a position in the sphere patch</span></div>
<div class="line">    <span class="keyword">const</span> float2 start = lp.theta_phi_start;</div>
<div class="line">    <span class="keyword">const</span> float2 delta = lp.theta_phi_delta;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(start.x + <span class="keywordtype">float</span>(idx_theta)      * delta.x);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(start.x + <span class="keywordtype">float</span>(idx_theta + 1u) * delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> prob_theta * prob_phi / (delta.y * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// BSDF Measurements</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of bsdf_measurement_isvalid() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> df_bsdf_measurement_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">return</span> bsdf_measurement_index != 0 &amp;&amp; bsdf_measurement_index - 1 &lt; <span class="keyword">self</span>-&gt;num_mbsdfs;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_resolution() function needed by generated code,</span></div>
<div class="line"><span class="comment">// which retrieves the angular and chromatic resolution of the given MBSDF.</span></div>
<div class="line"><span class="comment">// The returned triple consists of: number of equi-spaced steps of theta_i and theta_o,</span></div>
<div class="line"><span class="comment">// number of equi-spaced steps of phi, and number of color channels (1 or 3).</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_resolution(</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Mbsdf <span class="keyword">const</span> &amp;bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">    {</div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass out the information</span></div>
<div class="line">    result[0] = bm.angular_resolution[part_index].x;</div>
<div class="line">    result[1] = bm.angular_resolution[part_index].y;</div>
<div class="line">    result[2] = bm.num_channels[part_index];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> float3 bsdf_compute_uvw(<span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_in[2],</div>
<div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_out[2])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// assuming each phi is between -pi and pi</span></div>
<div class="line">    <span class="keywordtype">float</span> u = theta_phi_out[1] - theta_phi_in[1];</div>
<div class="line">    <span class="keywordflow">if</span> (u &lt; 0.0) u += float(2.0 * M_PI);</div>
<div class="line">    <span class="keywordflow">if</span> (u &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) u = float(2.0 * M_PI) - u;</div>
<div class="line">    u *= M_ONE_OVER_PI;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> v = theta_phi_out[0] * float(2.0 / M_PI);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> w = theta_phi_in[0] * float(2.0 / M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> make_float3(u, v, w);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">__device__ <span class="keyword">inline</span> T bsdf_measurement_lookup(<span class="keyword">const</span> cudaTextureObject_t&amp; eval_volume,</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_in[2],</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_out[2])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 3D volume on the GPU (phi_delta x theta_out x theta_in)</span></div>
<div class="line">    <span class="keyword">const</span> float3 uvw = bsdf_compute_uvw(theta_phi_in, theta_phi_out);</div>
<div class="line">    <span class="keywordflow">return</span> tex3D&lt;T&gt;(eval_volume, uvw.x, uvw.y, uvw.z);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_evaluate() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_evaluate(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_in[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the parta</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">    {</div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle channels</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.num_channels[part_index] == 3)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> float4 sample = bsdf_measurement_lookup&lt;float4&gt;(</div>
<div class="line">            bm.eval_data[part_index], theta_phi_in, theta_phi_out);</div>
<div class="line">        store_result3(result, sample.x, sample.y, sample.z);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> sample = bsdf_measurement_lookup&lt;float&gt;(</div>
<div class="line">            bm.eval_data[part_index], theta_phi_in, theta_phi_out);</div>
<div class="line">        store_result3(result, sample);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_sample() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_sample(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],          <span class="comment">// output: theta, phi, pdf</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 xi[3],              <span class="comment">// uniform random values</span></div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    result[0] = -1.0f;  <span class="comment">// negative theta means absorption</span></div>
<div class="line">    result[1] = -1.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid MBSDFs returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// check for the part</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data</span></div>
<div class="line">    uint2 res = bm.angular_resolution[part_index];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* sample_data = bm.sample_data[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute the theta_in index (flipping input and output, BSDFs are symmetric)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_in = unsigned(theta_phi_out[0] * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    idx_theta_in = min(idx_theta_in, res.x - 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample theta_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi0 = xi[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_theta = sample_data + idx_theta_in * res.x;</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_out = sample_cdf(cdf_theta, res.x, xi0);       <span class="comment">// binary search</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_theta[idx_theta_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_theta[idx_theta_out - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">        xi0 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi0 /= prob_theta;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample phi_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi1 = xi[1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_phi = sample_data +</div>
<div class="line">                           (res.x * res.x) +                                <span class="comment">// CDF theta block</span></div>
<div class="line">                           (idx_theta_in * res.x + idx_theta_out) * res.y;  <span class="comment">// selected CDF phi</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// select which half-circle to choose with probability 0.5</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> flip = (xi1 &gt; 0.5f);</div>
<div class="line">    <span class="keywordflow">if</span> (flip)</div>
<div class="line">        xi1 = 1.0f - xi1;</div>
<div class="line">    xi1 *= 2.0f;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_phi_out = sample_cdf(cdf_phi, res.y, xi1);           <span class="comment">// binary search</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_phi[idx_phi_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_phi[idx_phi_out - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">        xi1 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi1 /= prob_phi;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute theta and phi out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keyword">const</span> float2 inv_res = bm.inv_angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = float(0.5 * M_PI) * inv_res.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi   = float(1.0 * M_PI) * inv_res.y;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(<span class="keywordtype">float</span>(idx_theta_out)      * s_theta);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(<span class="keywordtype">float</span>(idx_theta_out + 1u) * s_theta);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta = cos_theta_0 * (1.0f - xi1) + cos_theta_1 * xi1;</div>
<div class="line">    result[0] = acosf(cos_theta);</div>
<div class="line">    result[1] = (float(idx_phi_out) + xi0) * s_phi;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (flip)</div>
<div class="line">        result[1] = float(2.0 * M_PI) - result[1];  <span class="comment">// phi \in [0, 2pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// align phi</span></div>
<div class="line">    result[1] += (theta_phi_out[1] &gt; 0) ? theta_phi_out[1] : (<span class="keywordtype">float</span>(2.0 * M_PI) + theta_phi_out[1]);</div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(2.0 * M_PI)) result[1] -= <span class="keywordtype">float</span>(2.0 * M_PI);</div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) result[1] = <span class="keywordtype">float</span>(-2.0 * M_PI) + result[1];  <span class="comment">// to [-pi, pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute pdf</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    result[2] = prob_theta * prob_phi * 0.5f</div>
<div class="line">                / (s_phi * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_pdf() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_bsdf_measurement_pdf(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_in[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;  <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data and resolution</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* sample_data = bm.sample_data[part_index];</div>
<div class="line">    uint2 res = bm.angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute indices in the CDF data</span></div>
<div class="line">    float3 uvw = bsdf_compute_uvw(theta_phi_in, theta_phi_out); <span class="comment">// phi_delta, theta_out, theta_in</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_in  = unsigned(theta_phi_in[0]  * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_out = unsigned(theta_phi_out[0] * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_phi_out   = unsigned(uvw.x * <span class="keywordtype">float</span>(res.y));</div>
<div class="line">    idx_theta_in  = min(idx_theta_in, res.x - 1);</div>
<div class="line">    idx_theta_out = min(idx_theta_out, res.x - 1);</div>
<div class="line">    idx_phi_out   = min(idx_phi_out, res.y - 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability to select theta_out</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_theta = sample_data + idx_theta_in * res.x;</div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_theta[idx_theta_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_theta[idx_theta_out - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability to select phi_out</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_phi = sample_data +</div>
<div class="line">        (res.x * res.x) +                                <span class="comment">// CDF theta block</span></div>
<div class="line">        (idx_theta_in * res.x + idx_theta_out) * res.y;  <span class="comment">// selected CDF phi</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_phi[idx_phi_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_phi[idx_phi_out - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute probability to select a position in the sphere patch</span></div>
<div class="line">    float2 inv_res = bm.inv_angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = float(0.5 * M_PI) * inv_res.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi = float(1.0 * M_PI) * inv_res.y;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(<span class="keywordtype">float</span>(idx_theta_out)      * s_theta);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(<span class="keywordtype">float</span>(idx_theta_out + 1u) * s_theta);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> prob_theta * prob_phi * 0.5f</div>
<div class="line">        / (s_phi * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> df_bsdf_measurement_albedo(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[2],          <span class="comment">// output: max (in case of color) albedo</span></div>
<div class="line">                                                    <span class="comment">// for the selected direction ([0]) and</span></div>
<div class="line">                                                    <span class="comment">// global ([1])</span></div>
<div class="line">    Texture_handler <span class="keyword">const</span>       *<span class="keyword">self</span>,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> uint2 res = bm.angular_resolution[part_index];</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta = unsigned(theta_phi[0] * <span class="keywordtype">float</span>(2.0 / M_PI) * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    idx_theta = min(idx_theta, res.x - 1u);</div>
<div class="line">    result[0] = bm.albedo_data[part_index][idx_theta];</div>
<div class="line">    result[1] = bm.max_albedo[part_index];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_albedos() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_albedos(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],          <span class="comment">// output: [0] albedo refl. for theta_phi</span></div>
<div class="line">                                                    <span class="comment">//         [1] max albedo refl. global</span></div>
<div class="line">                                                    <span class="comment">//         [2] albedo trans. for theta_phi</span></div>
<div class="line">                                                    <span class="comment">//         [3] max albedo trans. global</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    result[0] = 0.0f;</div>
<div class="line">    result[1] = 0.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line">    result[3] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line"></div>
<div class="line">    df_bsdf_measurement_albedo(</div>
<div class="line">        &amp;result[0],</div>
<div class="line">        <span class="keyword">self</span>,</div>
<div class="line">        bsdf_measurement_index,</div>
<div class="line">        theta_phi,</div>
<div class="line">        <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>);</div>
<div class="line"></div>
<div class="line">    df_bsdf_measurement_albedo(</div>
<div class="line">        &amp;result[2],</div>
<div class="line">        <span class="keyword">self</span>,</div>
<div class="line">        bsdf_measurement_index,</div>
<div class="line">        theta_phi,</div>
<div class="line">        <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Normal adaption (dummy functions)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Can be enabled via backend option &quot;use_renderer_adapt_normal&quot;.</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_DUMMY_ADAPTNORMAL</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Implementation of adapt_normal().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> adapt_normal(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            normal[3])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return original normal</span></div>
<div class="line">    result[0] = normal[0];</div>
<div class="line">    result[1] = normal[1];</div>
<div class="line">    result[2] = normal[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_DUMMY_ADAPTNORMAL</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Scene data (dummy functions)</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_DUMMY_SCENEDATA</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Implementation of scene_data_isvalid().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> scene_data_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float4().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float4(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[4],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">    result[3] = default_value[3];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float3().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float3(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_color().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_color(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float2().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float2(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[2],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> scene_data_lookup_float(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    <span class="keywordflow">return</span> default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int4().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int4(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[4],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">    result[3] = default_value[3];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int3().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int3(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int2().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int2(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[2],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">int</span> scene_data_lookup_int(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span>                                    default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    <span class="keywordflow">return</span> default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float4() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float4(</div>
<div class="line">    tct_deriv_arr_float_4                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_4 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float3() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float3(</div>
<div class="line">    tct_deriv_arr_float_3                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_3 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_color() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_color(</div>
<div class="line">    tct_deriv_arr_float_3                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_3 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float2() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float2(</div>
<div class="line">    tct_deriv_arr_float_2                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_2 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float(</div>
<div class="line">    tct_deriv_float                       *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_float <span class="keyword">const</span>                 *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_DUMMY_SCENEDATA</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Vtables</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_VTABLES</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// The vtable containing all texture access handlers required by the generated code</span></div>
<div class="line"><span class="comment">// in &quot;vtable&quot; mode.</span></div>
<div class="line">__device__ <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__vtable__impl.html" title="The runtime for bitmap texture access for the generated target code can optionally be implemented in ...">mi::neuraylib::Texture_handler_vtable</a> tex_vtable = {</div>
<div class="line">    tex_lookup_float4_2d,</div>
<div class="line">    tex_lookup_float3_2d,</div>
<div class="line">    tex_texel_float4_2d,</div>
<div class="line">    tex_lookup_float4_3d,</div>
<div class="line">    tex_lookup_float3_3d,</div>
<div class="line">    tex_texel_float4_3d,</div>
<div class="line">    tex_lookup_float4_cube,</div>
<div class="line">    tex_lookup_float3_cube,</div>
<div class="line">    tex_resolution_2d,</div>
<div class="line">    tex_resolution_3d,</div>
<div class="line">    tex_texture_isvalid,</div>
<div class="line">    tex_frame,</div>
<div class="line">    df_light_profile_power,</div>
<div class="line">    df_light_profile_maximum,</div>
<div class="line">    df_light_profile_isvalid,</div>
<div class="line">    df_light_profile_evaluate,</div>
<div class="line">    df_light_profile_sample,</div>
<div class="line">    df_light_profile_pdf,</div>
<div class="line">    df_bsdf_measurement_isvalid,</div>
<div class="line">    df_bsdf_measurement_resolution,</div>
<div class="line">    df_bsdf_measurement_evaluate,</div>
<div class="line">    df_bsdf_measurement_sample,</div>
<div class="line">    df_bsdf_measurement_pdf,</div>
<div class="line">    df_bsdf_measurement_albedos,</div>
<div class="line">    adapt_normal,</div>
<div class="line">    scene_data_isvalid,</div>
<div class="line">    scene_data_lookup_float,</div>
<div class="line">    scene_data_lookup_float2,</div>
<div class="line">    scene_data_lookup_float3,</div>
<div class="line">    scene_data_lookup_float4,</div>
<div class="line">    scene_data_lookup_int,</div>
<div class="line">    scene_data_lookup_int2,</div>
<div class="line">    scene_data_lookup_int3,</div>
<div class="line">    scene_data_lookup_int4,</div>
<div class="line">    scene_data_lookup_color,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The vtable containing all texture access handlers required by the generated code</span></div>
<div class="line"><span class="comment">// in &quot;vtable&quot; mode with derivatives.</span></div>
<div class="line">__device__ <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__vtable__impl.html" title="The runtime for bitmap texture access for the generated target code can optionally be implemented in ...">mi::neuraylib::Texture_handler_deriv_vtable</a> tex_deriv_vtable = {</div>
<div class="line">    tex_lookup_deriv_float4_2d,</div>
<div class="line">    tex_lookup_deriv_float3_2d,</div>
<div class="line">    tex_texel_float4_2d,</div>
<div class="line">    tex_lookup_float4_3d,</div>
<div class="line">    tex_lookup_float3_3d,</div>
<div class="line">    tex_texel_float4_3d,</div>
<div class="line">    tex_lookup_float4_cube,</div>
<div class="line">    tex_lookup_float3_cube,</div>
<div class="line">    tex_resolution_2d,</div>
<div class="line">    tex_resolution_3d,</div>
<div class="line">    tex_texture_isvalid,</div>
<div class="line">    tex_frame,</div>
<div class="line">    df_light_profile_power,</div>
<div class="line">    df_light_profile_maximum,</div>
<div class="line">    df_light_profile_isvalid,</div>
<div class="line">    df_light_profile_evaluate,</div>
<div class="line">    df_light_profile_sample,</div>
<div class="line">    df_light_profile_pdf,</div>
<div class="line">    df_bsdf_measurement_isvalid,</div>
<div class="line">    df_bsdf_measurement_resolution,</div>
<div class="line">    df_bsdf_measurement_evaluate,</div>
<div class="line">    df_bsdf_measurement_sample,</div>
<div class="line">    df_bsdf_measurement_pdf,</div>
<div class="line">    df_bsdf_measurement_albedos,</div>
<div class="line">    adapt_normal,</div>
<div class="line">    scene_data_isvalid,</div>
<div class="line">    scene_data_lookup_float,</div>
<div class="line">    scene_data_lookup_float2,</div>
<div class="line">    scene_data_lookup_float3,</div>
<div class="line">    scene_data_lookup_float4,</div>
<div class="line">    scene_data_lookup_int,</div>
<div class="line">    scene_data_lookup_int2,</div>
<div class="line">    scene_data_lookup_int3,</div>
<div class="line">    scene_data_lookup_int4,</div>
<div class="line">    scene_data_lookup_color,</div>
<div class="line">    scene_data_lookup_deriv_float,</div>
<div class="line">    scene_data_lookup_deriv_float2,</div>
<div class="line">    scene_data_lookup_deriv_float3,</div>
<div class="line">    scene_data_lookup_deriv_float4,</div>
<div class="line">    scene_data_lookup_deriv_color,</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_VTABLES</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif  // __CUDACC__</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif  // TEXTURE_SUPPORT_CUDA_H</span></div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/shared/example_cuda_shared.h</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Code shared by CUDA MDL SDK examples</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;example_shared.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;compiled_material_traverser_base.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cuda.h&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef OPENGL_INTEROP</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;GL/glew.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cudaGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector_functions.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing an MDL texture, containing filtered and unfiltered CUDA texture</span></div>
<div class="line"><span class="comment">// objects and the size of the texture.</span></div>
<div class="line"><span class="keyword">struct </span>Texture</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Texture(cudaTextureObject_t  filtered_object,</div>
<div class="line">            cudaTextureObject_t  unfiltered_object,</div>
<div class="line">            uint3                size)</div>
<div class="line">        : filtered_object(filtered_object)</div>
<div class="line">        , unfiltered_object(unfiltered_object)</div>
<div class="line">        , size(size)</div>
<div class="line">        , inv_size(make_float3(1.0f / size.x, 1.0f / size.y, 1.0f / size.z))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t  filtered_object;    <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    cudaTextureObject_t  unfiltered_object;  <span class="comment">// uses filter mode cudaFilterModePoint</span></div>
<div class="line">    uint3                size;               <span class="comment">// size of the texture, needed for texel access</span></div>
<div class="line">    float3               inv_size;           <span class="comment">// the inverse values of the size of the texture</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing an MDL bsdf measurement.</span></div>
<div class="line"><span class="keyword">struct </span>Mbsdf</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Mbsdf()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            has_data[i] = 0u;</div>
<div class="line">            eval_data[i] = 0;</div>
<div class="line">            sample_data[i] = 0;</div>
<div class="line">            albedo_data[i] = 0;</div>
<div class="line">            this-&gt;max_albedo[i] = 0.0f;</div>
<div class="line">            angular_resolution[i] = make_uint2(0u, 0u);</div>
<div class="line">            inv_angular_resolution[i] = make_float2(0.0f, 0.0f);</div>
<div class="line">            num_channels[i] = 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Add(<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a> part,</div>
<div class="line">             <span class="keyword">const</span> uint2&amp; angular_resolution,</div>
<div class="line">             <span class="keywordtype">unsigned</span> num_channels)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">unsigned</span> part_idx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">        this-&gt;has_data[part_idx] = 1u;</div>
<div class="line">        this-&gt;angular_resolution[part_idx] = angular_resolution;</div>
<div class="line">        this-&gt;inv_angular_resolution[part_idx] = make_float2(1.0f / <span class="keywordtype">float</span>(angular_resolution.x),</div>
<div class="line">                                                             1.0f / <span class="keywordtype">float</span>(angular_resolution.y));</div>
<div class="line">        this-&gt;num_channels[part_idx] = num_channels;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span>            has_data[2];            <span class="comment">// true if there is a measurement for this part</span></div>
<div class="line">    cudaTextureObject_t eval_data[2];           <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    <span class="keywordtype">float</span>               max_albedo[2];          <span class="comment">// max albedo used to limit the multiplier</span></div>
<div class="line">    <span class="keywordtype">float</span>*              sample_data[2];         <span class="comment">// CDFs for sampling a BSDF measurement</span></div>
<div class="line">    <span class="keywordtype">float</span>*              albedo_data[2];         <span class="comment">// max albedo for each theta (isotropic)</span></div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution[2];      <span class="comment">// size of the dataset, needed for texel access</span></div>
<div class="line">    float2          inv_angular_resolution[2];  <span class="comment">// the inverse values of the size of the dataset</span></div>
<div class="line">    <span class="keywordtype">unsigned</span>        num_channels[2];            <span class="comment">// number of color channels (1 or 3)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing a Light Profile</span></div>
<div class="line"><span class="keyword">struct </span>Lightprofile</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Lightprofile(</div>
<div class="line">        uint2               angular_resolution = make_uint2(0, 0),</div>
<div class="line">        float2              theta_phi_start = make_float2(0.0f, 0.0f),</div>
<div class="line">        float2              theta_phi_delta = make_float2(0.0f, 0.0f),</div>
<div class="line">        <span class="keywordtype">float</span>               candela_multiplier = 0.0f,</div>
<div class="line">        <span class="keywordtype">float</span>               total_power = 0.0f,</div>
<div class="line">        cudaTextureObject_t eval_data = 0,</div>
<div class="line">        <span class="keywordtype">float</span>               *cdf_data = <span class="keyword">nullptr</span>)</div>
<div class="line">    : angular_resolution(angular_resolution)</div>
<div class="line">    , inv_angular_resolution(make_float2(</div>
<div class="line">        1.0f / float(angular_resolution.x),</div>
<div class="line">        1.0f / float(angular_resolution.y)))</div>
<div class="line">    , theta_phi_start(theta_phi_start)</div>
<div class="line">    , theta_phi_delta(theta_phi_delta)</div>
<div class="line">        , theta_phi_inv_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">    , candela_multiplier(candela_multiplier)</div>
<div class="line">    , total_power(total_power)</div>
<div class="line">    , eval_data(eval_data)</div>
<div class="line">    , cdf_data(cdf_data)</div>
<div class="line">    {</div>
<div class="line">        theta_phi_inv_delta.x = theta_phi_delta.x ? (1.f / theta_phi_delta.x) : 0.f;</div>
<div class="line">        theta_phi_inv_delta.y = theta_phi_delta.y ? (1.f / theta_phi_delta.y) : 0.f;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution;     <span class="comment">// angular resolution of the grid</span></div>
<div class="line">    float2          inv_angular_resolution; <span class="comment">// inverse angular resolution of the grid</span></div>
<div class="line">    float2          theta_phi_start;        <span class="comment">// start of the grid</span></div>
<div class="line">    float2          theta_phi_delta;        <span class="comment">// angular step size</span></div>
<div class="line">    float2          theta_phi_inv_delta;    <span class="comment">// inverse step size</span></div>
<div class="line">    <span class="keywordtype">float</span>           candela_multiplier;     <span class="comment">// factor to rescale the normalized data</span></div>
<div class="line">    <span class="keywordtype">float</span>           total_power;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t eval_data;          <span class="comment">// normalized data sampled on grid</span></div>
<div class="line">    <span class="keywordtype">float</span>*              cdf_data;           <span class="comment">// CDFs for sampling a light profile</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing the resources used by the generated code of a target code.</span></div>
<div class="line"><span class="keyword">struct </span>Target_code_data</div>
<div class="line">{</div>
<div class="line">    Target_code_data(</div>
<div class="line">        <span class="keywordtype">size_t</span> num_textures,</div>
<div class="line">        CUdeviceptr textures,</div>
<div class="line">        <span class="keywordtype">size_t</span> num_mbsdfs,</div>
<div class="line">        CUdeviceptr mbsdfs,</div>
<div class="line">        <span class="keywordtype">size_t</span> num_lightprofiles,</div>
<div class="line">        CUdeviceptr lightprofiles,</div>
<div class="line">                     CUdeviceptr ro_data_segment)</div>
<div class="line">        : num_textures(num_textures)</div>
<div class="line">        , textures(textures)</div>
<div class="line">        , num_mbsdfs(num_mbsdfs)</div>
<div class="line">        , mbsdfs(mbsdfs)</div>
<div class="line">        , num_lightprofiles(num_lightprofiles)</div>
<div class="line">        , lightprofiles(lightprofiles)</div>
<div class="line">        , ro_data_segment(ro_data_segment)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_textures;           <span class="comment">// number of elements in the textures field</span></div>
<div class="line">    CUdeviceptr textures;               <span class="comment">// a device pointer to a list of Texture objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_mbsdfs;             <span class="comment">// number of elements in the mbsdfs field</span></div>
<div class="line">    CUdeviceptr mbsdfs;                 <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_lightprofiles;     <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">    CUdeviceptr lightprofiles;         <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line"></div>
<div class="line">    CUdeviceptr ro_data_segment;        <span class="comment">// a device pointer to the read-only data segment, if used</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Helper functions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return a textual representation of the given value.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::string to_string(T val)</div>
<div class="line">{</div>
<div class="line">    std::ostringstream stream;</div>
<div class="line">    stream &lt;&lt; val;</div>
<div class="line">    <span class="keywordflow">return</span> stream.str();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Collects the handles in a compiled material</span></div>
<div class="line"><span class="keyword">class </span>Handle_collector : <span class="keyword">public</span> Compiled_material_traverser_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// add all handle appearing in the provided material to the collectors handle list.</span></div>
<div class="line">    <span class="keyword">explicit</span> Handle_collector(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* material)</div>
<div class="line">    : Compiled_material_traverser_base()</div>
<div class="line">    {</div>
<div class="line">        traverse(material, transaction);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get the collected handles.</span></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; get_handles()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_handles; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Called when the traversal reaches a new element.</span></div>
<div class="line">    <span class="keywordtype">void</span> visit_begin(<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* material,</div>
<div class="line">                     <span class="keyword">const</span> Compiled_material_traverser_base::Traversal_element&amp; element,</div>
<div class="line">                     <span class="keywordtype">void</span>* context)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// look for direct calls</span></div>
<div class="line">        <span class="keywordflow">if</span> (!element.expression ||</div>
<div class="line">            element.expression-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IExpression.html#a7ebbfc1f9ceee07cd8721b3cb6e20032a79fecd7418c18fa74068ab7a823eb1ed" title="A direct call expression. See mi::neuraylib::IExpression_direct_call. ">mi::neuraylib::IExpression::EK_DIRECT_CALL</a>)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// check if it is a distribution function</span></div>
<div class="line">        <span class="keyword">auto</span> transaction = <span class="keyword">static_cast&lt;</span><a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>*<span class="keyword">&gt;</span>(context);</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_direct_call&gt;</a> expr_dcall(</div>
<div class="line">            element.expression-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IExpression__direct__call.html" title="A direct call expression. ">mi::neuraylib::IExpression_direct_call</a></div>
<div class="line">            &gt;());</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_list&gt;</a> args(</div>
<div class="line">            expr_dcall-&gt;get_arguments());</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> func_def(</div>
<div class="line">            transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(</div>
<div class="line">            expr_dcall-&gt;get_definition()));</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51" title="All known semantics of functions definitions. ">mi::neuraylib::IFunction_definition::Semantics</a> semantic = func_def-&gt;</div>
<div class="line">            get_semantic();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (semantic &lt; mi::neuraylib::IFunction_definition::DS_INTRINSIC_DF_FIRST</div>
<div class="line">            || semantic &gt; mi::neuraylib::IFunction_definition::DS_INTRINSIC_DF_LAST)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// check if the last argument is a handle</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_list&gt;</a> arguments(</div>
<div class="line">            expr_dcall-&gt;get_arguments());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> arg_count = arguments-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IExpression__list.html#a8f729ca92305e91f7a6bebff5822dde0" title="Returns the number of elements. ">get_size</a>();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* name = arguments-&gt;get_name(arg_count - 1);</div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">&quot;handle&quot;</span>) != 0)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get the handle value</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression&gt;</a> expr(</div>
<div class="line">            arguments-&gt;get_expression(arg_count - 1));</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (expr-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IExpression.html#a7ebbfc1f9ceee07cd8721b3cb6e20032ab563823691ce8b3c99a9a58bde726cef" title="A constant expression. See mi::neuraylib::IExpression_constant. ">mi::neuraylib::IExpression::EK_CONSTANT</a>)</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// is an error if &#39;handle&#39; is a reserved parameter name</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_constant&gt;</a> expr_const(</div>
<div class="line">            expr-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IExpression__constant.html" title="A constant expression. ">mi::neuraylib::IExpression_constant</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IValue&gt;</a> value(expr_const-&gt;get_value());</div>
<div class="line">        <span class="keywordflow">if</span> (value-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49ae5c46734d11a735e06d32592029cf431" title="A string value. See mi::neuraylib::IValue_string. ">mi::neuraylib::IValue::VK_STRING</a>)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IValue_string&gt;</a> handle(</div>
<div class="line">            value-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue__string.html" title="A value of type string. ">mi::neuraylib::IValue_string</a>&gt;());</div>
<div class="line"></div>
<div class="line">        std::string handle_value = handle-&gt;get_value() ? std::string(handle-&gt;get_value()) : <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (std::find(m_handles.begin(), m_handles.end(), handle_value) == m_handles.end())</div>
<div class="line">            m_handles.push_back(handle_value);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt;std::string&gt; m_handles;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// CUDA helper functions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper macro. Checks whether the expression is cudaSuccess and if not prints a message and</span></div>
<div class="line"><span class="comment">// resets the device and exits.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DEPRECATED_UTILIY_FUNCTIONS</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define check_cuda_success(expr) \</span></div>
<div class="line"><span class="preprocessor">    do { \</span></div>
<div class="line"><span class="preprocessor">        int err = (expr); \</span></div>
<div class="line"><span class="preprocessor">        if (err != 0) { \</span></div>
<div class="line"><span class="preprocessor">            fprintf(stderr, &quot;CUDA error %d in file %s, line %u: \&quot;%s\&quot;.\n&quot;, \</span></div>
<div class="line"><span class="preprocessor">                err, __FILE__, __LINE__, #expr); \</span></div>
<div class="line"><span class="preprocessor">            keep_console_open(); \</span></div>
<div class="line"><span class="preprocessor">            cudaDeviceReset(); \</span></div>
<div class="line"><span class="preprocessor">            exit(EXIT_FAILURE); \</span></div>
<div class="line"><span class="preprocessor">        } \</span></div>
<div class="line"><span class="preprocessor">    } while (false)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define check_cuda_success(expr) \</span></div>
<div class="line"><span class="preprocessor">    do { \</span></div>
<div class="line"><span class="preprocessor">        int err = (expr); \</span></div>
<div class="line"><span class="preprocessor">        if (err != 0) { \</span></div>
<div class="line"><span class="preprocessor">            cudaDeviceReset(); \</span></div>
<div class="line"><span class="preprocessor">            exit_failure( &quot;Error in file %s, line %u: \&quot;%s\&quot;.\n&quot;, __FILE__, __LINE__, #expr); \</span></div>
<div class="line"><span class="preprocessor">        } \</span></div>
<div class="line"><span class="preprocessor">    } while (false)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Initialize CUDA.</span></div>
<div class="line">CUcontext init_cuda(</div>
<div class="line">    <span class="keywordtype">int</span> ordinal</div>
<div class="line">#ifdef OPENGL_INTEROP</div>
<div class="line">    , <span class="keyword">const</span> <span class="keywordtype">bool</span> opengl_interop</div>
<div class="line">#endif</div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    CUdevice cu_device;</div>
<div class="line">    CUcontext cu_context;</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuInit(0));</div>
<div class="line"><span class="preprocessor">#if defined(OPENGL_INTEROP) &amp;&amp; !defined(__APPLE__)</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordflow">if</span> (opengl_interop) {</div>
<div class="line">        <span class="comment">// Use first device used by OpenGL context</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_cu_devices;</div>
<div class="line">        check_cuda_success(cuGLGetDevices(&amp;num_cu_devices, &amp;cu_device, 1, CU_GL_DEVICE_LIST_ALL));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    {</div>
<div class="line">        <span class="comment">// Use given device</span></div>
<div class="line">        check_cuda_success(cuDeviceGet(&amp;cu_device, ordinal));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuCtxCreate(&amp;cu_context, 0, cu_device));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For this example, increase printf CUDA buffer size to support a larger number</span></div>
<div class="line">    <span class="comment">// of MDL debug::print() calls per CUDA kernel launch</span></div>
<div class="line">    cudaDeviceSetLimit(cudaLimitPrintfFifoSize, 16 * 1024 * 1024);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cu_context;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Uninitialize CUDA.</span></div>
<div class="line"><span class="keywordtype">void</span> uninit_cuda(CUcontext cuda_context)</div>
<div class="line">{</div>
<div class="line">    check_cuda_success(cuCtxDestroy(cuda_context));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>Resource_deleter {</div>
<div class="line">    <span class="comment">/*compile error*/</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;cudaArray_t&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(cudaArray_t res) { check_cuda_success(cudaFreeArray(res)); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;cudaMipmappedArray_t&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(cudaMipmappedArray_t res) { check_cuda_success(cudaFreeMipmappedArray(res)); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Texture&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Texture &amp;res) {</div>
<div class="line">        check_cuda_success(cudaDestroyTextureObject(res.filtered_object));</div>
<div class="line">        check_cuda_success(cudaDestroyTextureObject(res.unfiltered_object));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Mbsdf&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Mbsdf &amp;res) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (res.has_data[i] != 0u) {</div>
<div class="line">                check_cuda_success(cudaDestroyTextureObject(res.eval_data[i]));</div>
<div class="line">                check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(res.sample_data[i])));</div>
<div class="line">                check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(res.albedo_data[i])));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Lightprofile&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Lightprofile res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res.cdf_data)</div>
<div class="line">            check_cuda_success(cuMemFree((CUdeviceptr)res.cdf_data));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Target_code_data&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Target_code_data &amp;res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res.textures)</div>
<div class="line">            check_cuda_success(cuMemFree(res.textures));</div>
<div class="line">        <span class="keywordflow">if</span> (res.ro_data_segment)</div>
<div class="line">            check_cuda_success(cuMemFree(res.ro_data_segment));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;CUdeviceptr&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CUdeviceptr res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res != 0)</div>
<div class="line">            check_cuda_success(cuMemFree(res));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = Resource_deleter&lt;T&gt; &gt;</div>
<div class="line"><span class="keyword">struct </span>Resource_handle {</div>
<div class="line">    Resource_handle(T res) : m_res(res) {}</div>
<div class="line"></div>
<div class="line">    ~Resource_handle() {</div>
<div class="line">        D deleter;</div>
<div class="line">        deleter(m_res);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    T &amp;<span class="keyword">get</span>() { <span class="keywordflow">return</span> m_res; }</div>
<div class="line"></div>
<div class="line">    T <span class="keyword">const</span> &amp;<span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> m_res; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> set(T res) { m_res = res; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// No copy possible.</span></div>
<div class="line">    Resource_handle(Resource_handle <span class="keyword">const</span> &amp;);</div>
<div class="line">    Resource_handle &amp;operator=(Resource_handle <span class="keyword">const</span> &amp;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    T m_res;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C = std::vector&lt;T&gt;, <span class="keyword">typename</span> D = Resource_deleter&lt;T&gt; &gt;</div>
<div class="line"><span class="keyword">struct </span>Resource_container {</div>
<div class="line">    Resource_container() : m_cont() {}</div>
<div class="line"></div>
<div class="line">    ~Resource_container() {</div>
<div class="line">        D deleter;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> C::iterator I;</div>
<div class="line">        <span class="keywordflow">for</span> (I it(m_cont.begin()), end(m_cont.end()); it != end; ++it) {</div>
<div class="line">            T &amp;r = *it;</div>
<div class="line">            deleter(r);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    C &amp;<a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>() { <span class="keywordflow">return</span> m_cont; }</div>
<div class="line"></div>
<div class="line">    C <span class="keyword">const</span> &amp;<a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_cont; }</div>
<div class="line"></div>
<div class="line">    C *operator-&gt;() { <span class="keywordflow">return</span> &amp;m_cont; }</div>
<div class="line"></div>
<div class="line">    C <span class="keyword">const</span> *operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;m_cont; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// No copy possible.</span></div>
<div class="line">    Resource_container(Resource_container <span class="keyword">const</span> &amp;);</div>
<div class="line">    Resource_container &amp;operator=(Resource_container <span class="keyword">const</span> &amp;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    C m_cont;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line">CUdeviceptr gpu_mem_dup(<span class="keywordtype">void</span> <span class="keyword">const</span> *data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    CUdeviceptr device_ptr;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;device_ptr, size));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(device_ptr, data, size));</div>
<div class="line">    <span class="keywordflow">return</span> device_ptr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(Resource_handle&lt;T&gt; <span class="keyword">const</span> *data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup((<span class="keywordtype">void</span> *)data-&gt;get(), size);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(std::vector&lt;T&gt; <span class="keyword">const</span> &amp;data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup(&amp;data[0], data.size() * <span class="keyword">sizeof</span>(T));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(Resource_container&lt;T,C&gt; <span class="keyword">const</span> &amp;cont)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup(*cont);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Material_gpu_context class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper class responsible for making textures and read-only data available to the GPU</span></div>
<div class="line"><span class="comment">// by generating and managing a list of Target_code_data objects.</span></div>
<div class="line"><span class="keyword">class </span>Material_gpu_context</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Material_gpu_context(<span class="keywordtype">bool</span> enable_derivatives)</div>
<div class="line">        : m_enable_derivatives(enable_derivatives)</div>
<div class="line">        , m_device_target_code_data_list(0)</div>
<div class="line">        , m_device_target_argument_block_list(0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Use first entry as &quot;not-used&quot; block</span></div>
<div class="line">        m_target_argument_block_list-&gt;push_back(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the needed data of the given target code.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_target_code_data(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>          *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>            *image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span>    *target_code,</div>
<div class="line">        std::vector&lt;size_t&gt; <span class="keyword">const</span>            &amp;arg_block_indices);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the target code data list.</span></div>
<div class="line">    CUdeviceptr get_device_target_code_data_list();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the target argument block list.</span></div>
<div class="line">    CUdeviceptr get_device_target_argument_block_list();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the i&#39;th target argument block.</span></div>
<div class="line">    CUdeviceptr get_device_target_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// First entry is the &quot;not-used&quot; block, so start at index 1.</span></div>
<div class="line">        <span class="keywordflow">if</span> (i + 1 &gt;= m_target_argument_block_list-&gt;size())</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        <span class="keywordflow">return</span> (*m_target_argument_block_list)[i + 1];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the number of target argument blocks.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_argument_block_count()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_own_arg_blocks.size();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the argument block of the i&#39;th BSDF.</span></div>
<div class="line">    <span class="comment">// If the BSDF has no target argument block, size_t(~0) is returned.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_bsdf_argument_block_index(<span class="keywordtype">size_t</span> i)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_bsdf_arg_block_indices.size()) <span class="keywordflow">return</span> <span class="keywordtype">size_t</span>(~0);</div>
<div class="line">        <span class="keywordflow">return</span> m_bsdf_arg_block_indices[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a writable copy of the i&#39;th target argument block.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a> get_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_own_arg_blocks.size())</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a>();</div>
<div class="line">        <span class="keywordflow">return</span> m_own_arg_blocks[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the layout of the i&#39;th target argument block.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt;</a> get_argument_block_layout(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_arg_block_layouts.size())</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt;</a>();</div>
<div class="line">        <span class="keywordflow">return</span> m_arg_block_layouts[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the i&#39;th target argument block on the device with the data from the corresponding</span></div>
<div class="line">    <span class="comment">// block returned by get_argument_block().</span></div>
<div class="line">    <span class="keywordtype">void</span> update_device_argument_block(<span class="keywordtype">size_t</span> i);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Copy the image data of a canvas to a CUDA array.</span></div>
<div class="line">    <span class="keywordtype">void</span> copy_canvas_to_cuda_array(cudaArray_t device_array, <a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> <span class="keyword">const</span> *canvas);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line">    <span class="comment">// on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_texture(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>         *image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           texture_index,</div>
<div class="line">        std::vector&lt;Texture&gt;              &amp;textures);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the mbsdf identified by the mbsdf_index for use by the bsdf measurement access</span></div>
<div class="line">    <span class="comment">// functions on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_mbsdf(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           mbsdf_index,</div>
<div class="line">        std::vector&lt;Mbsdf&gt;                &amp;mbsdfs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the mbsdf identified by the mbsdf_index for use by the bsdf measurement access</span></div>
<div class="line">    <span class="comment">// functions on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_lightprofile(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           lightprofile_index,</div>
<div class="line">        std::vector&lt;Lightprofile&gt;        &amp;lightprofiles);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If true, mipmaps will be generated for all 2D textures.</span></div>
<div class="line">    <span class="keywordtype">bool</span> m_enable_derivatives;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The device pointer of the target code data list.</span></div>
<div class="line">    Resource_handle&lt;CUdeviceptr&gt; m_device_target_code_data_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target code data objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Target_code_data&gt; m_target_code_data_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The device pointer of the target argument block list.</span></div>
<div class="line">    Resource_handle&lt;CUdeviceptr&gt; m_device_target_argument_block_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target argument blocks owned by this context.</span></div>
<div class="line">    Resource_container&lt;CUdeviceptr&gt; m_target_argument_block_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all local, writable copies of the target argument blocks.</span></div>
<div class="line">    std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt; &gt; m_own_arg_blocks;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of argument block indices per material BSDF.</span></div>
<div class="line">    std::vector&lt;size_t&gt; m_bsdf_arg_block_indices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target argument block layouts.</span></div>
<div class="line">    std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt; &gt; m_arg_block_layouts;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all Texture objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Texture&gt; m_all_textures;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all MBSDFs objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Mbsdf&gt; m_all_mbsdfs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all Light profiles objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Lightprofile&gt; m_all_lightprofiles;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all CUDA arrays owned by this context.</span></div>
<div class="line">    Resource_container&lt;cudaArray_t&gt; m_all_texture_arrays;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all CUDA mipmapped arrays owned by this context.</span></div>
<div class="line">    Resource_container&lt;cudaMipmappedArray_t&gt; m_all_texture_mipmapped_arrays;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get a device pointer to the target code data list.</span></div>
<div class="line">CUdeviceptr Material_gpu_context::get_device_target_code_data_list()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!m_device_target_code_data_list.get())</div>
<div class="line">        m_device_target_code_data_list.set(gpu_mem_dup(m_target_code_data_list));</div>
<div class="line">    <span class="keywordflow">return</span> m_device_target_code_data_list.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get a device pointer to the target argument block list.</span></div>
<div class="line">CUdeviceptr Material_gpu_context::get_device_target_argument_block_list()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!m_device_target_argument_block_list.get())</div>
<div class="line">        m_device_target_argument_block_list.set(gpu_mem_dup(m_target_argument_block_list));</div>
<div class="line">    <span class="keywordflow">return</span> m_device_target_argument_block_list.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy the image data of a canvas to a CUDA array.</span></div>
<div class="line"><span class="keywordtype">void</span> Material_gpu_context::copy_canvas_to_cuda_array(</div>
<div class="line">    cudaArray_t device_array,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> <span class="keyword">const</span> *canvas)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const</span> *data = <span class="keyword">static_cast&lt;</span><a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line">    check_cuda_success(cudaMemcpy2DToArray(</div>
<div class="line">        device_array, 0, 0, data,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>() * <span class="keyword">sizeof</span>(float) * 4,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>() * <span class="keyword">sizeof</span>(float) * 4,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>(),</div>
<div class="line">        cudaMemcpyHostToDevice));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line"><span class="comment">// on the GPU.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_texture(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>         *image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           texture_index,</div>
<div class="line">    std::vector&lt;Texture&gt;              &amp;textures)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITexture&gt;</a> texture(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(texture_index)));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IImage&gt;</a> image(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(texture-&gt;get_image()));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas(0, 0, 0));</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_width = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_height = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_layers = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a1d62d69c848f7b4da053bac9e071bb75" title="Returns the number of layers this canvas has. ">get_layers_size</a>();</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *image_type = image-&gt;get_type(0, 0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (image-&gt;is_uvtile() || image-&gt;is_animated()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;The example does not support uvtile and/or animated textures!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For simplicity, the texture access functions are only implemented for float4 and gamma</span></div>
<div class="line">    <span class="comment">// is pre-applied here (all images are converted to linear space).</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert to linear color space if necessary</span></div>
<div class="line">    <span class="keywordflow">if</span> (texture-&gt;get_effective_gamma(0, 0) != 1.0f) {</div>
<div class="line">        <span class="comment">// Copy/convert to float4 canvas and adjust gamma from &quot;effective gamma&quot; to 1.</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> gamma_canvas(</div>
<div class="line">            image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.get(), <span class="stringliteral">&quot;Color&quot;</span>));</div>
<div class="line">        gamma_canvas-&gt;set_gamma(texture-&gt;get_effective_gamma(0, 0));</div>
<div class="line">        image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#aef6f6c7994c60410b14d45a6cd0af7ce" title="Sets the gamma value of a canvas and adjusts the pixel data accordingly. ">adjust_gamma</a>(gamma_canvas.get(), 1.0f);</div>
<div class="line">        canvas = gamma_canvas;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(image_type, <span class="stringliteral">&quot;Color&quot;</span>) != 0 &amp;&amp; strcmp(image_type, <span class="stringliteral">&quot;Float32&lt;4&gt;&quot;</span>) != 0) {</div>
<div class="line">        <span class="comment">// Convert to expected format</span></div>
<div class="line">        canvas = image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.get(), <span class="stringliteral">&quot;Color&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc&lt;float4&gt;();</div>
<div class="line">    cudaResourceDesc res_desc;</div>
<div class="line">    memset(&amp;res_desc, 0, <span class="keyword">sizeof</span>(res_desc));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy image data to GPU array depending on texture shape</span></div>
<div class="line">    <a class="code" href="group__mi__neuray__mdl__compiler.html#gaa788bdbb9cb28f793e2c91cd8adf3faa">mi::neuraylib::ITarget_code::Texture_shape</a> texture_shape =</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1ffc64d788c1ff52bb994266a242c81c" title="Returns the texture shape of a given texture resource used by the target code. ">get_texture_shape</a>(texture_index);</div>
<div class="line">    <span class="keywordflow">if</span> (texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> ||</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaaa755f4fdb8b3cf46c19606707687ef4b" title="Three-dimensional texture. ">mi::neuraylib::ITarget_code::Texture_shape_3d</a> ||</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa7406ffbe2b2d7025a1467a7798d72400" title="Three-dimensional texture representing a BSDF data table. ">mi::neuraylib::ITarget_code::Texture_shape_bsdf_data</a>) {</div>
<div class="line">        <span class="comment">// Cubemap and 3D texture objects require 3D CUDA arrays</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> &amp;&amp;</div>
<div class="line">            tex_layers != 6) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid number of layers (&quot;</span> &lt;&lt; tex_layers</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;), cubemaps must have 6 layers!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate a 3D array on the GPU</span></div>
<div class="line">        cudaExtent extent = make_cudaExtent(tex_width, tex_height, tex_layers);</div>
<div class="line">        cudaArray_t device_tex_array;</div>
<div class="line">        check_cuda_success(cudaMalloc3DArray(</div>
<div class="line">            &amp;device_tex_array, &amp;channel_desc, extent,</div>
<div class="line">            texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> ?</div>
<div class="line">            cudaArrayCubemap : 0));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Prepare the memcpy parameter structure</span></div>
<div class="line">        cudaMemcpy3DParms copy_params;</div>
<div class="line">        memset(&amp;copy_params, 0, <span class="keyword">sizeof</span>(copy_params));</div>
<div class="line">        copy_params.dstArray = device_tex_array;</div>
<div class="line">        copy_params.extent = make_cudaExtent(tex_width, tex_height, 1);</div>
<div class="line">        copy_params.kind = cudaMemcpyHostToDevice;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy the image data of all layers (the layers are not consecutive in memory)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> layer = 0; layer &lt; tex_layers; ++layer) {</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(</div>
<div class="line">                canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>(layer));</div>
<div class="line">            <span class="keywordtype">float</span> <span class="keyword">const</span> *data = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line"></div>
<div class="line">            copy_params.srcPtr = make_cudaPitchedPtr(</div>
<div class="line">                const_cast&lt;float *&gt;(data), tex_width * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4,</div>
<div class="line">                tex_width, tex_height);</div>
<div class="line">            copy_params.dstPos = make_cudaPos(0, 0, layer);</div>
<div class="line"></div>
<div class="line">            check_cuda_success(cudaMemcpy3D(&amp;copy_params));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">        res_desc.res.array.array = device_tex_array;</div>
<div class="line"></div>
<div class="line">        m_all_texture_arrays-&gt;push_back(device_tex_array);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_enable_derivatives) {</div>
<div class="line">        <span class="comment">// mipmapped textures use CUDA mipmapped arrays</span></div>
<div class="line">        <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> num_levels = image-&gt;get_levels(0, 0);</div>
<div class="line">        cudaExtent extent = make_cudaExtent(tex_width, tex_height, 0);</div>
<div class="line">        cudaMipmappedArray_t device_tex_miparray;</div>
<div class="line">        check_cuda_success(cudaMallocMipmappedArray(</div>
<div class="line">            &amp;device_tex_miparray, &amp;channel_desc, extent, num_levels));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// create all mipmap levels and copy them to the CUDA arrays in the mipmapped array</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::IArray&gt;</a> mipmaps(image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#abb070d2b58cda51830236dccecf55210" title="Creates mipmaps from the given canvas. ">create_mipmaps</a>(canvas.get(), 1.0f));</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> level = 0; level &lt; num_levels; ++level) {</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas const&gt;</a> level_canvas;</div>
<div class="line">            <span class="keywordflow">if</span> (level == 0)</div>
<div class="line">                level_canvas = canvas;</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::IPointer&gt;</a> mipmap_ptr(mipmaps-&gt;get_element&lt;<a class="code" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a>&gt;(level - 1));</div>
<div class="line">                level_canvas = mipmap_ptr-&gt;get_pointer&lt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a>&gt;();</div>
<div class="line">            }</div>
<div class="line">            cudaArray_t device_level_array;</div>
<div class="line">            cudaGetMipmappedArrayLevel(&amp;device_level_array, device_tex_miparray, level);</div>
<div class="line">            copy_canvas_to_cuda_array(device_level_array, level_canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeMipmappedArray;</div>
<div class="line">        res_desc.res.mipmap.mipmap = device_tex_miparray;</div>
<div class="line"></div>
<div class="line">        m_all_texture_mipmapped_arrays-&gt;push_back(device_tex_miparray);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// 2D texture objects use CUDA arrays</span></div>
<div class="line">        cudaArray_t device_tex_array;</div>
<div class="line">        check_cuda_success(cudaMallocArray(</div>
<div class="line">            &amp;device_tex_array, &amp;channel_desc, tex_width, tex_height));</div>
<div class="line"></div>
<div class="line">        copy_canvas_to_cuda_array(device_tex_array, canvas.get());</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">        res_desc.res.array.array = device_tex_array;</div>
<div class="line"></div>
<div class="line">        m_all_texture_arrays-&gt;push_back(device_tex_array);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For cube maps we need clamped address mode to avoid artifacts in the corners</span></div>
<div class="line">    cudaTextureAddressMode addr_mode =</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a></div>
<div class="line">        ? cudaAddressModeClamp</div>
<div class="line">        : cudaAddressModeWrap;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create filtered texture object</span></div>
<div class="line">    cudaTextureDesc tex_desc;</div>
<div class="line">    memset(&amp;tex_desc, 0, <span class="keyword">sizeof</span>(tex_desc));</div>
<div class="line">    tex_desc.addressMode[0]   = addr_mode;</div>
<div class="line">    tex_desc.addressMode[1]   = addr_mode;</div>
<div class="line">    tex_desc.addressMode[2]   = addr_mode;</div>
<div class="line">    tex_desc.filterMode       = cudaFilterModeLinear;</div>
<div class="line">    tex_desc.readMode         = cudaReadModeElementType;</div>
<div class="line">    tex_desc.normalizedCoords = 1;</div>
<div class="line">    <span class="keywordflow">if</span> (res_desc.resType == cudaResourceTypeMipmappedArray) {</div>
<div class="line">        tex_desc.mipmapFilterMode = cudaFilterModeLinear;</div>
<div class="line">        tex_desc.maxAnisotropy = 16;</div>
<div class="line">        tex_desc.minMipmapLevelClamp = 0.f;</div>
<div class="line">        tex_desc.maxMipmapLevelClamp = 1000.f;  <span class="comment">// default value in OpenGL</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t tex_obj = 0;</div>
<div class="line">    check_cuda_success(cudaCreateTextureObject(&amp;tex_obj, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create unfiltered texture object if necessary (cube textures have no texel functions)</span></div>
<div class="line">    cudaTextureObject_t tex_obj_unfilt = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (texture_shape != <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a>) {</div>
<div class="line">        <span class="comment">// Use a black border for access outside of the texture</span></div>
<div class="line">        tex_desc.addressMode[0]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.addressMode[1]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.addressMode[2]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.filterMode       = cudaFilterModePoint;</div>
<div class="line"></div>
<div class="line">        check_cuda_success(cudaCreateTextureObject(</div>
<div class="line">            &amp;tex_obj_unfilt, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Store texture infos in result vector</span></div>
<div class="line">    textures.push_back(Texture(</div>
<div class="line">        tex_obj,</div>
<div class="line">        tex_obj_unfilt,</div>
<div class="line">        make_uint3(tex_width, tex_height, tex_layers)));</div>
<div class="line">    m_all_textures-&gt;push_back(textures.back());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a> part, Mbsdf&amp; mbsdf_cuda_representation,</div>
<div class="line">                             <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html" title="A scene element that stores measured BSDF data. ">mi::neuraylib::IBsdf_measurement</a>* bsdf_measurement)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::Bsdf_isotropic_data&gt;</a> dataset;</div>
<div class="line">        <span class="keywordflow">switch</span> (part)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>:</div>
<div class="line">                dataset = bsdf_measurement-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html#a1fac5d8562d606091ea652528480b37f" title="Returns the BSDF data for the reflection. ">get_reflection</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html" title="Example implementation of the abstract interface mi::neuraylib::IBsdf_isotropic_data. ">mi::neuraylib::Bsdf_isotropic_data</a>&gt;();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>:</div>
<div class="line">                dataset = bsdf_measurement-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html#af7ffdff52a088d45a12e93aa5d65bb72" title="Returns the BSDF data for transmission. ">get_transmission</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html" title="Example implementation of the abstract interface mi::neuraylib::IBsdf_isotropic_data. ">mi::neuraylib::Bsdf_isotropic_data</a>&gt;();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// no data, fine</span></div>
<div class="line">        <span class="keywordflow">if</span> (!dataset)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get dimensions</span></div>
<div class="line">        uint2 res;</div>
<div class="line">        res.x = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a5b71354f2117339bb9581631137460f1" title="Returns the number of values in theta direction. ">get_resolution_theta</a>();</div>
<div class="line">        res.y = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#abd7643ec08b101e4e58f591d6e80af06" title="Returns the number of values in phi direction. ">get_resolution_phi</a>();</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_channels = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a60f76457e265c983409dc04dde554119" title="Returns the type of the values. ">get_type</a>() == <a class="code" href="group__mi__neuray__misc.html#gga038cede92a99d99c9df55a87727c2c92ad8c362821ed5a71bb29f64c4dd4db7c7" title="One scalar per grid value. ">mi::neuraylib::BSDF_SCALAR</a> ? 1 : 3;</div>
<div class="line">        mbsdf_cuda_representation.Add(part, res, num_channels);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// get data</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IBsdf_buffer&gt;</a> buffer(dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a4d24f4d314a00dc7d88af2534f834111" title="Returns the buffer containing the values (const). ">get_bsdf_buffer</a>());</div>
<div class="line">        <span class="comment">// {1,3} * (index_theta_in * (res_phi * res_theta) + index_theta_out * res_phi + index_phi)</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a>* src_data = buffer-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__buffer.html#a58dc792ae63b977ef02549a4b9e3c417" title="Returns the memory block containing the actual BSDF values. ">get_data</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line">        <span class="comment">// prepare importance sampling data:</span></div>
<div class="line">        <span class="comment">// - for theta_in we will be able to perform a two stage CDF, first to select theta_out,</span></div>
<div class="line">        <span class="comment">//   and second to select phi_out</span></div>
<div class="line">        <span class="comment">// - maximum component is used to &quot;probability&quot; in case of colored measurements</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// CDF of the probability to select a certain theta_out for a given theta_in</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cdf_theta_size = res.x * res.x;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// for each of theta_in x theta_out combination, a CDF of the probabilities to select a</span></div>
<div class="line">        <span class="comment">// a certain theta_out is stored</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sample_data_size = cdf_theta_size + cdf_theta_size * res.y;</div>
<div class="line">        <span class="keywordtype">float</span>* sample_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[sample_data_size];</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span>* albedo_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[res.x]; <span class="comment">// albedo for sampling reflection and transmission</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span>* sample_data_theta = sample_data;                <span class="comment">// begin of the first (theta) CDF</span></div>
<div class="line">        <span class="keywordtype">float</span>* sample_data_phi = sample_data + cdf_theta_size; <span class="comment">// begin of the second (phi) CDFs</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = (float) (M_PI * 0.5) / float(res.x);  <span class="comment">// step size</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi = (float) (M_PI) / float(res.y);          <span class="comment">// step size</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> max_albedo = 0.0f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_in = 0; t_in &lt; res.x; ++t_in)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">float</span> sum_theta = 0.0f;</div>
<div class="line">            <span class="keywordtype">float</span> sintheta0_sqd = 0.0f;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> sintheta1 = sinf(<span class="keywordtype">float</span>(t_out + 1) * s_theta);</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> sintheta1_sqd = sintheta1 * sintheta1;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// BSDFs are symmetric: f(w_in, w_out) = f(w_out, w_in)</span></div>
<div class="line">                <span class="comment">// take the average of both measurements</span></div>
<div class="line"></div>
<div class="line">                <span class="comment">// area of two the surface elements (the ones we are averaging)</span></div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> mu = (sintheta1_sqd - sintheta0_sqd) * s_phi * 0.5f;</div>
<div class="line">                sintheta0_sqd = sintheta1_sqd;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// offset for both the thetas into the measurement data (select row in the volume)</span></div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi  = (t_in * res.x + t_out) * res.y;</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi2 = (t_out * res.x + t_in) * res.y;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// build CDF for phi</span></div>
<div class="line">                <span class="keywordtype">float</span> sum_phi = 0.0f;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx  = offset_phi  + p_out;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx2 = offset_phi2 + p_out;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordtype">float</span> value = 0.0f;</div>
<div class="line">                    <span class="keywordflow">if</span> (num_channels == 3)</div>
<div class="line">                    {</div>
<div class="line">                        value = fmax(fmaxf(src_data[3 * idx  + 0], src_data[3 * idx  + 1]),</div>
<div class="line">                                     fmaxf(src_data[3 * idx  + 2], 0.0f))</div>
<div class="line">                              + fmax(fmaxf(src_data[3 * idx2 + 0], src_data[3 * idx2 + 1]),</div>
<div class="line">                                     fmaxf(src_data[3 * idx2 + 2], 0.0f));</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="comment">/* num_channels == 1 */</span></div>
<div class="line">                    {</div>
<div class="line">                        value = fmaxf(src_data[idx], 0.0f) + fmaxf(src_data[idx2], 0.0f);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    sum_phi += value * mu;</div>
<div class="line">                    sample_data_phi[idx] = sum_phi;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// normalize CDF for phi</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = offset_phi + p_out;</div>
<div class="line">                    sample_data_phi[idx] = sample_data_phi[idx] / sum_phi;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// build CDF for theta</span></div>
<div class="line">                sum_theta += sum_phi;</div>
<div class="line">                sample_data_theta[t_in * res.x + t_out] = sum_theta;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (sum_theta &gt; max_albedo)</div>
<div class="line">                max_albedo = sum_theta;</div>
<div class="line"></div>
<div class="line">            albedo_data[t_in] = sum_theta;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// normalize CDF for theta</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = t_in * res.x + t_out;</div>
<div class="line">                sample_data_theta[idx] = sample_data_theta[idx] / sum_theta;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// copy entire CDF data buffer to GPU</span></div>
<div class="line">        CUdeviceptr sample_obj = 0;</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;sample_obj, sample_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        check_cuda_success(cuMemcpyHtoD(sample_obj, sample_data, sample_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        <span class="keyword">delete</span>[] sample_data;</div>
<div class="line"></div>
<div class="line">        CUdeviceptr albedo_obj = 0;</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;albedo_obj, res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        check_cuda_success(cuMemcpyHtoD(albedo_obj, albedo_data, res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        <span class="keyword">delete</span>[] albedo_data;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        mbsdf_cuda_representation.sample_data[part] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(sample_obj);</div>
<div class="line">        mbsdf_cuda_representation.albedo_data[part] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(albedo_obj);</div>
<div class="line">        mbsdf_cuda_representation.max_albedo[part] = max_albedo;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line">        <span class="comment">// prepare evaluation data:</span></div>
<div class="line">        <span class="comment">// - simply store the measured data in a volume texture</span></div>
<div class="line">        <span class="comment">// - in case of color data, we store each sample in a vector4 to get texture support</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> lookup_channels = (num_channels == 3) ? 4 : 1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// make lookup data symmetric</span></div>
<div class="line">        <span class="keywordtype">float</span>* lookup_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[lookup_channels * res.y * res.x * res.x];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_in = 0; t_in &lt; res.x; ++t_in)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi = (t_in * res.x + t_out) * res.y;</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi2 = (t_out * res.x + t_in) * res.y;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = offset_phi + p_out;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx2 = offset_phi2 + p_out;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (num_channels == 3)</div>
<div class="line">                    {</div>
<div class="line">                        lookup_data[4*idx+0] = (src_data[3*idx+0] + src_data[3*idx2+0]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+1] = (src_data[3*idx+1] + src_data[3*idx2+1]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+2] = (src_data[3*idx+2] + src_data[3*idx2+2]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+3] = 1.0f;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line">                        lookup_data[idx] = (src_data[idx] + src_data[idx2]) * 0.5f;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy data to GPU array</span></div>
<div class="line">        cudaArray_t device_mbsdf_data;</div>
<div class="line">        cudaChannelFormatDesc channel_desc = (num_channels == 3</div>
<div class="line">            ? cudaCreateChannelDesc&lt;float4&gt;() <span class="comment">// float3 is not supported</span></div>
<div class="line">            : cudaCreateChannelDesc&lt;float&gt;());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate a 3D array on the GPU (phi_delta x theta_out x theta_in)</span></div>
<div class="line">        cudaExtent extent = make_cudaExtent(res.y, res.x, res.x);</div>
<div class="line">        check_cuda_success(cudaMalloc3DArray(&amp;device_mbsdf_data, &amp;channel_desc, extent, 0));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// prepare and copy</span></div>
<div class="line">        cudaMemcpy3DParms copy_params;</div>
<div class="line">        memset(&amp;copy_params, 0, <span class="keyword">sizeof</span>(copy_params));</div>
<div class="line">        copy_params.srcPtr = make_cudaPitchedPtr(</div>
<div class="line">            (<span class="keywordtype">void</span>*)(lookup_data),                                   <span class="comment">// base pointer</span></div>
<div class="line">            res.y * lookup_channels * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),                <span class="comment">// row pitch</span></div>
<div class="line">            res.y,                                                  <span class="comment">// width of slice</span></div>
<div class="line">            res.x);                                                 <span class="comment">// height of slice</span></div>
<div class="line">        copy_params.dstArray = device_mbsdf_data;</div>
<div class="line">        copy_params.extent = extent;</div>
<div class="line">        copy_params.kind = cudaMemcpyHostToDevice;</div>
<div class="line">        check_cuda_success(cudaMemcpy3D(&amp;copy_params));</div>
<div class="line">        <span class="keyword">delete</span>[] lookup_data;</div>
<div class="line"></div>
<div class="line">        cudaResourceDesc    texRes;</div>
<div class="line">        memset(&amp;texRes, 0, <span class="keyword">sizeof</span>(cudaResourceDesc));</div>
<div class="line">        texRes.resType = cudaResourceTypeArray;</div>
<div class="line">        texRes.res.array.array = device_mbsdf_data;</div>
<div class="line"></div>
<div class="line">        cudaTextureDesc     texDescr;</div>
<div class="line">        memset(&amp;texDescr, 0, <span class="keyword">sizeof</span>(cudaTextureDesc));</div>
<div class="line">        texDescr.normalizedCoords = 1;</div>
<div class="line">        texDescr.filterMode = cudaFilterModeLinear;</div>
<div class="line">        texDescr.addressMode[0] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.addressMode[1] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.addressMode[2] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.readMode = cudaReadModeElementType;</div>
<div class="line"></div>
<div class="line">        cudaTextureObject_t eval_tex_obj;</div>
<div class="line">        check_cuda_success(cudaCreateTextureObject(&amp;eval_tex_obj, &amp;texRes, &amp;texDescr, <span class="keyword">nullptr</span>));</div>
<div class="line">        mbsdf_cuda_representation.eval_data[part] = eval_tex_obj;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_mbsdf(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           mbsdf_index,</div>
<div class="line">    std::vector&lt;Mbsdf&gt;                &amp;mbsdfs)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IBsdf_measurement&gt;</a> mbsdf(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html" title="A scene element that stores measured BSDF data. ">mi::neuraylib::IBsdf_measurement</a>&gt;(</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae001a474fbb738d2c5b0cd9805e456c8" title="Returns the name of a bsdf measurement resource used by the target code. ">get_bsdf_measurement</a>(mbsdf_index)));</div>
<div class="line"></div>
<div class="line">    Mbsdf mbsdf_cuda;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle reflection and transmission</span></div>
<div class="line">    <span class="keywordflow">if</span> (!prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>, mbsdf_cuda, mbsdf.get()))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>, mbsdf_cuda, mbsdf.get()))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    mbsdfs.push_back(mbsdf_cuda);</div>
<div class="line">    m_all_mbsdfs-&gt;push_back(mbsdfs.back());</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_lightprofile(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           lightprofile_index,</div>
<div class="line">    std::vector&lt;Lightprofile&gt;         &amp;lightprofiles)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ILightprofile&gt;</a> lprof_nr(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ILightprofile.html" title="This interface represents light profiles. ">mi::neuraylib::ILightprofile</a>&gt;(</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9b21ee745bcf580cce3beef23fbfc6e6" title="Returns the name of a light profile resource used by the target code. ">get_light_profile</a>(lightprofile_index)));</div>
<div class="line"></div>
<div class="line">    uint2 res = make_uint2(lprof_nr-&gt;get_resolution_theta(), lprof_nr-&gt;get_resolution_phi());</div>
<div class="line">    float2 start = make_float2(lprof_nr-&gt;get_theta(0), lprof_nr-&gt;get_phi(0));</div>
<div class="line">    float2 delta = make_float2(lprof_nr-&gt;get_theta(1) - start.x, lprof_nr-&gt;get_phi(1) - start.y);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// phi-mayor: [res.x x res.y]</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* data = lprof_nr-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITile.html#a0c4de1ae0441a464da1fc605369469f5" title="Returns a pointer to the raw tile data according to the pixel type of the tile. ">get_data</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// compute total power</span></div>
<div class="line">    <span class="comment">// compute inverse CDF data for sampling</span></div>
<div class="line">    <span class="comment">// sampling will work on cells rather than grid nodes (used for evaluation)</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// first (res.x-1) for the cdf for sampling theta</span></div>
<div class="line">    <span class="comment">// rest (rex.x-1) * (res.y-1) for the individual cdfs for sampling phi (after theta)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> cdf_data_size = (res.x - 1) + (res.x - 1) * (res.y - 1);</div>
<div class="line">    <span class="keywordtype">float</span>* cdf_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[cdf_data_size];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> debug_total_erea = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> sum_theta = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> total_power = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> cos_theta0 = cosf(start.x);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t = 0; t &lt; res.x - 1; ++t)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta1 = cosf(start.x + <span class="keywordtype">float</span>(t + 1) * delta.x);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// area of the patch (grid cell)</span></div>
<div class="line">        <span class="comment">// \mu = int_{theta0}^{theta1} sin{theta} \delta theta</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> mu = cos_theta0 - cos_theta1;</div>
<div class="line">        cos_theta0 = cos_theta1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build CDF for phi</span></div>
<div class="line">        <span class="keywordtype">float</span>* cdf_data_phi = cdf_data + (res.x - 1) + t * (res.y - 1);</div>
<div class="line">        <span class="keywordtype">float</span> sum_phi = 0.0f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; res.y - 1; ++p)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// the probability to select a patch corresponds to the value times area</span></div>
<div class="line">            <span class="comment">// the value of a cell is the average of the corners</span></div>
<div class="line">            <span class="comment">// omit the *1/4 as we normalize in the end</span></div>
<div class="line">            <span class="keywordtype">float</span> value = data[p * res.x + t]</div>
<div class="line">                + data[p * res.x + t + 1]</div>
<div class="line">                + data[(p + 1) * res.x + t]</div>
<div class="line">                + data[(p + 1) * res.x + t + 1];</div>
<div class="line"></div>
<div class="line">            sum_phi += value * mu;</div>
<div class="line">            cdf_data_phi[p] = sum_phi;</div>
<div class="line">            debug_total_erea += mu;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// normalize CDF for phi</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; res.y - 2; ++p)</div>
<div class="line">            cdf_data_phi[p] = sum_phi ? (cdf_data_phi[p] / sum_phi) : 0.0f;</div>
<div class="line"></div>
<div class="line">        cdf_data_phi[res.y - 2] = 1.0f;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build CDF for theta</span></div>
<div class="line">        sum_theta += sum_phi;</div>
<div class="line">        cdf_data[t] = sum_theta;</div>
<div class="line">    }</div>
<div class="line">    total_power = sum_theta * 0.25f * delta.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normalize CDF for theta</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t = 0; t &lt; res.x - 2; ++t)</div>
<div class="line">        cdf_data[t] = sum_theta ? (cdf_data[t] / sum_theta) : cdf_data[t];</div>
<div class="line"></div>
<div class="line">    cdf_data[res.x - 2] = 1.0f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// copy entire CDF data buffer to GPU</span></div>
<div class="line">    CUdeviceptr cdf_data_obj = 0;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;cdf_data_obj, cdf_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(cdf_data_obj, cdf_data, cdf_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">    <span class="keyword">delete</span>[] cdf_data;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// prepare evaluation data</span></div>
<div class="line">    <span class="comment">//  - use a 2d texture that allows bilinear interpolation</span></div>
<div class="line">    <span class="comment">// Copy data to GPU array</span></div>
<div class="line">    cudaArray_t device_lightprofile_data;</div>
<div class="line">    cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc&lt;float&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 2D texture objects use CUDA arrays</span></div>
<div class="line">    check_cuda_success(cudaMallocArray(&amp;device_lightprofile_data, &amp;channel_desc, res.x, res.y));</div>
<div class="line">    check_cuda_success(cudaMemcpy2DToArray(</div>
<div class="line">        device_lightprofile_data, 0, 0, data,</div>
<div class="line">        res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), res.y, cudaMemcpyHostToDevice));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create filtered texture object</span></div>
<div class="line">    cudaResourceDesc res_desc;</div>
<div class="line">    memset(&amp;res_desc, 0, <span class="keyword">sizeof</span>(res_desc));</div>
<div class="line">    res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">    res_desc.res.array.array = device_lightprofile_data;</div>
<div class="line"></div>
<div class="line">    cudaTextureDesc tex_desc;</div>
<div class="line">    memset(&amp;tex_desc, 0, <span class="keyword">sizeof</span>(tex_desc));</div>
<div class="line">    tex_desc.addressMode[0] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.addressMode[1] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.addressMode[2] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.borderColor[0] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[1] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[2] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[3] = 1.0f;</div>
<div class="line">    tex_desc.filterMode = cudaFilterModeLinear;</div>
<div class="line">    tex_desc.readMode = cudaReadModeElementType;</div>
<div class="line">    tex_desc.normalizedCoords = 1;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t tex_obj = 0;</div>
<div class="line">    check_cuda_success(cudaCreateTextureObject(&amp;tex_obj, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> multiplier = lprof_nr-&gt;get_candela_multiplier();</div>
<div class="line">    Lightprofile lprof(</div>
<div class="line">        res,</div>
<div class="line">        start,</div>
<div class="line">        delta,</div>
<div class="line">        <span class="keywordtype">float</span>(multiplier),</div>
<div class="line">        <span class="keywordtype">float</span>(total_power * multiplier),</div>
<div class="line">        tex_obj,</div>
<div class="line">        reinterpret_cast&lt;float*&gt;(cdf_data_obj));</div>
<div class="line"></div>
<div class="line">    lightprofiles.push_back(lprof);</div>
<div class="line">    m_all_lightprofiles-&gt;push_back(lightprofiles.back());</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the needed target code data of the given target code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_target_code_data(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>          *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>            *image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span>    *target_code,</div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span>            &amp;arg_block_indices)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Target code data list may not have been retrieved already</span></div>
<div class="line">    check_success(m_device_target_code_data_list.get() == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle the read-only data segments if necessary.</span></div>
<div class="line">    <span class="comment">// They are only created, if the &quot;enable_ro_segment&quot; backend option was set to &quot;on&quot;.</span></div>
<div class="line">    CUdeviceptr device_ro_data = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga2463c3e18318a828aaca780d42d1ae93" title="Returns the number of constant data initializers. ">get_ro_data_segment_count</a>() &gt; 0) {</div>
<div class="line">        device_ro_data = gpu_mem_dup(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">get_ro_data_segment_data</a>(0),</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga34a679f235fb3a81a9ffdff8205929d1" title="Returns the size of the constant data segment at the given index. ">get_ro_data_segment_size</a>(0));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy textures to GPU if the code has more than just the invalid texture</span></div>
<div class="line">    CUdeviceptr device_textures = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_textures = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">get_texture_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_textures &gt; 1) {</div>
<div class="line">        std::vector&lt;Texture&gt; textures;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all textures skipping the first texture,</span></div>
<div class="line">        <span class="comment">// which is always the invalid texture</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_textures; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_texture(</div>
<div class="line">                    transaction, image_api, target_code, i, textures))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy texture list to GPU</span></div>
<div class="line">        device_textures = gpu_mem_dup(textures);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy MBSDFs to GPU if the code has more than just the invalid mbsdf</span></div>
<div class="line">    CUdeviceptr device_mbsdfs = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_mbsdfs = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1c3669ca1523d2a98fcec3b049349f76" title="Returns the number of bsdf measurement resources used by the target code. ">get_bsdf_measurement_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_mbsdfs &gt; 1) {</div>
<div class="line">        std::vector&lt;Mbsdf&gt; mbsdfs;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all mbsdfs skipping the first mbsdf,</span></div>
<div class="line">        <span class="comment">// which is always the invalid mbsdf</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_mbsdfs; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_mbsdf(</div>
<div class="line">                transaction, target_code, i, mbsdfs))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy mbsdf list to GPU</span></div>
<div class="line">        device_mbsdfs = gpu_mem_dup(mbsdfs);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy light profiles to GPU if the code has more than just the invalid light profile</span></div>
<div class="line">    CUdeviceptr device_lightprofiles = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_lightprofiles = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gaf0cee310f5957d93edff6c4b13bc8e92" title="Returns the number of light profile resources used by the target code. ">get_light_profile_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_lightprofiles &gt; 1) {</div>
<div class="line">        std::vector&lt;Lightprofile&gt; lightprofiles;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all profiles skipping the first profile,</span></div>
<div class="line">        <span class="comment">// which is always the invalid profile</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_lightprofiles; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_lightprofile(</div>
<div class="line">                transaction, target_code, i, lightprofiles))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy light profile list to GPU</span></div>
<div class="line">        device_lightprofiles = gpu_mem_dup(lightprofiles);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    (*m_target_code_data_list).push_back(</div>
<div class="line">        Target_code_data(num_textures, device_textures,</div>
<div class="line">                         num_mbsdfs, device_mbsdfs,</div>
<div class="line">                         num_lightprofiles, device_lightprofiles,</div>
<div class="line">                         device_ro_data));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0, num = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga6e3493e83e86a5f346f935cd9ac5f3f0" title="Returns the number of target argument blocks. ">get_argument_block_count</a>(); i &lt; num; ++i) {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block const&gt;</a> arg_block(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga21940811d1cb33be2400ee7e5bd66983" title="Get a target argument block if available. ">get_argument_block</a>(i));</div>
<div class="line">        CUdeviceptr dev_block = gpu_mem_dup(arg_block-&gt;get_data(), arg_block-&gt;get_size());</div>
<div class="line">        m_target_argument_block_list-&gt;push_back(dev_block);</div>
<div class="line">        m_own_arg_blocks.push_back(<a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(arg_block-&gt;clone()));</div>
<div class="line">        m_arg_block_layouts.push_back(</div>
<div class="line">            <a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga8359a85ac66eed012aa0332a12f43e3f" title="Get a captured arguments block layout if available. ">get_argument_block_layout</a>(i)));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> arg_block_index : arg_block_indices) {</div>
<div class="line">        m_bsdf_arg_block_indices.push_back(arg_block_index);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the i&#39;th target argument block on the device with the data from the corresponding</span></div>
<div class="line"><span class="comment">// block returned by get_argument_block().</span></div>
<div class="line"><span class="keywordtype">void</span> Material_gpu_context::update_device_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">{</div>
<div class="line">    CUdeviceptr device_ptr = get_device_target_argument_block(i);</div>
<div class="line">    <span class="keywordflow">if</span> (device_ptr == 0) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a> arg_block(get_argument_block(i));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(</div>
<div class="line">        device_ptr, arg_block-&gt;get_data(), arg_block-&gt;get_size()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MDL material compilation code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Material_compiler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    Material_compiler(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_texture_results,</div>
<div class="line">#<span class="keywordflow">if</span> !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</div>
<div class="line">        <span class="keywordtype">bool</span> use_df_interpreter,</div>
<div class="line">#endif</div>
<div class="line">        <span class="keywordtype">bool</span> enable_derivatives,</div>
<div class="line">        <span class="keywordtype">bool</span> fold_ternary_on_df,</div>
<div class="line">        <span class="keywordtype">bool</span> enable_auxiliary,</div>
<div class="line">        <span class="keywordtype">bool</span> use_adapt_normal,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; df_handle_mode);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loads an MDL module and returns the module DB.</span></div>
<div class="line">    std::string load_module(<span class="keyword">const</span> std::string&amp; mdl_module_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add a subexpression of a given material to the link unit.</span></div>
<div class="line">    <span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line">    <span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line">    <span class="comment">// If class_compilation is true, the material will use class compilation.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material_subexpr(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* fname,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation=<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add a distribution function of a given material to the link unit.</span></div>
<div class="line">    <span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line">    <span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line">    <span class="comment">// If class_compilation is true, the material will use class compilation.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material_df(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* base_fname,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation=<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add (multiple) MDL distribution function and expressions of a material to this link unit.</span></div>
<div class="line">    <span class="comment">// For each distribution function it results in four functions, suffixed with \c &quot;_init&quot;,</span></div>
<div class="line">    <span class="comment">// \c &quot;_sample&quot;, \c &quot;_evaluate&quot;, and \c &quot;_pdf&quot;. Functions can be selected by providing a</span></div>
<div class="line">    <span class="comment">// a list of \c Target_function_descriptions. Each of them needs to define the \c path, the root</span></div>
<div class="line">    <span class="comment">// of the expression that should be translated. After calling this function, each element of</span></div>
<div class="line">    <span class="comment">// the list will contain information for later usage in the application,</span></div>
<div class="line">    <span class="comment">// e.g., the \c argument_block_index and the \c function_index.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>* function_descriptions,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> description_count,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generates CUDA PTX target code for the current link unit.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> generate_cuda_ptx();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;mi::base::Handle&lt;mi::neuraylib::IFunction_definition const&gt; &gt;</div>
<div class="line">        Material_definition_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the list of used material definitions.</span></div>
<div class="line">    <span class="comment">// There will be one entry per add_* call.</span></div>
<div class="line">    Material_definition_list <span class="keyword">const</span> &amp;get_material_defs()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> m_material_defs;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ICompiled_material const&gt; &gt;</div>
<div class="line">        Compiled_material_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the list of compiled materials.</span></div>
<div class="line">    <span class="comment">// There will be one entry per add_* call.</span></div>
<div class="line">    Compiled_material_list <span class="keyword">const</span> &amp;get_compiled_materials()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> m_compiled_materials;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span> &amp;get_argument_block_indices()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_arg_block_indexes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; get_handles()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_handles;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Creates an instance of the given material.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* create_material_instance(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* compile_material_instance(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> m_mdl_impexp_api;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend&gt;</a>    m_be_cuda_ptx;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a>    m_mdl_factory;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>    m_transaction;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_execution_context&gt;</a> m_context;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ILink_unit&gt;</a>             m_link_unit;</div>
<div class="line"></div>
<div class="line">    Material_definition_list  m_material_defs;</div>
<div class="line">    Compiled_material_list    m_compiled_materials;</div>
<div class="line">    std::vector&lt;size_t&gt;       m_arg_block_indexes;</div>
<div class="line">    std::vector&lt;std::string&gt;  m_handles;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor.</span></div>
<div class="line">Material_compiler::Material_compiler(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_texture_results,</div>
<div class="line">#<span class="keywordflow">if</span> !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</div>
<div class="line">        <span class="keywordtype">bool</span> use_df_interpreter,</div>
<div class="line">#endif</div>
<div class="line">        <span class="keywordtype">bool</span> enable_derivatives,</div>
<div class="line">        <span class="keywordtype">bool</span> fold_ternary_on_df,</div>
<div class="line">        <span class="keywordtype">bool</span> enable_auxiliary,</div>
<div class="line">        <span class="keywordtype">bool</span> use_adapt_normal,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; df_handle_mode)</div>
<div class="line">    : m_mdl_impexp_api(mdl_impexp_api, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_be_cuda_ptx(mdl_backend_api-&gt;get_backend(mi::neuraylib::IMdl_backend_api::MB_CUDA_PTX))</div>
<div class="line">    , m_mdl_factory(mdl_factory, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_transaction(transaction, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_context(mdl_factory-&gt;create_execution_context())</div>
<div class="line">    , m_link_unit()</div>
<div class="line">{</div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;num_texture_spaces&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;enable_ro_segment&quot;: Default is disabled.</span></div>
<div class="line">    <span class="comment">// If you have a lot of big arrays, enabling this might speed up compilation.</span></div>
<div class="line">    <span class="comment">// check_success(m_be_cuda_ptx-&gt;set_option(&quot;enable_ro_segment&quot;, &quot;on&quot;) == 0);</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (enable_derivatives) {</div>
<div class="line">        <span class="comment">// Option &quot;texture_runtime_with_derivs&quot;: Default is disabled.</span></div>
<div class="line">        <span class="comment">// We enable it to get coordinates with derivatives for texture lookup functions.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;texture_runtime_with_derivs&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;tex_lookup_call_mode&quot;: Default mode is vtable mode.</span></div>
<div class="line">    <span class="comment">// You can switch to the slower vtable mode by commenting out the next line.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;tex_lookup_call_mode&quot;</span>, <span class="stringliteral">&quot;direct_call&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;num_texture_results&quot;: Default is 0.</span></div>
<div class="line">    <span class="comment">// Set the size of a renderer provided array for texture results in the MDL SDK state in number</span></div>
<div class="line">    <span class="comment">// of float4 elements processed by the init() function.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(</div>
<div class="line">        <span class="stringliteral">&quot;num_texture_results&quot;</span>,</div>
<div class="line">        to_string(num_texture_results).c_str()) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (enable_auxiliary) {</div>
<div class="line">        <span class="comment">// Option &quot;enable_auxiliary&quot;: Default is disabled.</span></div>
<div class="line">        <span class="comment">// We enable it to create an additional &#39;auxiliary&#39; function that can be called on each</span></div>
<div class="line">        <span class="comment">// distribution function to fill an albedo and normal buffer e.g. for denoising.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;enable_auxiliary&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// Option &quot;enable_df_interpreter&quot;: Default is disabled.</span></div>
<div class="line">    <span class="comment">// Using the interpreter allows to reuse the same code for multiple materials</span></div>
<div class="line">    <span class="comment">// reducing code divergence, if your scene shows many materials at the same time.</span></div>
<div class="line">    <span class="keywordflow">if</span> (use_df_interpreter) {</div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;enable_df_interpreter&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Option &quot;df_handle_slot_mode&quot;: Default is &quot;none&quot;.</span></div>
<div class="line">    <span class="comment">// When using light path expressions, individual parts of the distribution functions can be</span></div>
<div class="line">    <span class="comment">// selected using &quot;handles&quot;. The contribution of each of those parts has to be evaluated during</span></div>
<div class="line">    <span class="comment">// rendering. This option controls how many parts are evaluated with each call into the</span></div>
<div class="line">    <span class="comment">// generated &quot;evaluate&quot; and &quot;auxiliary&quot; functions and how the data is passed.</span></div>
<div class="line">    <span class="comment">// The CUDA backend supports pointers, which means an externally managed buffer of arbitrary</span></div>
<div class="line">    <span class="comment">// size is used to transport the contributions of each part.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;df_handle_slot_mode&quot;</span>, df_handle_mode.c_str()) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;scene_data_names&quot;: Default is &quot;&quot;.</span></div>
<div class="line">    <span class="comment">// Uncomment the line below to enable calling the scene data runtime functions</span></div>
<div class="line">    <span class="comment">// for any scene data names or specify a comma-separated list of names for which</span></div>
<div class="line">    <span class="comment">// you may provide scene data. The example runtime functions always return the</span></div>
<div class="line">    <span class="comment">// default values, which is the same as not supporting any scene data.</span></div>
<div class="line">    <span class="comment">//     m_be_cuda_ptx-&gt;set_option(&quot;scene_data_names&quot;, &quot;*&quot;);</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (use_adapt_normal) {</div>
<div class="line">        <span class="comment">// Option &quot;use_renderer_adapt_normal&quot;: Default is &quot;off&quot;.</span></div>
<div class="line">        <span class="comment">// If enabled, the renderer can adapt the normal of BSDFs before use.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;use_renderer_adapt_normal&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// force experimental to true for now</span></div>
<div class="line">    m_context-&gt;set_option(<span class="stringliteral">&quot;experimental&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    m_context-&gt;set_option(<span class="stringliteral">&quot;fold_ternary_on_df&quot;</span>, fold_ternary_on_df);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// After we set the options, we can create the link unit</span></div>
<div class="line">    m_link_unit = <a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(m_be_cuda_ptx-&gt;create_link_unit(transaction, m_context.get()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::string Material_compiler::load_module(<span class="keyword">const</span> std::string&amp; mdl_module_name)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// load module</span></div>
<div class="line">    m_mdl_impexp_api-&gt;load_module(m_transaction.get(), mdl_module_name.c_str(), m_context.get());</div>
<div class="line">    <span class="keywordflow">if</span> (!print_messages(m_context.get()))</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to load module: %s&quot;</span>, mdl_module_name.c_str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get and return the DB name</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::IString&gt;</a> db_module_name(</div>
<div class="line">        m_mdl_factory-&gt;get_db_module_name(mdl_module_name.c_str()));</div>
<div class="line">    <span class="keywordflow">return</span> db_module_name-&gt;get_c_str();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creates an instance of the given material.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* Material_compiler::create_material_instance(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a material instance from the material definition</span></div>
<div class="line">    <span class="comment">// with the default arguments.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> material_definition(</div>
<div class="line">        m_transaction-&gt;access&lt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(</div>
<div class="line">            material_db_name.c_str()));</div>
<div class="line">    <span class="keywordflow">if</span> (!material_definition) {</div>
<div class="line">        <span class="comment">// material with given name does not exist</span></div>
<div class="line">        print_message(</div>
<div class="line">            <a class="code" href="group__mi__base__ilogger.html#gga35cadb98d3212ad7941f401da374f28dadaba4c0d57879faf349416dce0d3cb10" title="An error has occurred. ">mi::base::details::MESSAGE_SEVERITY_ERROR</a>,</div>
<div class="line">            <a class="code" href="classmi_1_1neuraylib_1_1IMessage.html#acd9444148b559e3d89a2b0042db48207aea0e19abaf4d2903fa254edc9d5c1051" title="MDL Core DAG generator message. ">mi::neuraylib::IMessage::MSG_COMPILER_DAG</a>,</div>
<div class="line">            (</div>
<div class="line">                <span class="stringliteral">&quot;Material &#39;&quot;</span> +</div>
<div class="line">                material_db_name +</div>
<div class="line">                <span class="stringliteral">&quot;&#39; does not exist in &#39;&quot;</span> +</div>
<div class="line">                qualified_module_name + <span class="stringliteral">&quot;&#39;&quot;</span>).c_str());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    m_material_defs.push_back(material_definition);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> result;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        material_definition-&gt;create_function_call(0, &amp;result));</div>
<div class="line">    check_success(result == 0);</div>
<div class="line"></div>
<div class="line">    material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> material_instance.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a> *Material_compiler::compile_material_instance(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> flags = class_compilation</div>
<div class="line">        ? <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959a7474d76ee055edda39a494edf06cfc36" title="Selects class compilation instead of instance compilation. ">mi::neuraylib::IMaterial_instance::CLASS_COMPILATION</a></div>
<div class="line">        : <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959afdcc06252ec8a89909ddd69006031766" title="Default compilation options (e.g., instance compilation). ">mi::neuraylib::IMaterial_instance::DEFAULT_OPTIONS</a>;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IMaterial_instance&gt;</a> material_instance2(</div>
<div class="line">        material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#aa24ef1b57dcff38f9abafc420978df5c" title="Acquires a const interface from another. ">get_interface</a>&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a>&gt;());</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        material_instance2-&gt;create_compiled_material(flags, m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line"></div>
<div class="line">    m_compiled_materials.push_back(compiled_material);</div>
<div class="line"></div>
<div class="line">    compiled_material-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> compiled_material.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generates CUDA PTX target code for the current link unit.</span></div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> Material_compiler::generate_cuda_ptx()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> code_cuda_ptx(</div>
<div class="line">        m_be_cuda_ptx-&gt;translate_link_unit(m_link_unit.get(), m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line">    check_success(code_cuda_ptx);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_PTX</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping CUDA PTX code:\n\n&quot;</span></div>
<div class="line">        &lt;&lt; code_cuda_ptx-&gt;get_code() &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">return</span> code_cuda_ptx;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a subexpression of a given material to the link unit.</span></div>
<div class="line"><span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line"><span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material_subexpr(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* fname,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a> desc;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#ga16a953c7e8bad024170a407b79372601" title="The path from the material root to the expression that should be translated, e.g., &quot;surface.scattering&quot;. ">path</a> = path;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gac11619c64e2547799987787278060abc" title="The base name of the generated functions. ">base_fname</a> = fname;</div>
<div class="line">    add_material(qualified_module_name, material_db_name, &amp;desc, 1, class_compilation);</div>
<div class="line">    <span class="keywordflow">return</span> desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gad50243f50149324fd09ca0206e35d265" title="A return code. ">return_code</a> == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a distribution function of a given material to the link unit.</span></div>
<div class="line"><span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line"><span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material_df(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* base_fname,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a> desc;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#ga16a953c7e8bad024170a407b79372601" title="The path from the material root to the expression that should be translated, e.g., &quot;surface.scattering&quot;. ">path</a> = path;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gac11619c64e2547799987787278060abc" title="The base name of the generated functions. ">base_fname</a> = base_fname;</div>
<div class="line">    add_material(qualified_module_name, material_db_name, &amp;desc, 1, class_compilation);</div>
<div class="line">    <span class="keywordflow">return</span> desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gad50243f50149324fd09ca0206e35d265" title="A return code. ">return_code</a> == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add (multiple) MDL distribution function and expressions of a material to this link unit.</span></div>
<div class="line"><span class="comment">// For each distribution function it results in four functions, suffixed with \c &quot;_init&quot;,</span></div>
<div class="line"><span class="comment">// \c &quot;_sample&quot;, \c &quot;_evaluate&quot;, and \c &quot;_pdf&quot;. Functions can be selected by providing a</span></div>
<div class="line"><span class="comment">// a list of \c Target_function_description. Each of them needs to define the \c path, the root</span></div>
<div class="line"><span class="comment">// of the expression that should be translated. After calling this function, each element of</span></div>
<div class="line"><span class="comment">// the list will contain information for later usage in the application,</span></div>
<div class="line"><span class="comment">// e.g., the \c argument_block_index and the \c function_index.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>* function_descriptions,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> description_count,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (description_count == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load the given module and create a material instance</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        create_material_instance(qualified_module_name, material_db_name));</div>
<div class="line">    <span class="keywordflow">if</span> (!material_instance)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compile the material instance in instance compilation mode</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        compile_material_instance(material_instance.get(), class_compilation));</div>
<div class="line"></div>
<div class="line">    m_link_unit-&gt;add_material(</div>
<div class="line">        compiled_material.get(), function_descriptions, description_count,</div>
<div class="line">        m_context.get());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Note: the same argument_block_index is filled into all function descriptions of a</span></div>
<div class="line">    <span class="comment">//       material, if any function uses it</span></div>
<div class="line">    m_arg_block_indexes.push_back(function_descriptions[0].argument_block_index);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> print_messages(m_context.get());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Material execution code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper function to create PTX source code for a non-empty 32-bit value array.</span></div>
<div class="line"><span class="keywordtype">void</span> print_array_u32(</div>
<div class="line">    std::string &amp;str, std::string <span class="keyword">const</span> &amp;name, <span class="keywordtype">unsigned</span> count, std::string <span class="keyword">const</span> &amp;content)</div>
<div class="line">{</div>
<div class="line">    str += <span class="stringliteral">&quot;.visible .const .align 4 .u32 &quot;</span> + name + <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (count == 0) {</div>
<div class="line">        <span class="comment">// PTX does not allow empty arrays, so use a dummy entry</span></div>
<div class="line">        str += <span class="stringliteral">&quot;1] = { 0 };\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        str += to_string(count) + <span class="stringliteral">&quot;] = { &quot;</span> + content + <span class="stringliteral">&quot; };\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper function to create PTX source code for a non-empty function pointer array.</span></div>
<div class="line"><span class="keywordtype">void</span> print_array_func(</div>
<div class="line">    std::string &amp;str, std::string <span class="keyword">const</span> &amp;name, <span class="keywordtype">unsigned</span> count, std::string <span class="keyword">const</span> &amp;content)</div>
<div class="line">{</div>
<div class="line">    str += <span class="stringliteral">&quot;.visible .const .align 8 .u64 &quot;</span> + name + <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (count == 0) {</div>
<div class="line">        <span class="comment">// PTX does not allow empty arrays, so use a dummy entry</span></div>
<div class="line">        str += <span class="stringliteral">&quot;1] = { dummy_func };\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        str += to_string(count) + <span class="stringliteral">&quot;] = { &quot;</span> + content + <span class="stringliteral">&quot; };\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate PTX array containing the references to all generated functions.</span></div>
<div class="line">std::string generate_func_array_ptx(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> &gt; &amp;target_codes)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create PTX header and mdl_expr_functions_count constant</span></div>
<div class="line">    std::string src =</div>
<div class="line">        <span class="stringliteral">&quot;.version 4.0\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;.target sm_20\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;.address_size 64\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Workaround needed to let CUDA linker resolve the function pointers in the arrays.</span></div>
<div class="line">    <span class="comment">// Also used for &quot;empty&quot; function arrays.</span></div>
<div class="line">    src += <span class="stringliteral">&quot;.func dummy_func() { ret; }\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::string tc_offsets;</div>
<div class="line">    std::string function_names;</div>
<div class="line">    std::string tc_indices;</div>
<div class="line">    std::string ab_indices;</div>
<div class="line">    <span class="keywordtype">unsigned</span> f_count = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Iterate over all target codes</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> tc_index = 0, num = target_codes.size(); tc_index &lt; num; ++tc_index)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> <span class="keyword">const</span> &amp;target_code =</div>
<div class="line">            target_codes[tc_index];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// in case of multiple target codes, we need to address the functions by a pair of</span></div>
<div class="line">        <span class="comment">// target_code_index and function_index.</span></div>
<div class="line">        <span class="comment">// the elements in the resulting function array can then be index by offset + func_index.</span></div>
<div class="line">        <span class="keywordflow">if</span>(!tc_offsets.empty())</div>
<div class="line">            tc_offsets += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        tc_offsets += to_string(f_count);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Collect all names and prototypes of callable functions within the current target code</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> func_index = 0, func_count = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5002e9d426ebb8abd844b418541d9870" title="Returns the number of callable functions in the target code. ">get_callable_function_count</a>();</div>
<div class="line">             func_index &lt; func_count; ++func_index)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// add to function list</span></div>
<div class="line">            <span class="keywordflow">if</span> (!tc_indices.empty())</div>
<div class="line">            {</div>
<div class="line">                tc_indices += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">                function_names += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">                ab_indices += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// target code index in case of multiple link units</span></div>
<div class="line">            tc_indices += to_string(tc_index);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// name of the function</span></div>
<div class="line">            function_names += target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gab23aae54fc513ea49c271ea09287ad7e" title="Returns the name of a callable function in the target code. ">get_callable_function</a>(func_index);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get argument block index and translate to 1 based list index (-&gt; 0 = not-used)</span></div>
<div class="line">            <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> ab_index = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b64734a46cffe60913b567108f30ed3" title="Get the index of the target argument block to use with a callable function. ">get_callable_function_argument_block_index</a>(func_index);</div>
<div class="line">            ab_indices += to_string(ab_index == <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(~0) ? 0 : (ab_index + 1));</div>
<div class="line">            f_count++;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add prototype declaration</span></div>
<div class="line">            src += target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga67096668a1a25617564ecd8687023fe6" title="Returns the prototype of a callable function in the target code. ">get_callable_function_prototype</a>(</div>
<div class="line">                func_index, mi::neuraylib::ITarget_code::SL_PTX);</div>
<div class="line">            src += <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// infos per target code (link unit)</span></div>
<div class="line">    src += std::string(<span class="stringliteral">&quot;.visible .const .align 4 .u32 mdl_target_code_count = &quot;</span>)</div>
<div class="line">        + to_string(target_codes.size()) + <span class="stringliteral">&quot;;\n&quot;</span>;</div>
<div class="line">    print_array_u32(</div>
<div class="line">        src, std::string(<span class="stringliteral">&quot;mdl_target_code_offsets&quot;</span>), <span class="keywordtype">unsigned</span>(target_codes.size()), tc_offsets);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// infos per function</span></div>
<div class="line">    src += std::string(<span class="stringliteral">&quot;.visible .const .align 4 .u32 mdl_functions_count = &quot;</span>)</div>
<div class="line">        + to_string(f_count) + <span class="stringliteral">&quot;;\n&quot;</span>;</div>
<div class="line">    print_array_func(src, std::string(<span class="stringliteral">&quot;mdl_functions&quot;</span>), f_count, function_names);</div>
<div class="line">    print_array_u32(src, std::string(<span class="stringliteral">&quot;mdl_arg_block_indices&quot;</span>), f_count, ab_indices);</div>
<div class="line">    print_array_u32(src, std::string(<span class="stringliteral">&quot;mdl_target_code_indices&quot;</span>), f_count, tc_indices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> src;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Build a linked CUDA kernel containing our kernel and all the generated code, making it</span></div>
<div class="line"><span class="comment">// available to the kernel via an added &quot;mdl_expr_functions&quot; array.</span></div>
<div class="line">CUmodule build_linked_kernel(</div>
<div class="line">    std::vector&lt;<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> &gt; <span class="keyword">const</span> &amp;target_codes,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *ptx_file,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_function_name,</div>
<div class="line">    CUfunction *out_kernel_function)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Generate PTX array containing the references to all generated functions.</span></div>
<div class="line">    <span class="comment">// The linker will resolve them to addresses.</span></div>
<div class="line"></div>
<div class="line">    std::string ptx_func_array_src = generate_func_array_ptx(target_codes);</div>
<div class="line"><span class="preprocessor">#ifdef DUMP_PTX</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping CUDA PTX code for the \&quot;mdl_expr_functions\&quot; array:\n\n&quot;</span></div>
<div class="line">        &lt;&lt; ptx_func_array_src &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Link all generated code, our generated PTX array and our kernel together</span></div>
<div class="line"></div>
<div class="line">    CUlinkState   cuda_link_state;</div>
<div class="line">    CUmodule      cuda_module;</div>
<div class="line">    <span class="keywordtype">void</span>         *linked_cubin;</div>
<div class="line">    <span class="keywordtype">size_t</span>        linked_cubin_size;</div>
<div class="line">    <span class="keywordtype">char</span>          error_log[8192], info_log[8192];</div>
<div class="line">    CUjit_option  options[4];</div>
<div class="line">    <span class="keywordtype">void</span>         *optionVals[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup the linker</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pass a buffer for info messages</span></div>
<div class="line">    options[0] = CU_JIT_INFO_LOG_BUFFER;</div>
<div class="line">    optionVals[0] = info_log;</div>
<div class="line">    <span class="comment">// Pass the size of the info buffer</span></div>
<div class="line">    options[1] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;</div>
<div class="line">    optionVals[1] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(uintptr_t(<span class="keyword">sizeof</span>(info_log)));</div>
<div class="line">    <span class="comment">// Pass a buffer for error messages</span></div>
<div class="line">    options[2] = CU_JIT_ERROR_LOG_BUFFER;</div>
<div class="line">    optionVals[2] = error_log;</div>
<div class="line">    <span class="comment">// Pass the size of the error buffer</span></div>
<div class="line">    options[3] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;</div>
<div class="line">    optionVals[3] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(uintptr_t(<span class="keyword">sizeof</span>(error_log)));</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuLinkCreate(4, options, optionVals, &amp;cuda_link_state));</div>
<div class="line"></div>
<div class="line">    CUresult link_result = CUDA_SUCCESS;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="comment">// Add all code generated by the MDL PTX backend</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, num_target_codes = target_codes.size(); i &lt; num_target_codes; ++i) {</div>
<div class="line">            link_result = cuLinkAddData(</div>
<div class="line">                cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">                const_cast&lt;char *&gt;(target_codes[i]-&gt;get_code()),</div>
<div class="line">                target_codes[i]-&gt;get_code_size(),</div>
<div class="line">                <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add the &quot;mdl_expr_functions&quot; array PTX module</span></div>
<div class="line">        link_result = cuLinkAddData(</div>
<div class="line">            cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">            const_cast&lt;char *&gt;(ptx_func_array_src.c_str()),</div>
<div class="line">            ptx_func_array_src.size(),</div>
<div class="line">            <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add our kernel</span></div>
<div class="line">        link_result = cuLinkAddFile(</div>
<div class="line">            cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">            ptx_file, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Link everything to a cubin</span></div>
<div class="line">        link_result = cuLinkComplete(cuda_link_state, &amp;linked_cubin, &amp;linked_cubin_size);</div>
<div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;PTX linker error:\n&quot;</span> &lt;&lt; error_log &lt;&lt; std::endl;</div>
<div class="line">        check_cuda_success(link_result);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;CUDA link completed.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">if</span> (info_log[0])</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Linker output:\n&quot;</span> &lt;&lt; info_log &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load the result and get the entrypoint of our kernel</span></div>
<div class="line">    check_cuda_success(cuModuleLoadData(&amp;cuda_module, linked_cubin));</div>
<div class="line">    check_cuda_success(cuModuleGetFunction(</div>
<div class="line">        out_kernel_function, cuda_module, kernel_function_name));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> regs = 0;</div>
<div class="line">    check_cuda_success(</div>
<div class="line">        cuFuncGetAttribute(&amp;regs, CU_FUNC_ATTRIBUTE_NUM_REGS, *out_kernel_function));</div>
<div class="line">    <span class="keywordtype">int</span> lmem = 0;</div>
<div class="line">    check_cuda_success(</div>
<div class="line">        cuFuncGetAttribute(&amp;lmem, CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, *out_kernel_function));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Kernel uses &quot;</span> &lt;&lt; regs &lt;&lt; <span class="stringliteral">&quot; registers and &quot;</span> &lt;&lt; lmem &lt;&lt; <span class="stringliteral">&quot; lmem and has a size of &quot;</span></div>
<div class="line">        &lt;&lt; linked_cubin_size &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    check_cuda_success(cuLinkDestroy(cuda_link_state));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cuda_module;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/df_cuda/example_df_cuda.cu</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;device_launch_parameters.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;curand_kernel.h&gt;</span></div>
<div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;example_df_cuda.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;texture_support_cuda.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// To reuse this sample code for the MDL SDK and MDL Core the corresponding namespaces are used.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// when this CUDA code is used in the context of an SDK sample.</span></div>
<div class="line"><span class="preprocessor">#if defined(MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define BSDF_USE_MATERIAL_IOR MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">using namespace </span>mi::neuraylib;</div>
<div class="line"><span class="comment">// when this CUDA code is used in the context of an Core sample.</span></div>
<div class="line"><span class="preprocessor">#elif defined(MDL_CORE_BSDF_USE_MATERIAL_IOR)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define BSDF_USE_MATERIAL_IOR MDL_CORE_BSDF_USE_MATERIAL_IOR</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">using namespace </span>mi::mdl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// for LPE support there different options for the renderer, for CUDA a renderer provided buffer</span></div>
<div class="line"><span class="comment">// can be used to retrieve the contributions of the individual handles (named lobes)</span></div>
<div class="line"><span class="comment">// Note, a real renderer would go for one specific option only</span></div>
<div class="line"><span class="preprocessor">#define DF_HSM_POINTER -2</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DF_HSM_NONE    -1</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DF_HSM_FIXED_1  1</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DF_HSM_FIXED_2  2</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DF_HSM_FIXED_4  4</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define DF_HSM_FIXED_8  8</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// this is the one that is used, </span></div>
<div class="line"><span class="comment">// Note, this has to match with code backend option &quot;df_handle_slot_mode&quot;</span></div>
<div class="line"><span class="preprocessor">#define DF_HANDLE_SLOTS DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// If enabled, math::DX(state::texture_coordinates(0).xy) = float2(1, 0) and</span></div>
<div class="line"><span class="comment">// math::DY(state::texture_coordinates(0).xy) = float2(0, 1) will be used.</span></div>
<div class="line"><span class="comment">// #define USE_FAKE_DERIVATIVES</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gab7316602c27a9f88add79aeec40ef134" title="Signature of material expression functions created via mi::neuraylib::IMdl_backend::translate_materia...">Material_expr_function_with_derivs</a>                  Mat_expr_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga1070493d677516ca96389edc818ee18c" title="Signature of the initialization function for material distribution functions created via mi::neurayli...">Bsdf_init_function_with_derivs</a>                      Bsdf_init_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gab2885bfc9061432fec5e77544659cc43" title="Signature of the importance sampling function for material distribution functions created via mi::neu...">Bsdf_sample_function_with_derivs</a>                    Bsdf_sample_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga825b9666a10136ad700a9b22db09f825" title="Signature of the evaluation function for material distribution functions created via mi::neuraylib::I...">Bsdf_evaluate_function_with_derivs</a>                  Bsdf_evaluate_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga8faf70600836f62326821add78d2f0e4" title="Signature of the probability density function for material distribution functions created via mi::neu...">Bsdf_pdf_function_with_derivs</a>                       Bsdf_pdf_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga65c352ae0ea12d7e7d0665650d6bf4ba" title="Signature of the auxiliary function for material distribution functions created via mi::neuraylib::IM...">Bsdf_auxiliary_function_with_derivs</a>                 Bsdf_auxiliary_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga7696b1bb7b63307afdecc702f05f93c1" title="Signature of the initialization function for material distribution functions created via mi::neurayli...">Edf_init_function_with_derivs</a>                       Edf_init_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gac642fe7ba358d1b98d54d4605568a76e" title="Signature of the importance sampling function for material distribution functions created via mi::neu...">Edf_sample_function_with_derivs</a>                     Edf_sample_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga4da58a344c642c9b36dc07fa3adc6a9b" title="Signature of the evaluation function for material distribution functions created via mi::neuraylib::I...">Edf_evaluate_function_with_derivs</a>                   Edf_evaluate_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga35abd44547c4c57bcb8144371634ad26" title="Signature of the probability density function for material distribution functions created via mi::neu...">Edf_pdf_function_with_derivs</a>                        Edf_pdf_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga0671043f81f09534273ffd22e4ca5156" title="Signature of the auxiliary function for material distribution functions created via mi::neuraylib::IM...">Edf_auxiliary_function_with_derivs</a>                  Edf_auxiliary_func;</div>
<div class="line"><span class="keyword">typedef</span> Shading_state_material_with_derivs                  Mdl_state;</div>
<div class="line"><span class="keyword">typedef</span> Texture_handler_deriv                               Tex_handler;</div>
<div class="line"><span class="preprocessor">#define TEX_VTABLE                                          tex_deriv_vtable</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga709d350d54344584622f892f119e3dea" title="Signature of material expression functions created via mi::neuraylib::IMdl_backend::translate_materia...">Material_expr_function</a>                              Mat_expr_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga51739a4d22d4e745c1437ee0763ddd0d" title="Signature of the initialization function for material distribution functions created via mi::neurayli...">Bsdf_init_function</a>                                  Bsdf_init_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga986445d0a97d751cfd1e26664d4e1613" title="Signature of the importance sampling function for material distribution functions created via mi::neu...">Bsdf_sample_function</a>                                Bsdf_sample_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga04671962ad18856bfee1d7f24d325cdc" title="Signature of the evaluation function for material distribution functions created via mi::neuraylib::I...">Bsdf_evaluate_function</a>                              Bsdf_evaluate_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga96174ff556b7072f8cc9d55b619719f3" title="Signature of the probability density function for material distribution functions created via mi::neu...">Bsdf_pdf_function</a>                                   Bsdf_pdf_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga72e87b0641a621ddb1db106c6af83c64" title="Signature of the auxiliary function for material distribution functions created via mi::neuraylib::IM...">Bsdf_auxiliary_function</a>                             Bsdf_auxiliary_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga89a7b2f0970e10c6536e376039427acd" title="Signature of the initialization function for material distribution functions created via mi::neurayli...">Edf_init_function</a>                                   Edf_init_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga18e944f197bb079cf22373a144652f7d" title="Signature of the importance sampling function for material distribution functions created via mi::neu...">Edf_sample_function</a>                                 Edf_sample_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga11dcbd842c822f8959151b01bc052359" title="Signature of the evaluation function for material distribution functions created via mi::neuraylib::I...">Edf_evaluate_function</a>                               Edf_evaluate_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga37ef3db4d7110589d8177ff25e0c1ad2" title="Signature of the probability density function for material distribution functions created via mi::neu...">Edf_pdf_function</a>                                    Edf_pdf_func;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga917c35ddbfb1961232a8f7b37e8b3829" title="Signature of the auxiliary function for material distribution functions created via mi::neuraylib::IM...">Edf_auxiliary_function</a>                              Edf_auxiliary_func;</div>
<div class="line"><span class="keyword">typedef</span> Shading_state_material                              Mdl_state;</div>
<div class="line"><span class="keyword">typedef</span> Texture_handler                                     Tex_handler;</div>
<div class="line"><span class="preprocessor">#define TEX_VTABLE                                          tex_vtable</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Custom structure representing the resources used by the generated code of a target code object.</span></div>
<div class="line"><span class="keyword">struct </span>Target_code_data</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span>       num_textures;      <span class="comment">// number of elements in the textures field</span></div>
<div class="line">    Texture      *textures;         <span class="comment">// a list of Texture objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>       num_mbsdfs;        <span class="comment">// number of elements in the mbsdfs field</span></div>
<div class="line">    Mbsdf        *mbsdfs;           <span class="comment">// a list of mbsdfs objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>       num_lightprofiles; <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">    Lightprofile *lightprofiles;    <span class="comment">// a list of lightprofiles objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>   *ro_data_segment;  <span class="comment">// the read-only data segment, if used</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// all function types</span></div>
<div class="line"><span class="keyword">union </span>Mdl_function_ptr</div>
<div class="line">{</div>
<div class="line">    Mat_expr_func           *expression;</div>
<div class="line">    Bsdf_init_func          *bsdf_init;</div>
<div class="line">    Bsdf_sample_func        *bsdf_sample;</div>
<div class="line">    Bsdf_evaluate_func      *bsdf_evaluate;</div>
<div class="line">    Bsdf_pdf_func           *bsdf_pdf;</div>
<div class="line">    Bsdf_auxiliary_func     *bsdf_auxiliary;</div>
<div class="line">    Edf_init_func           *edf_init;</div>
<div class="line">    Edf_sample_func         *edf_sample;</div>
<div class="line">    Edf_evaluate_func       *edf_evaluate;</div>
<div class="line">    Edf_pdf_func            *edf_pdf;</div>
<div class="line">    Edf_auxiliary_func      *edf_auxiliary;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// function index offset depending on the target code</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_target_code_offsets[];</div>
<div class="line"></div>
<div class="line"><span class="comment">// number of generated functions</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_functions_count;</div>
<div class="line"></div>
<div class="line"><span class="comment">// the following arrays are indexed by an mdl_function_index</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ Mdl_function_ptr mdl_functions[];</div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_arg_block_indices[];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Identity matrix.</span></div>
<div class="line"><span class="comment">// The last row is always implied to be (0, 0, 0, 1).</span></div>
<div class="line">__constant__ <span class="keyword">const</span> float4 identity[3] = {</div>
<div class="line">    {1.0f, 0.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 1.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 0.0f, 1.0f, 0.0f}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// the material provides pairs for each generated function to evaluate</span></div>
<div class="line"><span class="comment">// the functions and arg blocks array are indexed by:</span></div>
<div class="line"><span class="comment">// mdl_target_code_offsets[target_code_index] + function_index</span></div>
<div class="line"><span class="keyword">typedef</span> uint3 Mdl_function_index;</div>
<div class="line">__device__ <span class="keyword">inline</span> Mdl_function_index get_mdl_function_index(<span class="keyword">const</span> uint2&amp; index_pair)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_uint3(</div>
<div class="line">        index_pair.x,   <span class="comment">// target_code_index</span></div>
<div class="line">        index_pair.y,   <span class="comment">// function_index inside target code</span></div>
<div class="line">        mdl_target_code_offsets[index_pair.x] + index_pair.y); <span class="comment">// global function index</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// resource handler for accessing textures and other data</span></div>
<div class="line"><span class="comment">// depends on the target code (link unit)</span></div>
<div class="line"><span class="keyword">struct </span>Mdl_resource_handler</div>
<div class="line">{</div>
<div class="line">    __device__ Mdl_resource_handler()</div>
<div class="line">    {</div>
<div class="line">        m_tex_handler.vtable = &amp;TEX_VTABLE;   <span class="comment">// only required in &#39;vtable&#39; mode, otherwise NULL</span></div>
<div class="line">        data.shared_data = NULL;</div>
<div class="line">        data.texture_handler = <span class="keyword">reinterpret_cast&lt;</span>Texture_handler_base *<span class="keyword">&gt;</span>(&amp;m_tex_handler);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// reuse the handler with a different target code index</span></div>
<div class="line">    __device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> set_target_code_index(</div>
<div class="line">        <span class="keyword">const</span> Kernel_params&amp; params, <span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">    {</div>
<div class="line">        m_tex_handler.num_textures = params.tc_data[index.x].num_textures;</div>
<div class="line">        m_tex_handler.textures = params.tc_data[index.x].textures;</div>
<div class="line">        m_tex_handler.num_mbsdfs = params.tc_data[index.x].num_mbsdfs;</div>
<div class="line">        m_tex_handler.mbsdfs = params.tc_data[index.x].mbsdfs;</div>
<div class="line">        m_tex_handler.num_lightprofiles = params.tc_data[index.x].num_lightprofiles;</div>
<div class="line">        m_tex_handler.lightprofiles = params.tc_data[index.x].lightprofiles;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// a pointer to this data is passed to all generated functions</span></div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Resource__data.html" title="The data structure providing access to resources for generated code. ">Resource_data</a> data;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    Tex_handler m_tex_handler;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// checks if the indexed function can be evaluated or not</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">bool</span> is_valid(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> index.y != 0xFFFFFFFFu;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// get a pointer to the material parameters which is passed to all generated functions</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* get_arg_block(</div>
<div class="line">    <span class="keyword">const</span> Kernel_params&amp; params,</div>
<div class="line">    <span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> params.arg_block_list[mdl_arg_block_indices[index.z]];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Init function</span></div>
<div class="line">__device__ <span class="keyword">inline</span> Bsdf_init_func* as_init(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 0].bsdf_init;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Expression functions</span></div>
<div class="line">__device__ <span class="keyword">inline</span> Mat_expr_func* as_expression(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 0].expression;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// BSDF functions</span></div>
<div class="line">__device__ <span class="keyword">inline</span> Bsdf_sample_func* as_bsdf_sample(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 0].bsdf_sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Bsdf_evaluate_func* as_bsdf_evaluate(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 1].bsdf_evaluate;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Bsdf_pdf_func* as_bsdf_pdf(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 2].bsdf_pdf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Bsdf_auxiliary_func* as_bsdf_auxiliary(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 3].bsdf_auxiliary;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// EDF functions</span></div>
<div class="line">__device__ <span class="keyword">inline</span> Edf_sample_func* as_edf_sample(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 0].edf_sample;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Edf_evaluate_func* as_edf_evaluate(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 1].edf_evaluate;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Edf_pdf_func* as_edf_pdf(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 2].edf_pdf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> Edf_auxiliary_func* as_edf_auxiliary(<span class="keyword">const</span> Mdl_function_index&amp; index)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> mdl_functions[index.z + 3].edf_auxiliary;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// 3d vector math utilities</span></div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__bbox.html#gaf040cc4c039ba166c59300683dca980a" title="Returns a bounding box that is the bbox increased by a constant value at each face, i.e., value is added to bbox.max and subtracted from bbox.min. ">operator+</a>(<span class="keyword">const</span> float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(a.x + b.x, a.y + b.y, a.z + b.z);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__base__types.html#gaa99b8610590fe17df980d8587e1af81d" title="Reverses the sign of a three valued enum. ">operator-</a>(<span class="keyword">const</span> float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(a.x - b.x, a.y - b.y, a.z - b.z);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>(<span class="keyword">const</span> float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(a.x * b.x, a.y * b.y, a.z * b.z);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>(<span class="keyword">const</span> float3&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(a.x * s, a.y * s, a.z * s);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__bbox.html#ga27657e606d65aa9dee41e1246542ab5c" title="Returns a bounding box that is a version of bbox divided by divisor, i.e., bbox.max and bbox...">operator/</a>(<span class="keyword">const</span> float3&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(a.x / s, a.y / s, a.z / s);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__mi__math__bbox.html#gab6c52a6ad7178c3edd90c541935bba99" title="Increases bbox by a constant value at each face, i.e., value is added to bbox.max and subtracted from...">operator+=</a>(float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    a.x += b.x; a.y += b.y; a.z += b.z;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__mi__math__bbox.html#gabaa655abffebbdfe94f26a8a581bfa6f" title="Shrinks bbox by a constant value at each face, i.e., value is subtracted from bbox.max and added to bbox.min. ">operator-=</a>(float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    a.x -= b.x; a.y -= b.y; a.z -= b.z;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__mi__math__bbox.html#gae675fcba275db2da836e8a004692d244" title="Scales bbox by factor, i.e., bbox.max and bbox.min are multiplied by factor. ">operator*=</a>(float3&amp; a, <span class="keyword">const</span> float3&amp; b)</div>
<div class="line">{</div>
<div class="line">    a.x *= b.x; a.y *= b.y; a.z *= b.z;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__mi__math__bbox.html#gae675fcba275db2da836e8a004692d244" title="Scales bbox by factor, i.e., bbox.max and bbox.min are multiplied by factor. ">operator*=</a>(float3&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; s)</div>
<div class="line">{</div>
<div class="line">    a.x *= s; a.y *= s; a.z *= s;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">float</span> squared_length(<span class="keyword">const</span> float3 &amp;d)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> d.x * d.x + d.y * d.y + d.z * d.z;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 normalize(<span class="keyword">const</span> float3 &amp;d)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_len = 1.0f / sqrtf(d.x * d.x + d.y * d.y + d.z * d.z);</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(d.x * inv_len, d.y * inv_len, d.z * inv_len);</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">float</span> <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(<span class="keyword">const</span> float3 &amp;u, <span class="keyword">const</span> float3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> u.x * v.x + u.y * v.y + u.z * v.z;</div>
<div class="line">}</div>
<div class="line">__device__ <span class="keyword">inline</span> float3 <a class="code" href="group__mi__math__vector.html#ga2601053c0aee5b7c8eabbd62dcdab77f" title="Returns the two-times-two determinant result for the two vectors lhs and rhs. ">cross</a>(<span class="keyword">const</span> float3 &amp;u, <span class="keyword">const</span> float3 &amp;v)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(</div>
<div class="line">        u.y * v.z - u.z * v.y,</div>
<div class="line">        u.z * v.x - u.x * v.z,</div>
<div class="line">        u.x * v.y - u.y * v.x);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> curandStatePhilox4_32_10_t Rand_state;</div>
<div class="line"></div>
<div class="line"><span class="comment">// direction to environment map texture coordinates</span></div>
<div class="line">__device__ <span class="keyword">inline</span> float2 environment_coords(<span class="keyword">const</span> float3 &amp;dir, <span class="keyword">const</span> Kernel_params&amp; params)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> u = atan2f(dir.z, dir.x) * (float)(0.5 / M_PI) + 0.5f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> v = acosf(fmax(fminf(-dir.y, 1.0f), -1.0f)) * (float)(1.0 / M_PI);</div>
<div class="line">    <span class="keywordflow">return</span> make_float2(fmodf(u + params.env_rotation * 0.5f * M_1_PI, 1.0f), v);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// importance sample the environment</span></div>
<div class="line">__device__ <span class="keyword">inline</span> float3 environment_sample(</div>
<div class="line">    float3 &amp;dir,</div>
<div class="line">    <span class="keywordtype">float</span>  &amp;pdf,</div>
<div class="line">    <span class="keyword">const</span>  float3 &amp;xi,</div>
<div class="line">    <span class="keyword">const</span>  Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// importance sample an envmap pixel using an alias map</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = params.env_size.x * params.env_size.y;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = min((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(xi.x * (<span class="keywordtype">float</span>)size), size - 1);</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> env_idx;</div>
<div class="line">    <span class="keywordtype">float</span> xi_y = xi.y;</div>
<div class="line">    <span class="keywordflow">if</span> (xi_y &lt; params.env_accel[idx].q) {</div>
<div class="line">        env_idx = idx ;</div>
<div class="line">        xi_y /= params.env_accel[idx].q;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        env_idx = params.env_accel[idx].alias;</div>
<div class="line">        xi_y = (xi_y - params.env_accel[idx].q) / (1.0f - params.env_accel[idx].q);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> py = env_idx / params.env_size.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> px = env_idx % params.env_size.x;</div>
<div class="line">    pdf = params.env_accel[env_idx].pdf;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// uniformly sample spherical area of pixel</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> u = (float)(px + xi_y) / (float)params.env_size.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> phi = u * (<span class="keywordtype">float</span>)(2.0 * M_PI) - (<span class="keywordtype">float</span>)M_PI - params.env_rotation;</div>
<div class="line">    <span class="keywordtype">float</span> sin_phi, cos_phi;</div>
<div class="line">    sincosf(phi &gt; <span class="keywordtype">float</span>(-M_PI) ? phi : (phi + (<span class="keywordtype">float</span>)(2.0 * M_PI)), &amp;sin_phi, &amp;cos_phi);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> step_theta = (float)M_PI / (<span class="keywordtype">float</span>)params.env_size.y;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> theta0 = (float)(py) * step_theta;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta = cosf(theta0) * (1.0f - xi.z) + cosf(theta0 + step_theta) * xi.z;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> theta = acosf(cos_theta);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> sin_theta = sinf(theta);</div>
<div class="line">    dir = make_float3(cos_phi * sin_theta, -cos_theta, sin_phi * sin_theta);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// lookup filtered beauty</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> v = theta * (float)(1.0 / M_PI);</div>
<div class="line">    <span class="keyword">const</span> float4 t = tex2D&lt;float4&gt;(params.env_tex, u, v);</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(t.x, t.y, t.z) * params.env_intensity / pdf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// evaluate the environment</span></div>
<div class="line">__device__ <span class="keyword">inline</span> float3 environment_eval(</div>
<div class="line">    <span class="keywordtype">float</span> &amp;pdf,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;dir,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> float2 uv = environment_coords(dir, params);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x =</div>
<div class="line">        min((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(uv.x * (<span class="keywordtype">float</span>)params.env_size.x), params.env_size.x - 1);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y =</div>
<div class="line">        min((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(uv.y * (<span class="keywordtype">float</span>)params.env_size.y), params.env_size.y - 1);</div>
<div class="line"></div>
<div class="line">    pdf = params.env_accel[y * params.env_size.x + x].pdf;</div>
<div class="line">    <span class="keyword">const</span> float4 t = tex2D&lt;float4&gt;(params.env_tex, uv.x, uv.y) ;</div>
<div class="line">    <span class="keywordflow">return</span> make_float3(t.x, t.y, t.z) * params.env_intensity;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>auxiliary_data</div>
<div class="line">{</div>
<div class="line">    float3 albedo;</div>
<div class="line">    float3 normal;</div>
<div class="line">    <span class="keywordtype">int</span> num; <span class="comment">// multiple elements can contribute to the aux buffer with equal weight </span></div>
<div class="line"></div>
<div class="line">    __device__ <span class="keyword">inline</span> auxiliary_data&amp; <a class="code" href="group__mi__math__bbox.html#gab6c52a6ad7178c3edd90c541935bba99" title="Increases bbox by a constant value at each face, i.e., value is added to bbox.max and subtracted from...">operator+=</a>(<span class="keyword">const</span> auxiliary_data&amp; b)</div>
<div class="line">    {</div>
<div class="line">        albedo += b.albedo;</div>
<div class="line">        normal += b.normal;</div>
<div class="line">        num += b.num;</div>
<div class="line">        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">void</span> clear(auxiliary_data&amp; data)</div>
<div class="line">{</div>
<div class="line">    data.albedo = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">    data.normal = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">    data.num = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> normalize(auxiliary_data&amp; data)</div>
<div class="line">{</div>
<div class="line">    data.albedo = data.albedo / fmaxf(1.0f, <span class="keywordtype">float</span>(data.num));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(data.normal, data.normal) &gt; 0.0f)</div>
<div class="line">        data.normal = normalize(data.normal);</div>
<div class="line"></div>
<div class="line">    data.num = min(1, data.num);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Ray_state</div>
<div class="line">{</div>
<div class="line">    float3 contribution;</div>
<div class="line">    float3 weight;</div>
<div class="line">    float3 pos, pos_rx, pos_ry;</div>
<div class="line">    float3 dir, dir_rx, dir_ry;</div>
<div class="line">    <span class="keywordtype">bool</span> inside;</div>
<div class="line">    <span class="keywordtype">bool</span> inside_cutout;</div>
<div class="line">    <span class="keywordtype">int</span> intersection;</div>
<div class="line">    uint32_t lpe_current_state;</div>
<div class="line">    auxiliary_data* aux;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>Ray_hit_info</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">float</span> distance;</div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="group__mi__neuray__mdl__compiler.html#ga485e6f52995285582fc6a4b4be266e4e" title="A float3 with derivatives. ">tct_deriv_float3</a> position;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        float3 position;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>    float3 normal;</div>
<div class="line">    float3 tangent_u;</div>
<div class="line">    float3 tangent_v;</div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="group__mi__neuray__mdl__compiler.html#ga485e6f52995285582fc6a4b4be266e4e" title="A float3 with derivatives. ">tct_deriv_float3</a> texture_coords[1];</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">tct_float3</a> texture_coords[1];</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define GT_SPHERE_RADIUS 1.0f</span></div>
<div class="line"><span class="preprocessor"></span>__device__ <span class="keyword">inline</span> <span class="keywordtype">bool</span> intersect_sphere(</div>
<div class="line">    <span class="keyword">const</span> Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    Ray_hit_info&amp; out_hit)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> r = GT_SPHERE_RADIUS;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> b = 2.0f * <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(ray_state.dir, ray_state.pos);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> c = <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(ray_state.pos, ray_state.pos) - r * r;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> tmp = b * b - 4.0f * c;</div>
<div class="line">    <span class="keywordflow">if</span> (tmp &lt; 0.0f)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    tmp = sqrtf(tmp);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> t0 = (((b &lt; 0.0f) ? -tmp : tmp) - b) * 0.5f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> t1 = c / t0;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> m = fminf(t0, t1);</div>
<div class="line">    out_hit.distance = m &gt; 0.0f ? m : fmaxf(t0, t1);</div>
<div class="line">    <span class="keywordflow">if</span> (out_hit.distance &lt; 0.0f)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute geometry state</span></div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.position.val = ray_state.pos + ray_state.dir * out_hit.distance;</div>
<div class="line">        out_hit.position.dx = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.position.dy = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        <span class="keyword">const</span> float3 &amp;posval = out_hit.position.val;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.position = ray_state.pos + ray_state.dir * out_hit.distance;</div>
<div class="line">        <span class="keyword">const</span> float3 &amp;posval = out_hit.position;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>    out_hit.normal = normalize(posval);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> phi = atan2f(out_hit.normal.x, out_hit.normal.z);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> theta = acosf(out_hit.normal.y);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> float3 uvw = make_float3(</div>
<div class="line">        (phi * (<span class="keywordtype">float</span>) (0.5 / M_PI) + 0.5f) * 2.0f,</div>
<div class="line">        1.0f - theta * (<span class="keywordtype">float</span>) (1.0 / M_PI),</div>
<div class="line">        0.0f);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute surface derivatives</span></div>
<div class="line">    <span class="keywordtype">float</span> sp, cp;</div>
<div class="line">    sincosf(phi, &amp;sp, &amp;cp);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> st = sinf(theta);</div>
<div class="line">    out_hit.tangent_u = make_float3(cp * st, 0.0f, -sp * st) * (float) M_PI * r;</div>
<div class="line">    out_hit.tangent_v = make_float3(sp * out_hit.normal.y, -st, cp * out_hit.normal.y) * (float) (-M_PI) * r;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.texture_coords[0].val = uvw;</div>
<div class="line">        out_hit.texture_coords[0].dx = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.texture_coords[0].dy = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.texture_coords[0] = uvw;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define GT_HAIR_RADIUS 0.35f</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define GT_HAIR_LENGTH 3.0f</span></div>
<div class="line"><span class="preprocessor"></span>__device__ <span class="keyword">inline</span> <span class="keywordtype">bool</span> intersect_hair(</div>
<div class="line">    <span class="keyword">const</span> Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    Ray_hit_info&amp; out_hit)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> r = GT_HAIR_RADIUS;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> a = ray_state.dir.x * ray_state.dir.x + ray_state.dir.z * ray_state.dir.z;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> b = 2.0f * (ray_state.dir.x * ray_state.pos.x + ray_state.dir.z * ray_state.pos.z);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> c = ray_state.pos.x * ray_state.pos.x + ray_state.pos.z * ray_state.pos.z - r * r;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> tmp = b * b - 4.0f * a * c;</div>
<div class="line">    <span class="keywordflow">if</span> (tmp &lt; 0.0f)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    tmp = sqrtf(tmp);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> q = (((b &lt; 0.0f) ? -tmp : tmp) - b) * 0.5f;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> t0 = q / a;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> t1 = c / q;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> m = fminf(t0, t1);</div>
<div class="line">    out_hit.distance = m &gt; 0.0f ? m : fmaxf(t0, t1);</div>
<div class="line">    <span class="keywordflow">if</span> (out_hit.distance &lt; 0.0f)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute geometry state</span></div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.position.val = ray_state.pos + ray_state.dir * out_hit.distance;</div>
<div class="line">        out_hit.position.dx = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.position.dy = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        <span class="keyword">const</span> float3 &amp;posval = out_hit.position.val;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.position = ray_state.pos + ray_state.dir * out_hit.distance;</div>
<div class="line">        <span class="keyword">const</span> float3 &amp;posval = out_hit.position;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span>    out_hit.normal = normalize(make_float3(posval.x, 0.0f, posval.z));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (fabsf(posval.y) &gt; GT_HAIR_LENGTH * 0.5f)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> phi = atan2f(posval.z, posval.x);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> float3 uvw = make_float3(</div>
<div class="line">        (posval.y + GT_HAIR_LENGTH * 0.5f) / GT_HAIR_LENGTH, <span class="comment">// position along the hair</span></div>
<div class="line">        phi * (<span class="keywordtype">float</span>) (0.5f / M_PI) + 0.5f, <span class="comment">// position around the hair in the range [0, 1]</span></div>
<div class="line">        2.0f * GT_HAIR_RADIUS); <span class="comment">// thickness of the hair</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute surface derivatives</span></div>
<div class="line">    out_hit.tangent_u = make_float3(0.0, 1.0, 0.0);</div>
<div class="line">    out_hit.tangent_v = <a class="code" href="group__mi__math__vector.html#ga2601053c0aee5b7c8eabbd62dcdab77f" title="Returns the two-times-two determinant result for the two vectors lhs and rhs. ">cross</a>(out_hit.normal, out_hit.tangent_u);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">    #ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.texture_coords[0].val = uvw;</div>
<div class="line">        out_hit.texture_coords[0].dx = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.texture_coords[0].dy = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.texture_coords[0] = uvw;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">bool</span> intersect_geometry(</div>
<div class="line">    Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    Ray_hit_info&amp; out_hit)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (Geometry_type(params.geometry))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> GT_SPHERE:</div>
<div class="line">            <span class="keywordflow">if</span> (!intersect_sphere(ray_state, params, out_hit))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> GT_HAIR:</div>
<div class="line">            <span class="keywordflow">if</span> (!intersect_hair(ray_state, params, out_hit))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">    #ifndef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>    ray_state.pos = out_hit.position;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>    ray_state.pos = out_hit.position.val;</div>
<div class="line">    <span class="keywordflow">if</span> (params.use_derivatives &amp;&amp; ray_state.intersection == 0)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#ifdef USE_FAKE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        out_hit.position.dx = make_float3(1.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.position.dy = make_float3(0.0f, 1.0f, 0.0f);</div>
<div class="line">        out_hit.texture_coords[0].dx = make_float3(1.0f, 0.0f, 0.0f);</div>
<div class="line">        out_hit.texture_coords[0].dy = make_float3(0.0f, 1.0f, 0.0f);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">// compute ray differential for one-pixel offset rays</span></div>
<div class="line">        <span class="comment">// (&quot;Physically Based Rendering&quot;, 3rd edition, chapter 10.1.1)</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> d = <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(out_hit.normal, ray_state.pos);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tx = (d - <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(out_hit.normal, ray_state.pos_rx)) / <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(out_hit.normal, ray_state.dir_rx);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> ty = (d - <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(out_hit.normal, ray_state.pos_ry)) / <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(out_hit.normal, ray_state.dir_ry);</div>
<div class="line">        ray_state.pos_rx += ray_state.dir_rx * tx;</div>
<div class="line">        ray_state.pos_ry += ray_state.dir_ry * ty;</div>
<div class="line"></div>
<div class="line">        out_hit.position.dx = ray_state.pos_rx - ray_state.pos;</div>
<div class="line">        out_hit.position.dy = ray_state.pos_ry - ray_state.pos;</div>
<div class="line"></div>
<div class="line">        float4 A;</div>
<div class="line">        float2 B_x, B_y;</div>
<div class="line">        <span class="keywordflow">if</span> (fabsf(out_hit.normal.x) &gt; fabsf(out_hit.normal.y) &amp;&amp; fabsf(out_hit.normal.x) &gt; fabsf(out_hit.normal.z))</div>
<div class="line">        {</div>
<div class="line">            B_x = make_float2(</div>
<div class="line">                ray_state.pos_rx.y - ray_state.pos.y,</div>
<div class="line">                ray_state.pos_rx.z - ray_state.pos.z);</div>
<div class="line">            B_y = make_float2(</div>
<div class="line">                ray_state.pos_ry.y - ray_state.pos.y,</div>
<div class="line">                ray_state.pos_ry.z - ray_state.pos.z);</div>
<div class="line">            A = make_float4(</div>
<div class="line">                out_hit.tangent_u.y, out_hit.tangent_u.z, out_hit.tangent_v.y, out_hit.tangent_v.z);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fabsf(out_hit.normal.y) &gt; fabsf(out_hit.normal.z))</div>
<div class="line">        {</div>
<div class="line">            B_x = make_float2(</div>
<div class="line">                ray_state.pos_rx.x - ray_state.pos.x,</div>
<div class="line">                ray_state.pos_rx.z - ray_state.pos.z);</div>
<div class="line">            B_y = make_float2(</div>
<div class="line">                ray_state.pos_ry.x - ray_state.pos.x,</div>
<div class="line">                ray_state.pos_ry.z - ray_state.pos.z);</div>
<div class="line">            A = make_float4(</div>
<div class="line">                out_hit.tangent_u.x, out_hit.tangent_u.z, out_hit.tangent_v.x, out_hit.tangent_v.z);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            B_x = make_float2(</div>
<div class="line">                ray_state.pos_rx.x - ray_state.pos.x,</div>
<div class="line">                ray_state.pos_rx.y - ray_state.pos.y);</div>
<div class="line">            B_y = make_float2(</div>
<div class="line">                ray_state.pos_ry.x - ray_state.pos.x,</div>
<div class="line">                ray_state.pos_ry.y - ray_state.pos.y);</div>
<div class="line">            A = make_float4(</div>
<div class="line">                out_hit.tangent_u.x, out_hit.tangent_u.y, out_hit.tangent_v.x, out_hit.tangent_v.y);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> det = A.x * A.w - A.y * A.z;</div>
<div class="line">        <span class="keywordflow">if</span> (fabsf(det) &gt; 1e-10f)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> inv_det = 1.0f / det;</div>
<div class="line"></div>
<div class="line">            out_hit.texture_coords[0].dx.x = inv_det * (A.w * B_x.x - A.z * B_x.y);</div>
<div class="line">            out_hit.texture_coords[0].dx.y = inv_det * (A.x * B_x.y - A.y * B_x.x);</div>
<div class="line"></div>
<div class="line">            out_hit.texture_coords[0].dy.x = inv_det * (A.w * B_y.x - A.z * B_y.y);</div>
<div class="line">            out_hit.texture_coords[0].dy.y = inv_det * (A.x * B_y.y - A.y * B_y.x);</div>
<div class="line">        }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    out_hit.tangent_u = normalize(out_hit.tangent_u);</div>
<div class="line">    out_hit.tangent_v = normalize(out_hit.tangent_v);</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keywordtype">bool</span> cull_point_light(</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;light_position,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;light_direction <span class="comment">/*to light*/</span>,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;normal)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (params.geometry)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> GT_SPHERE:</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// same as default, but allow lights inside the sphere</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> inside = (squared_length(light_position) &lt; GT_SPHERE_RADIUS) ? -1.f : 1.f;</div>
<div class="line">            <span class="keywordflow">return</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(light_direction, normal) * inside) &lt;= 0.0f;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">case</span> GT_HAIR:</div>
<div class="line">            <span class="comment">// ignore light sources within the volume</span></div>
<div class="line">            <span class="keywordflow">return</span> (light_position.x * light_position.x +</div>
<div class="line">                    light_position.z * light_position.z) &lt; GT_SPHERE_RADIUS;</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="comment">// ignore light from behind</span></div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(light_direction, normal) &lt;= 0.0f;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">__device__ <span class="keywordtype">bool</span> cull_env_light(</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;light_direction <span class="comment">/*to light*/</span>,</div>
<div class="line">    <span class="keyword">const</span> float3 &amp;normal)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (params.geometry)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> GT_HAIR:</div>
<div class="line">            <span class="comment">// allow light from behind</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> GT_SPHERE:</div>
<div class="line">        <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="comment">// ignore light from behind</span></div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(light_direction, normal) &lt;= 0.0f;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keywordtype">void</span> continue_ray(</div>
<div class="line">    Ray_state&amp; ray_state,</div>
<div class="line">    <span class="keyword">const</span> Ray_hit_info &amp;hit_indo,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> event_type,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (params.geometry)</div>
<div class="line">    {</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">case</span> GT_HAIR:</div>
<div class="line">        <span class="keywordflow">if</span> (event_type == BSDF_EVENT_GLOSSY_TRANSMISSION)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// conservative</span></div>
<div class="line">            ray_state.pos += ray_state.dir * 2.0f * GT_HAIR_RADIUS;</div>
<div class="line">            ray_state.inside = <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// events that are define a transition between states, along with tag IDs</span></div>
<div class="line"><span class="keyword">enum</span> Transition_type</div>
<div class="line">{</div>
<div class="line">    TRANSITION_CAMERA = 0,</div>
<div class="line">    TRANSITION_LIGHT,</div>
<div class="line">    TRANSITION_EMISSION,</div>
<div class="line">    TRANSITION_SCATTER_DR,</div>
<div class="line">    TRANSITION_SCATTER_DT,</div>
<div class="line">    TRANSITION_SCATTER_GR,</div>
<div class="line">    TRANSITION_SCATTER_GT,</div>
<div class="line">    TRANSITION_SCATTER_SR,</div>
<div class="line">    TRANSITION_SCATTER_ST,</div>
<div class="line"></div>
<div class="line">    TRANSITION_COUNT,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// go to the next state, given the current state and a transition token.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> uint32_t lpe_transition(</div>
<div class="line">    uint32_t current_state,</div>
<div class="line">    Transition_type event,</div>
<div class="line">    uint32_t global_tag_id,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(current_state == static_cast&lt;uint32_t&gt;(-1))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(-1);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> params.lpe_state_table[</div>
<div class="line">        current_state * params.lpe_num_transitions +</div>
<div class="line">        <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(TRANSITION_COUNT) * global_tag_id +</div>
<div class="line">        static_cast&lt;uint32_t&gt;(event)];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// add direct contribution, e.g., for emission, direct light hits</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> accumulate_contribution(</div>
<div class="line">    Transition_type light_event,</div>
<div class="line">    uint32_t light_global_tag_id,</div>
<div class="line">    <span class="keyword">const</span> float3&amp; contrib,</div>
<div class="line">    Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// check if there is a valid transition to that light source</span></div>
<div class="line">    uint32_t next_state = lpe_transition(</div>
<div class="line">        ray_state.lpe_current_state, light_event, light_global_tag_id, params);</div>
<div class="line">    <span class="keywordflow">if</span> (next_state == static_cast&lt;uint32_t&gt;(-1)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add contribution the when the reached state is a final state for the selected LPE</span></div>
<div class="line">    <span class="comment">// here we only have one LPE buffer, but more can be added easily by checking different LPEs</span></div>
<div class="line">    <span class="keywordflow">if</span> ((params.lpe_final_mask[next_state] &amp; (1 &lt;&lt; params.lpe_ouput_expression)) != 0)</div>
<div class="line">        ray_state.contribution += contrib;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// add contribution for next event estimations</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> accumulate_next_event_contribution(</div>
<div class="line">    Transition_type scatter_event, uint32_t material_global_tag_id,</div>
<div class="line">    Transition_type light_event, uint32_t light_global_tag_id,</div>
<div class="line">    <span class="keyword">const</span> float3&amp; contrib,</div>
<div class="line">    Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// transition following the scatter event</span></div>
<div class="line">    uint32_t next_state = lpe_transition(</div>
<div class="line">        ray_state.lpe_current_state, scatter_event, material_global_tag_id, params);</div>
<div class="line">    <span class="keywordflow">if</span> (next_state == static_cast&lt;uint32_t&gt;(-1)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check if there is a valid transition to the light source</span></div>
<div class="line">    next_state = lpe_transition(</div>
<div class="line">        next_state, light_event, light_global_tag_id, params);</div>
<div class="line">    <span class="keywordflow">if</span> (next_state == static_cast&lt;uint32_t&gt;(-1)) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add contribution the when the reached state is a final state for the selected LPE</span></div>
<div class="line">    <span class="comment">// here we only have one LPE buffer, but more can be added easily by checking different LPEs</span></div>
<div class="line">    <span class="keywordflow">if</span> ((params.lpe_final_mask[next_state] &amp; (1 &lt;&lt; params.lpe_ouput_expression)) != 0)</div>
<div class="line">        ray_state.contribution += contrib;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">bool</span> trace_scene(</div>
<div class="line">    Rand_state &amp;rand_state,</div>
<div class="line">    Ray_state &amp;ray_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// stop at invalid states</span></div>
<div class="line">    <span class="keywordflow">if</span> (ray_state.lpe_current_state == static_cast&lt;uint32_t&gt;(-1))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// intersect with geometry</span></div>
<div class="line">    Ray_hit_info hit;</div>
<div class="line">    <span class="keywordflow">if</span> (!intersect_geometry(ray_state, params, hit)) {</div>
<div class="line">        <span class="keywordflow">if</span> (ray_state.intersection == 0 &amp;&amp; params.mdl_test_type != MDL_TEST_NO_ENV) {</div>
<div class="line">            <span class="comment">// primary ray miss, add environment contribution</span></div>
<div class="line">            <span class="keyword">const</span> float2 uv = environment_coords(ray_state.dir, params);</div>
<div class="line">            <span class="keyword">const</span> float4 texval = tex2D&lt;float4&gt;(params.env_tex, uv.x, uv.y);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// add contribution, if `CL` is a valid path</span></div>
<div class="line">            accumulate_contribution(</div>
<div class="line">                TRANSITION_LIGHT, params.env_gtag <span class="comment">/* light group &#39;env&#39; */</span>,</div>
<div class="line">                make_float3(texval.x, texval.y, texval.z) * params.env_intensity,</div>
<div class="line">                ray_state, params);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    float4 texture_results[16];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// material of the current object</span></div>
<div class="line">    Df_cuda_material material = params.material_buffer[params.current_material];</div>
<div class="line"></div>
<div class="line">    Mdl_function_index func_idx;</div>
<div class="line">    func_idx = get_mdl_function_index(material.init);</div>
<div class="line">    <span class="keywordflow">if</span> (!is_valid(func_idx))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// create state</span></div>
<div class="line">    Mdl_state state = {</div>
<div class="line">        hit.normal,</div>
<div class="line">        hit.normal,</div>
<div class="line">        hit.position,</div>
<div class="line">        0.0f,</div>
<div class="line">        hit.texture_coords,</div>
<div class="line">        &amp;hit.tangent_u,</div>
<div class="line">        &amp;hit.tangent_v,</div>
<div class="line">        texture_results,</div>
<div class="line">        params.tc_data[func_idx.x].ro_data_segment,</div>
<div class="line">        identity,</div>
<div class="line">        identity,</div>
<div class="line">        0,</div>
<div class="line">        1.0f</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// access textures and other resource data</span></div>
<div class="line">    <span class="comment">// expect that the target code index is the same for all functions of a material</span></div>
<div class="line">    Mdl_resource_handler mdl_resources;</div>
<div class="line">    mdl_resources.set_target_code_index(params, func_idx);    <span class="comment">// init resource handler</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* arg_block = get_arg_block(params, func_idx);  <span class="comment">// get material parameters</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// initialize the state</span></div>
<div class="line">    as_init(func_idx)(&amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle cutouts be treating the opacity as chance to hit the surface</span></div>
<div class="line">    <span class="comment">// if we don&#39;t hit it, the ray will continue with the same direction</span></div>
<div class="line">    func_idx = get_mdl_function_index(material.cutout_opacity);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> x_anyhit = curand_uniform(&amp;rand_state);</div>
<div class="line">    <span class="keywordflow">if</span> (is_valid(func_idx))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">float</span> opacity;</div>
<div class="line">        as_expression(func_idx)(&amp;opacity, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line">        <span class="keywordflow">if</span> (x_anyhit &gt; opacity)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// this example does not fully support cutouts</span></div>
<div class="line">            <span class="comment">// a ray that is reflected on the inside is not doing a next event estimation</span></div>
<div class="line">            <span class="comment">// therefore the back-face looks black if seen through a cutout</span></div>
<div class="line">            <span class="comment">// using a second flag `inside_cutout` avoids this, but there is still no</span></div>
<div class="line">            <span class="comment">// shadow test for the next event estimation</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// decrease to see the environment though front and back face cutouts</span></div>
<div class="line">            ray_state.intersection--;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// change the side</span></div>
<div class="line">            ray_state.inside_cutout = !ray_state.inside_cutout;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// avoid self-intersections</span></div>
<div class="line">            ray_state.pos += hit.normal * (ray_state.inside_cutout ? -1.0f : 1.0f) * 0.001f;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// for evaluating parts of the BSDF individually, e.g. for implementing LPEs</span></div>
<div class="line">    <span class="comment">// the MDL SDK provides several options to pass out the BSDF, EDF, and auxiliary data</span></div>
<div class="line"><span class="preprocessor">    #if DF_HANDLE_SLOTS == DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">// application provided memory</span></div>
<div class="line">        <span class="comment">// the data structs will get only a pointer to a buffer, along with size and offset</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> df_eval_slots = 4;       <span class="comment">// number of handles (parts) that can be evaluated</span></div>
<div class="line">                                                <span class="comment">// at once. 4 is an arbitrary choice. However, it</span></div>
<div class="line">                                                <span class="comment">// has to match eval_data.handle_count and</span></div>
<div class="line">                                                <span class="comment">// aux_data.handle_count)</span></div>
<div class="line"></div>
<div class="line">        float3 result_buffer_0[df_eval_slots];  <span class="comment">// used for bsdf_diffuse, edf, and albedo</span></div>
<div class="line">        float3 result_buffer_1[df_eval_slots];  <span class="comment">// used for bsdf_specular and normal</span></div>
<div class="line"><span class="preprocessor">    #elif DF_HANDLE_SLOTS == DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">// handles are ignored, all parts of the BSDF are returned at once without loops (fastest)</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> df_eval_slots = 1;</div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">// eval_data and auxiliary_data have a fixed size array to pass the data. Only an offset</span></div>
<div class="line">        <span class="comment">// is required if there are more handles (parts) than slots.</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> df_eval_slots = DF_HANDLE_SLOTS;</div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// apply volume attenuation after first bounce</span></div>
<div class="line">    <span class="comment">// (assuming uniform absorption coefficient and ignoring scattering coefficient)</span></div>
<div class="line">    <span class="keywordflow">if</span> (ray_state.intersection &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        func_idx = get_mdl_function_index(material.volume_absorption);</div>
<div class="line">        <span class="keywordflow">if</span> (is_valid(func_idx))</div>
<div class="line">        {</div>
<div class="line">            float3 abs_coeff;</div>
<div class="line">            as_expression(func_idx)(&amp;abs_coeff, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">            ray_state.weight.x *= abs_coeff.x &gt; 0.0f ? expf(-abs_coeff.x * hit.distance) : 1.0f;</div>
<div class="line">            ray_state.weight.y *= abs_coeff.y &gt; 0.0f ? expf(-abs_coeff.y * hit.distance) : 1.0f;</div>
<div class="line">            ray_state.weight.z *= abs_coeff.z &gt; 0.0f ? expf(-abs_coeff.z * hit.distance) : 1.0f;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// add emission</span></div>
<div class="line">    func_idx = get_mdl_function_index(material.edf);</div>
<div class="line">    <span class="keywordflow">if</span> (is_valid(func_idx))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// evaluate intensity expression</span></div>
<div class="line">        float3 emission_intensity = make_float3(0.0, 0.0, 0.0);</div>
<div class="line">        Mdl_function_index intensity_func_idx = get_mdl_function_index(material.emission_intensity);</div>
<div class="line">        <span class="keywordflow">if</span> (is_valid(intensity_func_idx))</div>
<div class="line">        {</div>
<div class="line">            as_expression(intensity_func_idx)(</div>
<div class="line">                &amp;emission_intensity, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// evaluate EDF</span></div>
<div class="line">        Edf_evaluate_data&lt;(Df_handle_slot_mode) DF_HANDLE_SLOTS&gt; eval_data;</div>
<div class="line">        eval_data.k1 = make_float3(-ray_state.dir.x, -ray_state.dir.y, -ray_state.dir.z);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">        #if DF_HANDLE_SLOTS == DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span>            eval_data.edf = result_buffer_0;</div>
<div class="line">            eval_data.handle_count = df_eval_slots;</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        <span class="comment">// outer loop in case the are more material tags than slots in the evaluate struct</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> offset = 0;</div>
<div class="line"><span class="preprocessor">        #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="keywordflow">for</span> (; offset &lt; material.edf_mtag_to_gtag_map_size; offset += df_eval_slots)</div>
<div class="line">        {</div>
<div class="line">            eval_data.handle_offset = offset;</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">            <span class="comment">// evaluate the materials EDF</span></div>
<div class="line">            as_edf_evaluate(func_idx)(&amp;eval_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// iterate over all lobes (tags that appear in the df)</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lobe = 0; (lobe &lt; df_eval_slots) &amp;&amp;</div>
<div class="line">                ((offset + lobe) &lt; material.edf_mtag_to_gtag_map_size); ++lobe)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// add emission contribution</span></div>
<div class="line">                accumulate_contribution(</div>
<div class="line">                    TRANSITION_EMISSION, material.edf_mtag_to_gtag_map[offset + lobe],</div>
<div class="line">                    #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                        eval_data.edf * emission_intensity,</div>
<div class="line">                    #<span class="keywordflow">else</span></div>
<div class="line">                        eval_data.edf[lobe] * emission_intensity,</div>
<div class="line">                    #endif</div>
<div class="line">                    ray_state, params);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">        #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>        }</div>
<div class="line"><span class="preprocessor">        #endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    func_idx = get_mdl_function_index(material.bsdf);</div>
<div class="line">    <span class="keywordflow">if</span> (is_valid(func_idx))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// reuse memory for function data</span></div>
<div class="line">        <span class="keyword">union</span></div>
<div class="line">        {</div>
<div class="line">            <a class="code" href="structmi_1_1neuraylib_1_1Bsdf__sample__data.html" title="Input and output structure for BSDF sampling data. ">Bsdf_sample_data</a>                                            sample_data;</div>
<div class="line">            Bsdf_evaluate_data&lt;(Df_handle_slot_mode)DF_HANDLE_SLOTS&gt;    eval_data;</div>
<div class="line">            <a class="code" href="structmi_1_1neuraylib_1_1Bsdf__pdf__data.html" title="Input and output structure for BSDF PDF calculation data. ">Bsdf_pdf_data</a>                                               pdf_data;</div>
<div class="line">            Bsdf_auxiliary_data&lt;(Df_handle_slot_mode)DF_HANDLE_SLOTS&gt;   aux_data;</div>
<div class="line">        };</div>
<div class="line"></div>
<div class="line">        <span class="comment">// for thin_walled materials there is no &#39;inside&#39;</span></div>
<div class="line">        <span class="keywordtype">bool</span> thin_walled = <span class="keyword">false</span>;</div>
<div class="line">        Mdl_function_index thin_walled_func_idx = get_mdl_function_index(material.thin_walled);</div>
<div class="line">        <span class="keywordflow">if</span> (is_valid(thin_walled_func_idx))</div>
<div class="line">            as_expression(thin_walled_func_idx)(</div>
<div class="line">                &amp;thin_walled, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// initialize shared fields</span></div>
<div class="line">        <span class="keywordflow">if</span> (ray_state.inside &amp;&amp; !thin_walled)</div>
<div class="line">        {</div>
<div class="line">            sample_data.ior1.x = BSDF_USE_MATERIAL_IOR;</div>
<div class="line">            sample_data.ior2 = make_float3(1.0f, 1.0f, 1.0f);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            sample_data.ior1 = make_float3(1.0f, 1.0f, 1.0f);</div>
<div class="line">            sample_data.ior2.x = BSDF_USE_MATERIAL_IOR;</div>
<div class="line">        }</div>
<div class="line">        sample_data.k1 = make_float3(-ray_state.dir.x, -ray_state.dir.y, -ray_state.dir.z);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// if requested, fill auxiliary buffers</span></div>
<div class="line">        <span class="keywordflow">if</span> (params.enable_auxiliary_output &amp;&amp; ray_state.intersection == 0)</div>
<div class="line">        {</div>
<div class="line"><span class="preprocessor">            #if DF_HANDLE_SLOTS == DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span>                aux_data.albedo = result_buffer_0;</div>
<div class="line">                aux_data.normal = result_buffer_1;</div>
<div class="line">                aux_data.handle_count = df_eval_slots;</div>
<div class="line"><span class="preprocessor">            #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">            <span class="comment">// outer loop in case the are more material tags than slots in the evaluate struct</span></div>
<div class="line">            <span class="keywordtype">unsigned</span> offset = 0;</div>
<div class="line"><span class="preprocessor">            #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>            <span class="keywordflow">for</span> (; offset &lt; material.bsdf_mtag_to_gtag_map_size; offset += df_eval_slots)</div>
<div class="line">            {</div>
<div class="line">                aux_data.handle_offset = offset;</div>
<div class="line"><span class="preprocessor">            #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">                <span class="comment">// evaluate the materials auxiliary</span></div>
<div class="line">                as_bsdf_auxiliary(func_idx)(&amp;aux_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// iterate over all lobes (tags that appear in the df)</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lobe = 0; (lobe &lt; df_eval_slots) &amp;&amp;</div>
<div class="line">                    ((offset + lobe) &lt; material.bsdf_mtag_to_gtag_map_size); ++lobe)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// to keep it simpler, the individual albedo and normals are averaged</span></div>
<div class="line">                    <span class="comment">// however, the parts can also be used separately, e.g. for LPEs</span></div>
<div class="line"><span class="preprocessor">                    #if DF_HANDLE_SLOTS == DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>                        ray_state.aux-&gt;albedo += aux_data.albedo;</div>
<div class="line">                        ray_state.aux-&gt;normal += aux_data.normal;</div>
<div class="line"><span class="preprocessor">                    #else</span></div>
<div class="line"><span class="preprocessor"></span>                        ray_state.aux-&gt;albedo += aux_data.albedo[lobe];</div>
<div class="line">                        ray_state.aux-&gt;normal += aux_data.normal[lobe];</div>
<div class="line"><span class="preprocessor">                    #endif</span></div>
<div class="line"><span class="preprocessor"></span>                    ray_state.aux-&gt;num++;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">            #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>            }</div>
<div class="line"><span class="preprocessor">            #endif</span></div>
<div class="line"><span class="preprocessor"></span>        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// compute direct lighting for point light</span></div>
<div class="line">        Transition_type transition_glossy, transition_diffuse;</div>
<div class="line">        <span class="keywordflow">if</span> (params.light_intensity &gt; 0.0f)</div>
<div class="line">        {</div>
<div class="line">            float3 to_light = params.light_pos - ray_state.pos;</div>
<div class="line">            <span class="keywordflow">if</span>(!cull_point_light(params, params.light_pos, to_light, hit.normal))</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> inv_squared_dist = 1.0f / squared_length(to_light);</div>
<div class="line">                <span class="keyword">const</span> float3 f = params.light_color * params.light_intensity *</div>
<div class="line">                                 inv_squared_dist * (float) (0.25 / M_PI);</div>
<div class="line"></div>
<div class="line">                eval_data.k2 = to_light * sqrtf(inv_squared_dist);</div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS == DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span>                    eval_data.bsdf_diffuse = result_buffer_0;</div>
<div class="line">                    eval_data.bsdf_glossy = result_buffer_1;</div>
<div class="line">                    eval_data.handle_count = df_eval_slots;</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">                <span class="comment">// outer loop in case the are more material tags than slots in the evaluate struct</span></div>
<div class="line">                <span class="keywordtype">unsigned</span> offset = 0;</div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>                <span class="keywordflow">for</span> (; offset &lt; material.bsdf_mtag_to_gtag_map_size; offset += df_eval_slots)</div>
<div class="line">                {</div>
<div class="line">                    eval_data.handle_offset = offset;</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">                    <span class="comment">// evaluate the materials BSDF</span></div>
<div class="line">                    as_bsdf_evaluate(func_idx)(</div>
<div class="line">                        &amp;eval_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// we know if we reflect or transmit</span></div>
<div class="line">                    <span class="keywordflow">if</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(to_light, hit.normal) &gt; 0.0f) {</div>
<div class="line">                        transition_glossy = TRANSITION_SCATTER_GR;</div>
<div class="line">                        transition_diffuse = TRANSITION_SCATTER_DR;</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        transition_glossy = TRANSITION_SCATTER_GT;</div>
<div class="line">                        transition_diffuse = TRANSITION_SCATTER_DT;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// sample weight</span></div>
<div class="line">                    <span class="keyword">const</span> float3 w = ray_state.weight * f;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// iterate over all lobes (tags that appear in the df)</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lobe = 0; (lobe &lt; df_eval_slots) &amp;&amp;</div>
<div class="line">                         ((offset + lobe) &lt; material.bsdf_mtag_to_gtag_map_size); ++lobe)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// get the `global tag` of the lobe</span></div>
<div class="line">                        <span class="keywordtype">unsigned</span> material_lobe_gtag = material.bsdf_mtag_to_gtag_map[offset + lobe];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// add diffuse contribution</span></div>
<div class="line">                        accumulate_next_event_contribution(</div>
<div class="line">                            transition_diffuse, material_lobe_gtag,</div>
<div class="line">                            TRANSITION_LIGHT, params.point_light_gtag, <span class="comment">// light group</span></div>
<div class="line">                            #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                                eval_data.bsdf_diffuse * w,</div>
<div class="line">                            #<span class="keywordflow">else</span></div>
<div class="line">                                eval_data.bsdf_diffuse[lobe] * w,</div>
<div class="line">                            #endif</div>
<div class="line">                            ray_state, params);</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// add glossy contribution</span></div>
<div class="line">                        accumulate_next_event_contribution(</div>
<div class="line">                            transition_glossy, material_lobe_gtag,</div>
<div class="line">                            TRANSITION_LIGHT, params.point_light_gtag, <span class="comment">// light group</span></div>
<div class="line">                            #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                                eval_data.bsdf_glossy * w,</div>
<div class="line">                            #<span class="keywordflow">else</span></div>
<div class="line">                                eval_data.bsdf_glossy[lobe] * w,</div>
<div class="line">                            #endif</div>
<div class="line">                            ray_state, params);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>                }</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span>            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// importance sample environment light</span></div>
<div class="line">        <span class="keywordflow">if</span> (params.mdl_test_type != MDL_TEST_SAMPLE &amp;&amp; params.mdl_test_type != MDL_TEST_NO_ENV)</div>
<div class="line">        {</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> xi0 = curand_uniform(&amp;rand_state);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> xi1 = curand_uniform(&amp;rand_state);</div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> xi2 = curand_uniform(&amp;rand_state);</div>
<div class="line"></div>
<div class="line">            float3 light_dir;</div>
<div class="line">            <span class="keywordtype">float</span> pdf;</div>
<div class="line">            <span class="keyword">const</span> float3 f = environment_sample(light_dir, pdf, make_float3(xi0, xi1, xi2), params);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (!cull_env_light(params, light_dir, hit.normal) &amp;&amp; pdf &gt; 0.0f)</div>
<div class="line">            {</div>
<div class="line">                eval_data.k2 = light_dir;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS == DF_HSM_POINTER</span></div>
<div class="line"><span class="preprocessor"></span>                    eval_data.bsdf_diffuse = result_buffer_0;</div>
<div class="line">                    eval_data.bsdf_glossy = result_buffer_1;</div>
<div class="line">                    eval_data.handle_count = df_eval_slots;</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">                <span class="comment">// outer loop in case the are more material tags than slots in the evaluate struct</span></div>
<div class="line">                <span class="keywordtype">unsigned</span> offset = 0;</div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>                <span class="keywordflow">for</span> (; offset &lt; material.bsdf_mtag_to_gtag_map_size; offset += df_eval_slots)</div>
<div class="line">                {</div>
<div class="line">                    eval_data.handle_offset = offset;</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">                    <span class="comment">// evaluate the materials BSDF</span></div>
<div class="line">                    as_bsdf_evaluate(func_idx)(</div>
<div class="line">                        &amp;eval_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">float</span> mis_weight =</div>
<div class="line">                        (params.mdl_test_type == MDL_TEST_EVAL) ? 1.0f : pdf / (pdf + eval_data.pdf);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// we know if we reflect or transmit</span></div>
<div class="line">                    <span class="keywordflow">if</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(light_dir, hit.normal) &gt; 0.0f) {</div>
<div class="line">                        transition_glossy = TRANSITION_SCATTER_GR;</div>
<div class="line">                        transition_diffuse = TRANSITION_SCATTER_DR;</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        transition_glossy = TRANSITION_SCATTER_GT;</div>
<div class="line">                        transition_diffuse = TRANSITION_SCATTER_DT;</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// sample weight</span></div>
<div class="line">                    <span class="keyword">const</span> float3 w = ray_state.weight * f * mis_weight;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// iterate over all lobes (tags that appear in the df)</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> lobe = 0; (lobe &lt; df_eval_slots) &amp;&amp;</div>
<div class="line">                        ((offset + lobe) &lt; material.bsdf_mtag_to_gtag_map_size); ++lobe)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// get the `global tag` of the lobe</span></div>
<div class="line">                        <span class="keywordtype">unsigned</span> material_lobe_gtag = material.bsdf_mtag_to_gtag_map[offset + lobe];</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// add diffuse contribution</span></div>
<div class="line">                        accumulate_next_event_contribution(</div>
<div class="line">                            transition_diffuse, material_lobe_gtag,</div>
<div class="line">                            TRANSITION_LIGHT, params.env_gtag, <span class="comment">// light group &#39;env&#39;</span></div>
<div class="line">                            #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                                (eval_data.bsdf - eval_data.bsdf_glossy) * w,</div>
<div class="line">                            #<span class="keywordflow">else</span></div>
<div class="line">                                eval_data.bsdf_diffuse[lobe] * w,</div>
<div class="line">                            #endif</div>
<div class="line">                            ray_state, params);</div>
<div class="line"></div>
<div class="line">                        <span class="comment">// add glossy contribution</span></div>
<div class="line">                        accumulate_next_event_contribution(</div>
<div class="line">                            transition_glossy, material_lobe_gtag,</div>
<div class="line">                            TRANSITION_LIGHT, params.env_gtag, <span class="comment">// light group &#39;env&#39;</span></div>
<div class="line">                            #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                                eval_data.bsdf_glossy * w,</div>
<div class="line">                            #<span class="keywordflow">else</span></div>
<div class="line">                                eval_data.bsdf_glossy[lobe] * w,</div>
<div class="line">                            #endif</div>
<div class="line">                            ray_state, params);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">                #if DF_HANDLE_SLOTS != DF_HSM_NONE</span></div>
<div class="line"><span class="preprocessor"></span>                }</div>
<div class="line"><span class="preprocessor">                #endif</span></div>
<div class="line"><span class="preprocessor"></span>            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// importance sample BSDF</span></div>
<div class="line">        {</div>
<div class="line">            sample_data.xi.x = curand_uniform(&amp;rand_state);</div>
<div class="line">            sample_data.xi.y = curand_uniform(&amp;rand_state);</div>
<div class="line">            sample_data.xi.z = curand_uniform(&amp;rand_state);</div>
<div class="line">            sample_data.xi.w = curand_uniform(&amp;rand_state);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="comment">// sample the materials BSDF</span></div>
<div class="line">            as_bsdf_sample(func_idx)(&amp;sample_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (sample_data.event_type == BSDF_EVENT_ABSORB)</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">            ray_state.dir = sample_data.k2;</div>
<div class="line">            ray_state.weight *= sample_data.bsdf_over_pdf;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> transmission = (sample_data.event_type &amp; BSDF_EVENT_TRANSMISSION) != 0;</div>
<div class="line">            <span class="keywordflow">if</span> (transmission)</div>
<div class="line">                ray_state.inside = !ray_state.inside;</div>
<div class="line"></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">bool</span> is_specular = (sample_data.event_type &amp; BSDF_EVENT_SPECULAR) != 0;</div>
<div class="line"></div>
<div class="line">            Transition_type next;</div>
<div class="line">            <span class="keywordflow">if</span> (is_specular)</div>
<div class="line">                next = transmission ? TRANSITION_SCATTER_ST : TRANSITION_SCATTER_SR;</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((sample_data.event_type &amp; BSDF_EVENT_DIFFUSE) != 0)</div>
<div class="line">                next = transmission ? TRANSITION_SCATTER_DT : TRANSITION_SCATTER_DR;</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                next = transmission ? TRANSITION_SCATTER_GT : TRANSITION_SCATTER_GR;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// move ray to the next sampled state</span></div>
<div class="line">            ray_state.lpe_current_state = lpe_transition(</div>
<div class="line">                ray_state.lpe_current_state, next,</div>
<div class="line">                #<span class="keywordflow">if</span> DF_HANDLE_SLOTS == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggad0920be275d080f3b387b45a987409a5a983e0d34c7747b2c919dab9d3fe746f7" title="No slots, handles are ignored completely. ">DF_HSM_NONE</a></div>
<div class="line">                    <span class="comment">// ill-defined case: the LPE machine expects tags but the renderer ignores them</span></div>
<div class="line">                    <span class="comment">// -&gt; the resulting image of LPEs with tags is undefined in this case</span></div>
<div class="line">                    params.default_gtag,</div>
<div class="line">                #<span class="keywordflow">else</span></div>
<div class="line">                    material.bsdf_mtag_to_gtag_map[sample_data.handle], <span class="comment">// sampled lobe</span></div>
<div class="line">                #endif</div>
<div class="line">                params);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// depending on the geometry, the ray might be displaced before continuing</span></div>
<div class="line">            continue_ray(ray_state, hit, sample_data.event_type, params);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (ray_state.inside)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// avoid self-intersections</span></div>
<div class="line">                ray_state.pos -= hit.normal * 0.001f;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// continue bouncing in sphere</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (params.mdl_test_type != MDL_TEST_NO_ENV &amp;&amp;</div>
<div class="line">                params.mdl_test_type != MDL_TEST_EVAL)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// leaving sphere, add contribution from environment hit</span></div>
<div class="line"></div>
<div class="line">                <span class="keywordtype">float</span> pdf;</div>
<div class="line">                <span class="keyword">const</span> float3 f = environment_eval(pdf, sample_data.k2, params);</div>
<div class="line"></div>
<div class="line">                <span class="keywordtype">float</span> bsdf_pdf;</div>
<div class="line">                <span class="keywordflow">if</span> (params.mdl_test_type == MDL_TEST_MIS_PDF)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> float3 k2 = sample_data.k2;</div>
<div class="line">                    pdf_data.k2 = k2;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// get pdf corresponding to the materials BSDF</span></div>
<div class="line">                    as_bsdf_pdf(func_idx)(&amp;pdf_data, &amp;state, &amp;mdl_resources.data, NULL, arg_block);</div>
<div class="line"></div>
<div class="line">                    bsdf_pdf = pdf_data.pdf;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    bsdf_pdf = sample_data.pdf;</div>
<div class="line"></div>
<div class="line">                <span class="keywordflow">if</span> (is_specular || bsdf_pdf &gt; 0.0f)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">float</span> mis_weight = is_specular ||</div>
<div class="line">                        (params.mdl_test_type == MDL_TEST_SAMPLE) ? 1.0f :</div>
<div class="line">                            bsdf_pdf / (pdf + bsdf_pdf);</div>
<div class="line"></div>
<div class="line">                    float3 specular_contrib = ray_state.weight * f * mis_weight;</div>
<div class="line">                    accumulate_contribution(</div>
<div class="line">                        TRANSITION_LIGHT, params.env_gtag <span class="comment">/* light group &#39;env&#39; */</span>,</div>
<div class="line">                        specular_contrib,</div>
<div class="line">                        ray_state, params);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>render_result</div>
<div class="line">{</div>
<div class="line">    float3 beauty;</div>
<div class="line">    auxiliary_data aux;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> render_result render_scene(</div>
<div class="line">    Rand_state &amp;rand_state,</div>
<div class="line">    <span class="keyword">const</span> Kernel_params &amp;params,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> x,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> y)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_res_x = 1.0f / (float)params.resolution.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> inv_res_y = 1.0f / (<span class="keywordtype">float</span>)params.resolution.y;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dx = params.disable_aa ? 0.5f : curand_uniform(&amp;rand_state);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> dy = params.disable_aa ? 0.5f : curand_uniform(&amp;rand_state);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> float2 screen_pos = make_float2(</div>
<div class="line">        ((<span class="keywordtype">float</span>)x + dx) * inv_res_x,</div>
<div class="line">        ((<span class="keywordtype">float</span>)y + dy) * inv_res_y);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> r    = (2.0f * screen_pos.x               - 1.0f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> r_rx = (2.0f * (screen_pos.x + inv_res_x) - 1.0f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> u    = (2.0f * screen_pos.y               - 1.0f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> u_ry = (2.0f * (screen_pos.y + inv_res_y) - 1.0f);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> aspect = (float)params.resolution.y / (<span class="keywordtype">float</span>)params.resolution.x;</div>
<div class="line"></div>
<div class="line">    render_result res;</div>
<div class="line">    clear(res.aux);</div>
<div class="line"></div>
<div class="line">    Ray_state ray_state;</div>
<div class="line">    ray_state.contribution = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">    ray_state.weight = make_float3(1.0f, 1.0f, 1.0f);</div>
<div class="line">    ray_state.pos = ray_state.pos_rx = ray_state.pos_ry = params.cam_pos;</div>
<div class="line">    ray_state.dir = normalize(</div>
<div class="line">        params.cam_dir * params.cam_focal + params.cam_right * r    + params.cam_up * aspect * u);</div>
<div class="line">    ray_state.dir_rx = normalize(</div>
<div class="line">        params.cam_dir * params.cam_focal + params.cam_right * r_rx + params.cam_up * aspect * u);</div>
<div class="line">    ray_state.dir_ry = normalize(</div>
<div class="line">        params.cam_dir * params.cam_focal + params.cam_right * r    + params.cam_up * aspect * u_ry);</div>
<div class="line">    ray_state.inside = <span class="keyword">false</span>;</div>
<div class="line">    ray_state.inside_cutout = <span class="keyword">false</span>;</div>
<div class="line">    ray_state.lpe_current_state = 1; <span class="comment">// already at the camera so state 0 to 1 is free as long as</span></div>
<div class="line">                                     <span class="comment">// there is only one camera</span></div>
<div class="line">    ray_state.aux = &amp;res.aux;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_inters = params.max_path_length - 1;</div>
<div class="line">    <span class="keywordflow">for</span> (ray_state.intersection = 0; ray_state.intersection &lt; max_inters; ++ray_state.intersection)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (!trace_scene(rand_state, ray_state, params))</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    res.beauty =</div>
<div class="line">        <a class="code" href="group__mi__math__color.html#ga5d8868383c0ce561196ba1227202dbc9" title="Indicates whether all components of the color are finite. ">isfinite</a>(ray_state.contribution.x) &amp;&amp;</div>
<div class="line">        <a class="code" href="group__mi__math__color.html#ga5d8868383c0ce561196ba1227202dbc9" title="Indicates whether all components of the color are finite. ">isfinite</a>(ray_state.contribution.y) &amp;&amp;</div>
<div class="line">        <a class="code" href="group__mi__math__color.html#ga5d8868383c0ce561196ba1227202dbc9" title="Indicates whether all components of the color are finite. ">isfinite</a>(ray_state.contribution.z) ? ray_state.contribution : make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">    normalize(res.aux);</div>
<div class="line">    <span class="keywordflow">return</span> res;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// quantize + gamma</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> float3_to_rgba8(float3 val)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> r = (<span class="keywordtype">unsigned</span> int) (255.0 * powf(<a class="code" href="group__mi__math__color.html#ga898b52f365e9fbed319b9e46c0cd701b" title="Returns the color c clamped elementwise to the range [0,1]. ">saturate</a>(val.x), 1.0f / 2.2f));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> g = (<span class="keywordtype">unsigned</span> int) (255.0 * powf(<a class="code" href="group__mi__math__color.html#ga898b52f365e9fbed319b9e46c0cd701b" title="Returns the color c clamped elementwise to the range [0,1]. ">saturate</a>(val.y), 1.0f / 2.2f));</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = (<span class="keywordtype">unsigned</span> int) (255.0 * powf(<a class="code" href="group__mi__math__color.html#ga898b52f365e9fbed319b9e46c0cd701b" title="Returns the color c clamped elementwise to the range [0,1]. ">saturate</a>(val.z), 1.0f / 2.2f));</div>
<div class="line">    <span class="keywordflow">return</span> 0xff000000 | (b &lt;&lt; 16) | (g &lt;&lt; 8) | r;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// exposure + simple Reinhard tonemapper + gamma</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> display(float3 val, <span class="keyword">const</span> <span class="keywordtype">float</span> tonemap_scale)</div>
<div class="line">{</div>
<div class="line">    val *= tonemap_scale;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> burn_out = 0.1f;</div>
<div class="line">    val.x *= (1.0f + val.x * burn_out) / (1.0f + val.x);</div>
<div class="line">    val.y *= (1.0f + val.y * burn_out) / (1.0f + val.y);</div>
<div class="line">    val.z *= (1.0f + val.z * burn_out) / (1.0f + val.z);</div>
<div class="line">    <span class="keywordflow">return</span> float3_to_rgba8(val);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// CUDA kernel rendering simple geometry with IBL</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __global__ <span class="keywordtype">void</span> render_scene_kernel(</div>
<div class="line">    <span class="keyword">const</span> Kernel_params kernel_params)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</div>
<div class="line">    <span class="keywordflow">if</span> (x &gt;= kernel_params.resolution.x || y &gt;= kernel_params.resolution.y)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = y * kernel_params.resolution.x + x;</div>
<div class="line">    Rand_state rand_state;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_dim = kernel_params.disable_aa ? 6 : 8; <span class="comment">// 2 camera, 3 BSDF, 3 environment</span></div>
<div class="line">    curand_init(idx, <span class="comment">/*subsequence=*/</span>0, kernel_params.iteration_start * num_dim, &amp;rand_state);</div>
<div class="line"></div>
<div class="line">    render_result res;</div>
<div class="line">    float3 beauty = make_float3(0.0f, 0.0f, 0.0f);</div>
<div class="line">    auxiliary_data aux;</div>
<div class="line">    clear(aux);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s &lt; kernel_params.iteration_num; ++s)</div>
<div class="line">    {</div>
<div class="line">        res = render_scene(</div>
<div class="line">            rand_state,</div>
<div class="line">            kernel_params,</div>
<div class="line">            x, y);</div>
<div class="line"></div>
<div class="line">        beauty += res.beauty;</div>
<div class="line">        aux += res.aux;</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line">    beauty *= 1.0f / (float)kernel_params.iteration_num;</div>
<div class="line">    normalize(aux);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// accumulate</span></div>
<div class="line">    <span class="keywordflow">if</span> (kernel_params.iteration_start == 0) {</div>
<div class="line">        kernel_params.accum_buffer[idx] = beauty;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (kernel_params.enable_auxiliary_output) {</div>
<div class="line">            kernel_params.albedo_buffer[idx] = aux.albedo;</div>
<div class="line">            kernel_params.normal_buffer[idx] = aux.normal;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordtype">float</span> iteration_weight = (float) kernel_params.iteration_num /</div>
<div class="line">            (<span class="keywordtype">float</span>) (kernel_params.iteration_start + kernel_params.iteration_num);</div>
<div class="line"></div>
<div class="line">        float3 buffer_val = kernel_params.accum_buffer[idx] +</div>
<div class="line">            (beauty - kernel_params.accum_buffer[idx]) * iteration_weight;</div>
<div class="line"></div>
<div class="line">        kernel_params.accum_buffer[idx] =</div>
<div class="line">            (isinf(buffer_val.x) || <a class="code" href="group__mi__math__color.html#gada9c25a0b7142264b13038303887c71d" title="Indicates whether any component of the color is &quot;not a number&quot;. ">isnan</a>(buffer_val.y) || isinf(buffer_val.z) ||</div>
<div class="line">             <a class="code" href="group__mi__math__color.html#gada9c25a0b7142264b13038303887c71d" title="Indicates whether any component of the color is &quot;not a number&quot;. ">isnan</a>(buffer_val.x) || isinf(buffer_val.y) || <a class="code" href="group__mi__math__color.html#gada9c25a0b7142264b13038303887c71d" title="Indicates whether any component of the color is &quot;not a number&quot;. ">isnan</a>(buffer_val.z))</div>
<div class="line">                ? make_float3(0.0f, 0.0f, 1.0e+30f)</div>
<div class="line">                : buffer_val;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (kernel_params.enable_auxiliary_output) {</div>
<div class="line"></div>
<div class="line">            <span class="comment">// albedo</span></div>
<div class="line">            kernel_params.albedo_buffer[idx] = kernel_params.albedo_buffer[idx] +</div>
<div class="line">                (aux.albedo - kernel_params.albedo_buffer[idx]) * iteration_weight;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// normal, check for zero length first</span></div>
<div class="line">            float3 weighted_normal = kernel_params.normal_buffer[idx] +</div>
<div class="line">                (aux.normal - kernel_params.normal_buffer[idx]) * iteration_weight;</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(weighted_normal, weighted_normal) &gt; 0.0f)</div>
<div class="line">                weighted_normal = normalize(weighted_normal);</div>
<div class="line">            kernel_params.normal_buffer[idx] = weighted_normal;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// update display buffer</span></div>
<div class="line">    <span class="keywordflow">if</span> (kernel_params.display_buffer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">switch</span> (kernel_params.enable_auxiliary_output ? kernel_params.display_buffer_index : 0)</div>
<div class="line">        {</div>
<div class="line">        <span class="keywordflow">case</span> 1: <span class="comment">/* albedo */</span></div>
<div class="line">            kernel_params.display_buffer[idx] = float3_to_rgba8(kernel_params.albedo_buffer[idx]);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">case</span> 2: <span class="comment">/* normal */</span></div>
<div class="line">        {</div>
<div class="line">            float3 display_normal = kernel_params.normal_buffer[idx];</div>
<div class="line">            <span class="keywordflow">if</span> (<a class="code" href="group__mi__math__function.html#ga407d21f3ae47abb81a502ecd23b905b8" title="Returns the inner product (a.k.a. dot or scalar product) of two integers. ">dot</a>(display_normal, display_normal) &gt; 0) {</div>
<div class="line">                display_normal.x = display_normal.x * 0.5f + 0.5f;</div>
<div class="line">                display_normal.y = display_normal.y * 0.5f + 0.5f;</div>
<div class="line">                display_normal.z = display_normal.z * 0.5f + 0.5f;</div>
<div class="line">            }</div>
<div class="line">            kernel_params.display_buffer[idx] = float3_to_rgba8(display_normal);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">default</span>: <span class="comment">/* beauty */</span></div>
<div class="line">            kernel_params.display_buffer[idx] =</div>
<div class="line">                display(kernel_params.accum_buffer[idx], kernel_params.exposure_scale);</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --><div align="right"> [<a class="el" href="mi_neuray_example_execution_glsl.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_df_native.html">Next</a>] </div> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
