<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Example for Execution of Compiled MDL Materials (GLSL)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mi_neuray_example_execution_glsl.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Example for Execution of Compiled MDL Materials (GLSL) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="right"> [<a class="el" href="mi_neuray_example_execution_ptx.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_df_cuda.html">Next</a>] </div><p>This example describes the API of the code generated by the "GLSL" backend for compiled materials and shows how a renderer can call this generated code to evaluate sub-expressions of multiple materials using OpenGL.</p>
<h1><a class="anchor" id="example_execution_glsl_new"></a>
New Topics</h1>
<ul>
<li>MDL material state (GLSL)</li>
<li>Execution of generated code (GLSL)</li>
<li>Constant data (GLSL)</li>
<li>Loading textures (GLSL)</li>
<li>Texture access functions (GLSL)</li>
</ul>
<h1><a class="anchor" id="example_execution_glsl_descr"></a>
Detailed Description</h1>
<dl>
<dt><b>MDL material state (GLSL)</b> </dt>
<dd><p class="startdd"><br/>
 The MDL material state is a representation of the renderer state as defined in section 19 "Renderer state" in the MDL specification. It is used to make the state of the renderer (like the position of an intersection point on the surface, the shading normal and the texture coordinates) available to the generated code.</p>
<p>With the GLSL backend, you can define the MDL material state in a pretty flexible way: For each supported state member you can specify whether you want to implement it as a field in the <code>"State"</code> structure (<code>"field"</code> mode), as an input variable of the fragment shader (<code>"arg"</code> mode), as a function (<code>"func"</code> mode), or as constant zero (<code>"zero"</code> mode). Please refer to the documentation of <a class="el" href="group__mi__neuray__mdl__compiler.html#ga1301dec05ba862ca7745814367811f15" title="Sets a backend option. ">mi::neuraylib::IMdl_backend::set_option()</a> on how to set these modes via the <code>"glsl_state_*"</code> options.</p>
<p>The code snippet below shows how the <code>"State"</code> structure would look like, if all state options were set to <code>"field"</code> mode and <code>"num_textures_spaces"</code> was set to 1.</p>
<div class="fragment"><div class="line"><span class="comment">// The MDL material state structure used by the MDL SDK when all state accessor functions</span></div>
<div class="line"><span class="comment">// are set to &quot;field&quot; mode and &quot;num_texture_spaces&quot; is set to 1.</span></div>
<div class="line"><span class="keyword">struct </span>State {</div>
<div class="line">    vec3    normal;                      <span class="comment">// state::normal() result</span></div>
<div class="line">    vec3    geometry_normal;             <span class="comment">// state::geom_normal() result</span></div>
<div class="line">    vec3    position;                    <span class="comment">// state::position() result</span></div>
<div class="line">    <span class="keywordtype">float</span>   animation_time;              <span class="comment">// state::animation_time() result</span></div>
<div class="line">    vec3    motion;                      <span class="comment">// state::motion() result</span></div>
<div class="line">    <span class="keywordtype">int</span>     texture_space_max;           <span class="comment">// state::texture_space_max() result</span></div>
<div class="line">    vec3[1] texture_coordinate;          <span class="comment">// state::texture_coordinate() table</span></div>
<div class="line">    vec3[1] texture_tangent_u;           <span class="comment">// state::texture_tangent_u() table</span></div>
<div class="line">    vec3[1] texture_tangent_v;           <span class="comment">// state::texture_tangent_v() table</span></div>
<div class="line">    vec3[1] geometry_tangent_u;          <span class="comment">// state::texture_geometry_tangent_u() table</span></div>
<div class="line">    vec3[1] geometry_tangent_v;          <span class="comment">// state::texture_geometry_tangent_v() table</span></div>
<div class="line">    <span class="keywordtype">int</span>     object_id;                   <span class="comment">// state::object_id() result</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>If all state options were set to <code>"arg"</code> mode and <code>"num_textures_spaces"</code> was set to 1, the <code>"state"</code> input variables would look like this:</p>
<div class="fragment"><div class="line">in vec3    normal;                       <span class="comment">// state::normal() result</span></div>
<div class="line">in vec3    geometry_normal;              <span class="comment">// state::geom_normal() result</span></div>
<div class="line">in vec3    position;                     <span class="comment">// state::position() result</span></div>
<div class="line">in <span class="keywordtype">float</span>   animation_time;               <span class="comment">// state::animation_time() result</span></div>
<div class="line">in vec3    motion;                       <span class="comment">// state::motion() result</span></div>
<div class="line">in <span class="keywordtype">int</span>     texture_space_max;            <span class="comment">// state::texture_space_max() result</span></div>
<div class="line">in vec3[1] texture_coordinate;           <span class="comment">// state::texture_coordinate() table</span></div>
<div class="line">in vec3[1] texture_tangent_u;            <span class="comment">// state::texture_tangent_u() table</span></div>
<div class="line">in vec3[1] texture_tangent_v;            <span class="comment">// state::texture_tangent_v() table</span></div>
<div class="line">in vec3[1] geometry_tangent_u;           <span class="comment">// state::texture_geometry_tangent_u() table</span></div>
<div class="line">in vec3[1] geometry_tangent_v;           <span class="comment">// state::texture_geometry_tangent_v() table</span></div>
<div class="line">in <span class="keywordtype">int</span>     object_id;                    <span class="comment">// state::object_id() result</span></div>
</div><!-- fragment --><p>If all state options were set to <code>"func"</code> mode and <code>"num_textures_spaces"</code> was set to 1, the <code>"state"</code> function prototypes would look like this:</p>
<div class="fragment"><div class="line">vec3    normal(<span class="keywordtype">void</span>);                    <span class="comment">// state::normal() implementation</span></div>
<div class="line">vec3    geometry_normal(<span class="keywordtype">void</span>);           <span class="comment">// state::geom_normal() implementation</span></div>
<div class="line">vec3    position(<span class="keywordtype">void</span>);                  <span class="comment">// state::position() implementation</span></div>
<div class="line"><span class="keywordtype">float</span>   animation_time(<span class="keywordtype">void</span>);            <span class="comment">// state::animation_time() implementation</span></div>
<div class="line">vec3    motion(<span class="keywordtype">void</span>);                    <span class="comment">// state::motion() implementation</span></div>
<div class="line"><span class="keywordtype">int</span>     texture_space_max(<span class="keywordtype">void</span>);         <span class="comment">// state::texture_space_max() implementation</span></div>
<div class="line">vec3[1] texture_coordinate(<span class="keywordtype">int</span> index);   <span class="comment">// state::texture_coordinate() implementation</span></div>
<div class="line">vec3[1] texture_tangent_u(<span class="keywordtype">int</span> index);    <span class="comment">// state::texture_tangent_u() implementation</span></div>
<div class="line">vec3[1] texture_tangent_v(<span class="keywordtype">int</span> index);    <span class="comment">// state::texture_tangent_v() implementation</span></div>
<div class="line">vec3[1] geometry_tangent_u(<span class="keywordtype">int</span> index);   <span class="comment">// state::texture_geometry_tangent_u() implementation</span></div>
<div class="line">vec3[1] geometry_tangent_v(<span class="keywordtype">int</span> index);   <span class="comment">// state::texture_geometry_tangent_v() implementation</span></div>
<div class="line"><span class="keywordtype">int</span>     object_id(<span class="keywordtype">void</span>);                 <span class="comment">// state::object_id() implementation</span></div>
</div><!-- fragment --><p>Please refer to the documentation of the <a class="el" href="group__mi__neuray__mdl__compiler.html#ga8a42cb80b6772ce4b266f2311b0561c1" title="The MDL material state structure. ">mi::neuraylib::Shading_state_material</a> structure or the MDL specification for more information about the MDL material state.</p>
<dl class="section note"><dt>Note</dt><dd>The world-to-object and object-to-world matrices can currently not be set for the GLSL backend if a link unit (see below) is used. Thus they will default to the identity matrix.</dd></dl>
<p>In this example, we fill the material state structure with some example values and only use one texture space. For <code>state::position()</code> we will use <code>"func"</code> mode with a function which will mirror the position received from the vertex shader across the center. For <code>state::texture_coordinate(int)</code> we will use <code>"arg"</code> mode to use the texture coordinates from the vertex shader directly. For the normals, animation time and the texture tangents we will use <code>"field"</code> mode to make them part of the <code>"State"</code> structure (for the normals, this is the default mode). We will animate the materials by updating the animation_time with every frame.</p>
<p>The scene consists of a 2x2 quad around the center of the world with position <code>x</code> and <code>y</code> coordinates ranging from -1 to 1 and the texture uv-coordinates ranging from 0 to 1, respectively. </p>
<p class="enddd"></p>
</dd>
<dt><b>Execution of generated code (GLSL)</b> </dt>
<dd><p class="startdd"><br/>
 For the non-native backends, the generated code has to be called directly from the corresponding framework, so we need to know the prototypes of the functions generated by the backend via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga965f9701d653a059364c011762266c96" title="Transforms an expression that is part of an MDL material instance to target code. ...">mi::neuraylib::IMdl_backend::translate_material_expression()</a>. With <code>"NAME"</code> being the function name you provided as <code>fname</code> parameter and <code>"T"</code> being the result type, they simply look like this:</p>
<div class="fragment"><div class="line">T NAME(State state);</div>
</div><!-- fragment --><p>If you need multiple sub-expressions per GLSL program, you should create an <a class="el" href="classmi_1_1neuraylib_1_1ILink__unit.html" title="Represents a link-unit of an MDL backend. ">mi::neuraylib::ILink_unit</a> via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga2a47cff09fe1b7ac157f32b168fa93d2" title="Creates a new link unit. ">mi::neuraylib::IMdl_backend::create_link_unit()</a> to prevent the backend from generating illegal duplicate functions and globals. With the link unit, you can then add material subexpressions or environment functions by calling <a class="el" href="group__mi__neuray__mdl__compiler.html#ga4b4ea31354b2eb720814d3bbb4841ac2" title="Add an expression that is part of an MDL material instance as a function to this link unit...">mi::neuraylib::ILink_unit::add_material_expression()</a> and <a class="el" href="group__mi__neuray__mdl__compiler.html#gaca63ab90c774d8a4e4e71d239d3c43c8" title="Add an MDL environment function call as a function to this link unit. ">mi::neuraylib::ILink_unit::add_environment()</a>, respectively. Finally, you can create the GLSL target code with <a class="el" href="group__mi__neuray__mdl__compiler.html#gab2db03209c55985f122e47977364d8cf" title="Transforms a link unit to target code. ">mi::neuraylib::IMdl_backend::translate_link_unit()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>You may not change the backend options between the creation and the destruction of a link unit due to the way the option values are currently stored.</dd></dl>
<p>To make the generated functions available by index in the GLSL fragment shader, we generate a switch function <code>"mdl_mat_subexpr()"</code> which calls the function corresponding to the given index (see <code>"generate_glsl_switch_func()"</code>).</p>
<p>In this example, we render multiple materials onto the quad with a user-configurable checkerboard pattern by drawing the triangles of the quad with OpenGL and letting the fragment shader call our generated switch function with a material index and an MDL material state. </p>
<p class="enddd"></p>
</dd>
<dt><b>Constant data (GLSL)</b> </dt>
<dd><p class="startdd"><br/>
 By default, the GLSL backend creates one uniform per constant data object larger than 1024 bytes. Each uniform has to be filled by the renderer via the correct <code>glUniform*</code> functions with the data provided by <a class="el" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">mi::neuraylib::ITarget_code::get_ro_data_segment_data()</a>.</p>
<p>The amount of constant data you can provide within the GLSL code is very limited. If your GLSL code or the code generated by the GLSL backend uses to much constant data, you may get errors about too many registers being used or invalid instructions in the resulting ARB assembly code. While it is possible to force constant data to be placed in uniforms only, the amount of data is still very limited and often already causes problems with 5 kB of data scattered over multiple uniforms.</p>
<p>To avoid these problems, it is highly recommended to enable using Shader Storage Buffer Objects (SSBO) for the generated code by setting the backend option <code>"glsl_place_uniforms_into_ssbo"</code> to <code>"on"</code>. There, the main limitation is usually only the available GPU memory.</p>
<dl class="section note"><dt>Note</dt><dd>SSBOs are not available on Mac OS X up to at least version 10.9.</dd></dl>
<p>Additionally we recommend to set <code>"glsl_max_const_data"</code> to zero or a very low value to avoid running into above problems when you already use some constant data in your own code.</p>
<p>When SSBOs are enabled, the GLSL backend will place the data of all uniforms into one SSBO. You can access the data for the SSBO via <a class="el" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">mi::neuraylib::ITarget_code::get_ro_data_segment_data()</a>. In this example, the generated SSBO will look like this:</p>
<div class="fragment"><div class="line">layout(std430) buffer mdl_buffer_0 {</div>
<div class="line">    <span class="keywordtype">float</span>[16] mdl_field_1;</div>
<div class="line">    <span class="keywordtype">int</span>[256] mdl_field_2;</div>
<div class="line">    <span class="keywordtype">int</span>[256] mdl_field_3;</div>
<div class="line">    <span class="keywordtype">int</span>[256] mdl_field_4;</div>
<div class="line">    <span class="keywordtype">int</span>[256] mdl_field_5;</div>
<div class="line">    <span class="keywordtype">int</span>[256] mdl_field_6;</div>
<div class="line">    vec4[128] mdl_field_7;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Please refer to the <code>"Material_opengl_context::set_mdl_readonly_data()"</code> method on how to set the uniform data or the SSBO data in OpenGL.</p>
<p></p>
<p class="enddd"></p>
</dd>
<dt><b>Loading textures (GLSL)</b> </dt>
<dd><p class="startdd"><br/>
 When the <code>nv_freeimage</code> plugin has been loaded via <a class="el" href="classmi_1_1neuraylib_1_1IPlugin__configuration.html#aa8660748a128a9bb925c831dbbf05a0b" title="Loads a plugin library. ">mi::neuraylib::IPlugin_configuration::load_plugin_library()</a> before starting the MDL SDK, the SDK will automatically load textures on the host side for many common image formats and make them available via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">mi::neuraylib::ITarget_code::get_texture()</a>. Note, that the first texture is always the invalid texture, so only if there is more than just one texture according to <a class="el" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">mi::neuraylib::ITarget_code::get_texture_count()</a>, there will be real referenced textures available.</p>
<p>Here's a small code snippet showing how to access the <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> of the texture at index <code>i</code>. </p>
<div class="fragment"><div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITexture&gt;</a> texture(</div>
<div class="line">    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(i)));</div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IImage&gt;</a> image(</div>
<div class="line">    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(texture-&gt;get_image()));</div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas());</div>
</div><!-- fragment --><p>The textures still have to be copied to the GPU and possibly they have to be gamma corrected and converted to a format understood by the texture access functions you provide. In this example, we use the <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a> to apply the gamma correction and to convert the image format to a float32 RGBA format.</p>
<p>The textures are then made available via OpenGL 2D texture samplers.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, the GLSL backend only supports 2D textures. </dd></dl>
</dd>
<dt><b>Texture access functions (GLSL)</b> </dt>
<dd><p class="startdd"><br/>
 For the GLSL backend, the generated code currently expects two texture access functions to be provided by the fragment shader:</p>
<div class="fragment"><div class="line">vec4 tex_lookup_2d(uint tex, vec2 coord, <span class="keywordtype">int</span> wrap_u, <span class="keywordtype">int</span> wrap_v, vec2 crop_u, vec2 crop_v);</div>
<div class="line">vec4 tex_texel_2d(uint tex, ivec2 coord);</div>
</div><!-- fragment --><p>These correspond directly to the functions described in section 20.3 "Standard library functions - Texture" in the MDL specification.</p>
<p>The <code>"tex"</code> parameter represents the texture index as used by <a class="el" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">mi::neuraylib::ITarget_code::get_texture()</a>.</p>
<p class="enddd">The <code>tex_lookup_2d()</code> function receives floating-point texture coordinates and should return a sampled value, whereas <code>tex_texel_2d()</code> receives integer texture coordinates and should return a raw texture value.  </p>
</dd>
</dl>
<h1><a class="anchor" id="example_execution_glsl"></a>
Example Source</h1>
<p>To compile the source code, you need GLEW available at <a href="http://glew.sourceforge.net/">http://glew.sourceforge.net/</a> and GLFW available at <a href="http://www.glfw.org/download.html">http://www.glfw.org/download.html</a>. Please refer to the <a class="el" href="mi_neuray_getting_started.html">Getting Started </a> section for details.</p>
<p><b>Source Code Location:</b> <code>examples/mdl_sdk/execution_glsl/example_execution_glsl.cpp</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/execution_glsl/example_execution_glsl.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Introduces the execution of generated code for compiled materials for</span></div>
<div class="line"><span class="comment">// the GLSL backend and shows how to manually bake a material</span></div>
<div class="line"><span class="comment">// sub-expression to a texture.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;example_shared.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;example_glsl_shared.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;GL/glew.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This selects SSBO (Shader Storage Buffer Objects) mode for passing uniforms and MDL const data.</span></div>
<div class="line"><span class="comment">// Should not be disabled unless you only use materials with very small const data.</span></div>
<div class="line"><span class="comment">// In this example, this would only apply to execution_material_2, because the others are using</span></div>
<div class="line"><span class="comment">// lookup tables for noise functions.</span></div>
<div class="line"><span class="preprocessor">#if defined(MI_PLATFORM_MACOSX) || defined(MI_ARCH_ARM_64)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define MAX_MATERIALS 16</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define MAX_TEXTURES 16</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define MAX_MATERIALS 64</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define MAX_TEXTURES 32</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// If defined, the GLSL backend will remap these functions</span></div>
<div class="line"><span class="comment">//   float ::base::perlin_noise(float4 pos)</span></div>
<div class="line"><span class="comment">//   float ::base::mi_noise(float3 pos)</span></div>
<div class="line"><span class="comment">//   float ::base::mi_noise(int3 pos)</span></div>
<div class="line"><span class="comment">//   ::base::worley_return ::base::worley_noise(float3 pos, float jitter, int metric)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// to lut-free alternatives. When enabled, you can avoid to set the USE_SSBO define for this</span></div>
<div class="line"><span class="comment">// example.</span></div>
<div class="line"><span class="preprocessor">#define REMAP_NOISE_FUNCTIONS</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Enable this to dump the generated GLSL code to stdout.</span></div>
<div class="line"><span class="comment">//#define DUMP_GLSL</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* vertex_shader_filename   = <span class="stringliteral">&quot;example_execution_glsl.vert&quot;</span>;</div>
<div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* fragment_shader_filename = <span class="stringliteral">&quot;example_execution_glsl.frag&quot;</span>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Command line options structure.</span></div>
<div class="line"><span class="keyword">struct </span>Options {</div>
<div class="line">    <span class="comment">// If true, no interactive display will be used.</span></div>
<div class="line">    <span class="keywordtype">bool</span> no_window;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// An result output file name for non-interactive mode.</span></div>
<div class="line">    std::string outputfile;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The pattern number representing the combination of materials to display.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> material_pattern;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The resolution of the display / image.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> res_x, res_y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The constructor.</span></div>
<div class="line">    Options()</div>
<div class="line">        : no_window(false)</div>
<div class="line">        , outputfile(<span class="stringliteral">&quot;output.png&quot;</span>)</div>
<div class="line">        , material_pattern(7)</div>
<div class="line">        , res_x(1024)</div>
<div class="line">        , res_y(768)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Struct representing a vertex of a scene object.</span></div>
<div class="line"><span class="keyword">struct </span>Vertex {</div>
<div class="line">    <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">mi::Float32_3_struct</a> position;</div>
<div class="line">    <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">mi::Float32_2_struct</a> tex_coord;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// OpenGL code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Initialize OpenGL and create a window with an associated OpenGL context.</span></div>
<div class="line"><span class="keyword">static</span> GLFWwindow *init_opengl(Options <span class="keyword">const</span> &amp;options)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize GLFW</span></div>
<div class="line">    check_success(glfwInit());</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// SSBO requires GLSL 4.30</span></div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);</div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// else GLSL 3.30 is sufficient</span></div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);</div>
<div class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</div>
<div class="line">    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Hide window in no-window mode</span></div>
<div class="line">    <span class="keywordflow">if</span> (options.no_window)</div>
<div class="line">        glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create an OpenGL window and a context</span></div>
<div class="line">    GLFWwindow *window = glfwCreateWindow(</div>
<div class="line">        options.res_x, options.res_y,</div>
<div class="line">        <span class="stringliteral">&quot;MDL SDK GLSL Execution Example - Switch pattern with keys 1 - 7&quot;</span>, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (!window) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error creating OpenGL window!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        terminate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Attach context to window</span></div>
<div class="line">    glfwMakeContextCurrent(window);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Initialize GLEW to get OpenGL extensions</span></div>
<div class="line">    GLenum res = glewInit();</div>
<div class="line">    <span class="keywordflow">if</span> (res != GLEW_OK) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;GLEW error: &quot;</span> &lt;&lt; glewGetErrorString(res) &lt;&lt; std::endl;</div>
<div class="line">        terminate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Enable VSync</span></div>
<div class="line">    glfwSwapInterval(1);</div>
<div class="line"></div>
<div class="line">    check_gl_success();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> window;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate GLSL source code for a function executing an MDL subexpression function</span></div>
<div class="line"><span class="comment">// selected by a given id.</span></div>
<div class="line"><span class="keyword">static</span> std::string generate_glsl_switch_func(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a>&amp; target_code)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Note: The &quot;State&quot; struct must be in sync with the struct in example_execution_glsl.frag and</span></div>
<div class="line">    <span class="comment">//       the code generated by the MDL SDK (see dumped code when enabling DUMP_GLSL).</span></div>
<div class="line"></div>
<div class="line">    std::string src =</div>
<div class="line">        <span class="stringliteral">&quot;#version 330 core\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;struct State {\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    vec3 normal;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    vec3 geometry_normal;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    float animation_time;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    vec3[1] texture_tangent_u;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    vec3[1] texture_tangent_v;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;};\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;uint get_mdl_num_mat_subexprs() { return &quot;</span> +</div>
<div class="line">        to_string(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5002e9d426ebb8abd844b418541d9870" title="Returns the number of callable functions in the target code. ">get_callable_function_count</a>()) +</div>
<div class="line">        <span class="stringliteral">&quot;u; }\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::string switch_func =</div>
<div class="line">        <span class="stringliteral">&quot;vec3 mdl_mat_subexpr(uint id, State state) {\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    switch(id) {\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create one switch case for each callable function in the target code</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, num_target_codes = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5002e9d426ebb8abd844b418541d9870" title="Returns the number of callable functions in the target code. ">get_callable_function_count</a>();</div>
<div class="line">          i &lt; num_target_codes;</div>
<div class="line">          ++i)</div>
<div class="line">    {</div>
<div class="line">        std::string func_name(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gab23aae54fc513ea49c271ea09287ad7e" title="Returns the name of a callable function in the target code. ">get_callable_function</a>(i));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add prototype declaration</span></div>
<div class="line">        src += target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga67096668a1a25617564ecd8687023fe6" title="Returns the prototype of a callable function in the target code. ">get_callable_function_prototype</a>(</div>
<div class="line">            i, mi::neuraylib::ITarget_code::SL_GLSL);</div>
<div class="line">        src += <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"></div>
<div class="line">        switch_func += <span class="stringliteral">&quot;        case &quot;</span> + to_string(i) + <span class="stringliteral">&quot;u: return &quot;</span> + func_name + <span class="stringliteral">&quot;(state);\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    switch_func +=</div>
<div class="line">        <span class="stringliteral">&quot;        default: return vec3(0);\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;    }\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> src + <span class="stringliteral">&quot;\n&quot;</span> + switch_func;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create the shader program with a fragment shader.</span></div>
<div class="line"><span class="keyword">static</span> GLuint create_shader_program(</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a>&amp; target_code)</div>
<div class="line">{</div>
<div class="line">    GLint success;</div>
<div class="line"></div>
<div class="line">    GLuint program = glCreateProgram();</div>
<div class="line"></div>
<div class="line">    add_shader(GL_VERTEX_SHADER,</div>
<div class="line">        read_text_file(</div>
<div class="line">            mi::examples::io::get_executable_folder() + <span class="stringliteral">&quot;/&quot;</span> + vertex_shader_filename), program);</div>
<div class="line"></div>
<div class="line">    std::stringstream sstr;</div>
<div class="line">    sstr &lt;&lt; <span class="stringliteral">&quot;#version 330 core\n&quot;</span>;</div>
<div class="line">    sstr &lt;&lt; <span class="stringliteral">&quot;#define MAX_MATERIALS &quot;</span> &lt;&lt; to_string(MAX_MATERIALS) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    sstr &lt;&lt; <span class="stringliteral">&quot;#define MAX_TEXTURES &quot;</span> &lt;&lt; to_string(MAX_TEXTURES) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    sstr &lt;&lt; read_text_file(</div>
<div class="line">        mi::examples::io::get_executable_folder() + <span class="stringliteral">&quot;/&quot;</span> + fragment_shader_filename);</div>
<div class="line">    add_shader(GL_FRAGMENT_SHADER, sstr.str() , program);</div>
<div class="line"></div>
<div class="line">    std::string code(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga4d570269ba116dde0bbb517d97323d90" title="Returns the represented target code in ASCII representation. ">get_code</a>());</div>
<div class="line"><span class="preprocessor">#ifdef REMAP_NOISE_FUNCTIONS</span></div>
<div class="line"><span class="preprocessor"></span>    code.append(read_text_file(</div>
<div class="line">        mi::examples::io::get_executable_folder() + <span class="stringliteral">&quot;/&quot;</span> + <span class="stringliteral">&quot;noise_no_lut.glsl&quot;</span>));</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    add_shader(GL_FRAGMENT_SHADER, code, program);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generate GLSL switch function for the generated functions</span></div>
<div class="line">    std::string glsl_switch_func = generate_glsl_switch_func(target_code);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_GLSL</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping GLSL code for the \&quot;mdl_mat_subexpr\&quot; switch function:\n\n&quot;</span></div>
<div class="line">        &lt;&lt; glsl_switch_func &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    add_shader(GL_FRAGMENT_SHADER, glsl_switch_func.c_str(), program);</div>
<div class="line"></div>
<div class="line">    glLinkProgram(program);</div>
<div class="line">    glGetProgramiv(program, GL_LINK_STATUS, &amp;success);</div>
<div class="line">    <span class="keywordflow">if</span> (!success) {</div>
<div class="line">        dump_program_info(program, <span class="stringliteral">&quot;Error linking the shader program: &quot;</span>);</div>
<div class="line">        terminate();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    glUseProgram(program);</div>
<div class="line">    check_gl_success();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> program;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a quad filling the whole screen.</span></div>
<div class="line"><span class="keyword">static</span> GLuint create_quad(GLuint program, GLuint* vertex_buffer)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> Vertex <span class="keyword">const</span> vertices[6] = {</div>
<div class="line">        { { -1.f, -1.f, 0.0f }, { 0.f, 0.f } },</div>
<div class="line">        { {  1.f, -1.f, 0.0f }, { 1.f, 0.f } },</div>
<div class="line">        { { -1.f,  1.f, 0.0f }, { 0.f, 1.f } },</div>
<div class="line">        { {  1.f, -1.f, 0.0f }, { 1.f, 0.f } },</div>
<div class="line">        { {  1.f,  1.f, 0.0f }, { 1.f, 1.f } },</div>
<div class="line">        { { -1.f,  1.f, 0.0f }, { 0.f, 1.f } }</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    glGenBuffers(1, vertex_buffer);</div>
<div class="line">    glBindBuffer(GL_ARRAY_BUFFER, *vertex_buffer);</div>
<div class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</div>
<div class="line"></div>
<div class="line">    GLuint vertex_array;</div>
<div class="line">    glGenVertexArrays(1, &amp;vertex_array);</div>
<div class="line">    glBindVertexArray(vertex_array);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get locations of vertex shader inputs</span></div>
<div class="line">    GLint   pos_index              = glGetAttribLocation(program, <span class="stringliteral">&quot;Position&quot;</span>);</div>
<div class="line">    GLint   tex_coord_index        = glGetAttribLocation(program, <span class="stringliteral">&quot;TexCoord&quot;</span>);</div>
<div class="line">    check_success(pos_index &gt;= 0 &amp;&amp; tex_coord_index &gt;= 0);</div>
<div class="line"></div>
<div class="line">    glEnableVertexAttribArray(pos_index);</div>
<div class="line">    glVertexAttribPointer(</div>
<div class="line">        pos_index, 3, GL_FLOAT, GL_FALSE, <span class="keyword">sizeof</span>(Vertex), 0);</div>
<div class="line"></div>
<div class="line">    glEnableVertexAttribArray(tex_coord_index);</div>
<div class="line">    glVertexAttribPointer(</div>
<div class="line">        tex_coord_index, 2, GL_FLOAT, GL_FALSE,</div>
<div class="line">        <span class="keyword">sizeof</span>(Vertex), reinterpret_cast&lt;const GLvoid*&gt;(<span class="keyword">sizeof</span>(<a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">mi::Float32_3_struct</a>)));</div>
<div class="line"></div>
<div class="line">    check_gl_success();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> vertex_array;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Material_opengl_context class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper class responsible for making textures and read-only data available to OpenGL</span></div>
<div class="line"><span class="comment">// by generating and managing a list of Material_data objects.</span></div>
<div class="line"><span class="keyword">class </span>Material_opengl_context</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Material_opengl_context(GLuint program)</div>
<div class="line">    : m_program(program)</div>
<div class="line">    , m_next_storage_block_binding(0)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Free all acquired resources.</span></div>
<div class="line">    ~Material_opengl_context();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the needed material data of the given target code.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_material_data(</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>         image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Sets all collected material data in the OpenGL program.</span></div>
<div class="line">    <span class="keywordtype">bool</span> set_material_data();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Sets the read-only data segments in the current OpenGL program object.</span></div>
<div class="line">    <span class="keywordtype">void</span> set_mdl_readonly_data(<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line">    <span class="comment">// in the OpenGL program.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_texture(</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>         image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                                            texture_index,</div>
<div class="line">        GLuint                                              texture_array);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// The OpenGL program to prepare.</span></div>
<div class="line">    GLuint m_program;</div>
<div class="line"></div>
<div class="line">    std::vector&lt;GLuint&gt; m_texture_objects;</div>
<div class="line"></div>
<div class="line">    std::vector&lt;unsigned int&gt; m_material_texture_starts;</div>
<div class="line"></div>
<div class="line">    std::vector&lt;GLuint&gt; m_buffer_objects;</div>
<div class="line">    GLuint m_next_storage_block_binding;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Free all acquired resources.</span></div>
<div class="line">Material_opengl_context::~Material_opengl_context()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (m_buffer_objects.size() &gt; 0)</div>
<div class="line">        glDeleteBuffers(GLsizei(m_buffer_objects.size()), &amp;m_buffer_objects[0]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (m_texture_objects.size() &gt; 0)</div>
<div class="line">        glDeleteTextures(GLsizei(m_texture_objects.size()), &amp;m_texture_objects[0]);</div>
<div class="line"></div>
<div class="line">    check_gl_success();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sets the read-only data segments in the current OpenGL program object.</span></div>
<div class="line"><span class="keywordtype">void</span> Material_opengl_context::set_mdl_readonly_data(</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_uniforms = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga2463c3e18318a828aaca780d42d1ae93" title="Returns the number of constant data initializers. ">get_ro_data_segment_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_uniforms == 0) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordtype">size_t</span> cur_buffer_offs = m_buffer_objects.size();</div>
<div class="line">    m_buffer_objects.insert(m_buffer_objects.end(), num_uniforms, 0);</div>
<div class="line"></div>
<div class="line">    glGenBuffers(GLsizei(num_uniforms), &amp;m_buffer_objects[cur_buffer_offs]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0; i &lt; num_uniforms; ++i) {</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> segment_size = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga34a679f235fb3a81a9ffdff8205929d1" title="Returns the size of the constant data segment at the given index. ">get_ro_data_segment_size</a>(i);</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span>* segment_data = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">get_ro_data_segment_data</a>(i);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_GLSL</span></div>
<div class="line"><span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Dump ro segment data &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; \&quot;&quot;</span></div>
<div class="line">            &lt;&lt; target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1a80b172c6c5f2d5a8642fea41f826d9" title="Returns the name of the constant data segment at the given index. ">get_ro_data_segment_name</a>(i) &lt;&lt; <span class="stringliteral">&quot;\&quot; (size = &quot;</span></div>
<div class="line">            &lt;&lt; segment_size &lt;&lt; <span class="stringliteral">&quot;):\n&quot;</span> &lt;&lt; std::hex;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 16 &amp;&amp; j &lt; segment_size; ++j) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; (<span class="keywordtype">unsigned</span> int)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)segment_data[j] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::dec &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_buffer_objects[cur_buffer_offs + i]);</div>
<div class="line">        glBufferData(</div>
<div class="line">            GL_SHADER_STORAGE_BUFFER, GLsizeiptr(segment_size), segment_data, GL_STATIC_DRAW);</div>
<div class="line"></div>
<div class="line">        GLuint block_index = glGetProgramResourceIndex(</div>
<div class="line">            m_program, GL_SHADER_STORAGE_BLOCK, target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1a80b172c6c5f2d5a8642fea41f826d9" title="Returns the name of the constant data segment at the given index. ">get_ro_data_segment_name</a>(i));</div>
<div class="line">        glShaderStorageBlockBinding(m_program, block_index, m_next_storage_block_binding);</div>
<div class="line">        glBindBufferBase(</div>
<div class="line">            GL_SHADER_STORAGE_BUFFER,</div>
<div class="line">            m_next_storage_block_binding,</div>
<div class="line">            m_buffer_objects[cur_buffer_offs + i]);</div>
<div class="line"></div>
<div class="line">        ++m_next_storage_block_binding;</div>
<div class="line"></div>
<div class="line">        check_gl_success();</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    std::vector&lt;char const*&gt; uniform_names;</div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0; i &lt; num_uniforms; ++i) {</div>
<div class="line"><span class="preprocessor">#ifdef DUMP_GLSL</span></div>
<div class="line"><span class="preprocessor"></span>        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> segment_size = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga34a679f235fb3a81a9ffdff8205929d1" title="Returns the size of the constant data segment at the given index. ">get_ro_data_segment_size</a>(i);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* segment_data = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">get_ro_data_segment_data</a>(i);</div>
<div class="line"></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Dump ro segment data &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot; \&quot;&quot;</span></div>
<div class="line">            &lt;&lt; target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1a80b172c6c5f2d5a8642fea41f826d9" title="Returns the name of the constant data segment at the given index. ">get_ro_data_segment_name</a>(i) &lt;&lt; <span class="stringliteral">&quot;\&quot; (size = &quot;</span></div>
<div class="line">            &lt;&lt; segment_size &lt;&lt; <span class="stringliteral">&quot;):\n&quot;</span> &lt;&lt; std::hex;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16 &amp;&amp; i &lt; segment_size; ++i) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;0x&quot;</span> &lt;&lt; (<span class="keywordtype">unsigned</span> int)(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)segment_data[i] &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; std::dec &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        uniform_names.push_back(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1a80b172c6c5f2d5a8642fea41f826d9" title="Returns the name of the constant data segment at the given index. ">get_ro_data_segment_name</a>(i));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt;GLuint&gt; uniform_indices(num_uniforms, 0);</div>
<div class="line">    glGetUniformIndices(m_program, GLsizei(num_uniforms), &amp;uniform_names[0], &amp;uniform_indices[0]);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0; i &lt; num_uniforms; ++i) {</div>
<div class="line">        <span class="comment">// uniforms may have been removed, if they were not used</span></div>
<div class="line">        <span class="keywordflow">if</span> (uniform_indices[i] == GL_INVALID_INDEX)</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">        GLint uniform_type = 0;</div>
<div class="line">        GLuint index = GLuint(uniform_indices[i]);</div>
<div class="line">        glGetActiveUniformsiv(m_program, 1, &amp;index, GL_UNIFORM_TYPE, &amp;uniform_type);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_GLSL</span></div>
<div class="line"><span class="preprocessor"></span>        std::cout &lt;&lt; <span class="stringliteral">&quot;Uniform type of &quot;</span> &lt;&lt; uniform_names[i]</div>
<div class="line">            &lt;&lt; <span class="stringliteral">&quot;: 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; uniform_type &lt;&lt; std::dec &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> segment_size = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga34a679f235fb3a81a9ffdff8205929d1" title="Returns the size of the constant data segment at the given index. ">get_ro_data_segment_size</a>(i);</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* segment_data = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">get_ro_data_segment_data</a>(i);</div>
<div class="line"></div>
<div class="line">        GLint uniform_location = glGetUniformLocation(m_program, uniform_names[i]);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">switch</span> (uniform_type) {</div>
<div class="line"></div>
<div class="line"><span class="comment">// For bool, the data has to be converted to int, first</span></div>
<div class="line"><span class="preprocessor">#define CASE_TYPE_BOOL(type, func, num)                            \</span></div>
<div class="line"><span class="preprocessor">    case type: {                                                   \</span></div>
<div class="line"><span class="preprocessor">        GLint *buf = new GLint[segment_size];                      \</span></div>
<div class="line"><span class="preprocessor">        for (mi::Size j = 0; j &lt; segment_size; ++j)               \</span></div>
<div class="line"><span class="preprocessor">            buf[j] = GLint(segment_data[j]);                       \</span></div>
<div class="line"><span class="preprocessor">        func(uniform_location, GLsizei(segment_size / num), buf);  \</span></div>
<div class="line"><span class="preprocessor">        delete[] buf;                                              \</span></div>
<div class="line"><span class="preprocessor">        break;                                                     \</span></div>
<div class="line"><span class="preprocessor">    }</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">            CASE_TYPE_BOOL(GL_BOOL,      glUniform1iv, 1)</div>
<div class="line">            CASE_TYPE_BOOL(GL_BOOL_VEC2, glUniform2iv, 2)</div>
<div class="line">            CASE_TYPE_BOOL(GL_BOOL_VEC3, glUniform3iv, 3)</div>
<div class="line">            CASE_TYPE_BOOL(GL_BOOL_VEC4, glUniform4iv, 4)</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define CASE_TYPE(type, func, num, elemtype)                                      \</span></div>
<div class="line"><span class="preprocessor">    case type:                                                                    \</span></div>
<div class="line"><span class="preprocessor">        func(uniform_location, GLsizei(segment_size/(num * sizeof(elemtype))), \</span></div>
<div class="line"><span class="preprocessor">            (const elemtype*)segment_data);                                       \</span></div>
<div class="line"><span class="preprocessor">        break</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">            CASE_TYPE(GL_INT,             glUniform1iv, 1, GLint);</div>
<div class="line">            CASE_TYPE(GL_INT_VEC2,        glUniform2iv, 2, GLint);</div>
<div class="line">            CASE_TYPE(GL_INT_VEC3,        glUniform3iv, 3, GLint);</div>
<div class="line">            CASE_TYPE(GL_INT_VEC4,        glUniform4iv, 4, GLint);</div>
<div class="line">            CASE_TYPE(GL_FLOAT,           glUniform1fv, 1, GLfloat);</div>
<div class="line">            CASE_TYPE(GL_FLOAT_VEC2,      glUniform2fv, 2, GLfloat);</div>
<div class="line">            CASE_TYPE(GL_FLOAT_VEC3,      glUniform3fv, 3, GLfloat);</div>
<div class="line">            CASE_TYPE(GL_FLOAT_VEC4,      glUniform4fv, 4, GLfloat);</div>
<div class="line">            CASE_TYPE(GL_DOUBLE,          glUniform1dv, 1, GLdouble);</div>
<div class="line">            CASE_TYPE(GL_DOUBLE_VEC2,     glUniform2dv, 2, GLdouble);</div>
<div class="line">            CASE_TYPE(GL_DOUBLE_VEC3,     glUniform3dv, 3, GLdouble);</div>
<div class="line">            CASE_TYPE(GL_DOUBLE_VEC4,     glUniform4dv, 4, GLdouble);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define CASE_TYPE_MAT(type, func, num, elemtype)                                  \</span></div>
<div class="line"><span class="preprocessor">    case type:                                                                    \</span></div>
<div class="line"><span class="preprocessor">        func(uniform_location, GLsizei(segment_size/(num * sizeof(elemtype))),  \</span></div>
<div class="line"><span class="preprocessor">            false, (const elemtype*)segment_data);                                \</span></div>
<div class="line"><span class="preprocessor">        break</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT2_ARB,  glUniformMatrix2fv,   4,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT2x3,    glUniformMatrix2x3fv, 6,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT3x2,    glUniformMatrix3x2fv, 6,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT2x4,    glUniformMatrix2x4fv, 8,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT4x2,    glUniformMatrix4x2fv, 8,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT3_ARB,  glUniformMatrix3fv,   9,  GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT3x4,    glUniformMatrix3x4fv, 12, GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT4x3,    glUniformMatrix4x3fv, 12, GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_FLOAT_MAT4_ARB,  glUniformMatrix4fv,   16, GLfloat);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT2,     glUniformMatrix2dv,   4,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT2x3,   glUniformMatrix2x3dv, 6,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT3x2,   glUniformMatrix3x2dv, 6,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT2x4,   glUniformMatrix2x4dv, 8,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT4x2,   glUniformMatrix4x2dv, 8,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT3,     glUniformMatrix3dv,   9,  GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT3x4,   glUniformMatrix3x4dv, 12, GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT4x3,   glUniformMatrix4x3dv, 12, GLdouble);</div>
<div class="line">            CASE_TYPE_MAT(GL_DOUBLE_MAT4,     glUniformMatrix4dv,   16, GLdouble);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Unsupported uniform type: 0x&quot;</span></div>
<div class="line">                    &lt;&lt; std::hex &lt;&lt; uniform_type &lt;&lt; std::dec &lt;&lt; std::endl;</div>
<div class="line">                terminate();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        check_gl_success();</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line"><span class="comment">// on the GPU.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_opengl_context::prepare_texture(</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>         image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> code,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                                            texture_index,</div>
<div class="line">    GLuint                                              texture_obj)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITexture&gt;</a> texture(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(texture_index)));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IImage&gt;</a> image(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(texture-&gt;get_image()));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas(0, 0, 0));</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_width = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_height = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_layers = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a1d62d69c848f7b4da053bac9e071bb75" title="Returns the number of layers this canvas has. ">get_layers_size</a>();</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *image_type = image-&gt;get_type(0, 0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (image-&gt;is_uvtile() || image-&gt;is_animated()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;The example does not support uvtile and/or animated textures!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (tex_layers != 1) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;The example and the GLSL backend don&#39;t support layered images!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For simplicity, the texture access functions are only implemented for float4 and gamma</span></div>
<div class="line">    <span class="comment">// is pre-applied here (all images are converted to linear space).</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert to linear color space if necessary</span></div>
<div class="line">    <span class="keywordflow">if</span> (texture-&gt;get_effective_gamma(0, 0) != 1.0f) {</div>
<div class="line">        <span class="comment">// Copy/convert to float4 canvas and adjust gamma from &quot;effective gamma&quot; to 1.</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> gamma_canvas(</div>
<div class="line">            image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), <span class="stringliteral">&quot;Color&quot;</span>));</div>
<div class="line">        gamma_canvas-&gt;set_gamma(texture-&gt;get_effective_gamma(0, 0));</div>
<div class="line">        image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#aef6f6c7994c60410b14d45a6cd0af7ce" title="Sets the gamma value of a canvas and adjusts the pixel data accordingly. ">adjust_gamma</a>(gamma_canvas.get(), 1.0f);</div>
<div class="line">        canvas = gamma_canvas;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(image_type, <span class="stringliteral">&quot;Color&quot;</span>) != 0 &amp;&amp; strcmp(image_type, <span class="stringliteral">&quot;Float32&lt;4&gt;&quot;</span>) != 0) {</div>
<div class="line">        <span class="comment">// Convert to expected format</span></div>
<div class="line">        canvas = image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), <span class="stringliteral">&quot;Color&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// This example supports only 2D textures</span></div>
<div class="line">    <a class="code" href="group__mi__neuray__mdl__compiler.html#gaa788bdbb9cb28f793e2c91cd8adf3faa">mi::neuraylib::ITarget_code::Texture_shape</a> texture_shape =</div>
<div class="line">        code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1ffc64d788c1ff52bb994266a242c81c" title="Returns the texture shape of a given texture resource used by the target code. ">get_texture_shape</a>(texture_index);</div>
<div class="line">    <span class="keywordflow">if</span> (texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaaecdeb3ccdfdca97e871c63b445d9dbf8" title="Two-dimensional texture. ">mi::neuraylib::ITarget_code::Texture_shape_2d</a>) {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const</span> *data = <span class="keyword">static_cast&lt;</span><a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line"></div>
<div class="line">        glBindTexture(GL_TEXTURE_2D, texture_obj);</div>
<div class="line">        glTexImage2D(</div>
<div class="line">            GL_TEXTURE_2D, 0, GL_RGBA, tex_width, tex_height, 0,  GL_RGBA, GL_FLOAT, data);</div>
<div class="line"></div>
<div class="line">        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</div>
<div class="line">        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    check_gl_success();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the needed material data of the given target code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_opengl_context::prepare_material_data(</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>       transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>         image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle the read-only data segments if necessary</span></div>
<div class="line">    set_mdl_readonly_data(target_code);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle the textures if there are more than just the invalid texture</span></div>
<div class="line">    <span class="keywordtype">size_t</span> cur_tex_offs = m_texture_objects.size();</div>
<div class="line">    m_material_texture_starts.push_back(GLuint(cur_tex_offs));</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_textures = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">get_texture_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_textures &gt; 1) {</div>
<div class="line">        m_texture_objects.insert(m_texture_objects.end(), num_textures - 1, 0);</div>
<div class="line"></div>
<div class="line">        glGenTextures(GLsizei(num_textures - 1), &amp;m_texture_objects[cur_tex_offs]);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all textures skipping the first texture,</span></div>
<div class="line">        <span class="comment">// which is always the MDL invalid texture</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_textures; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_texture(</div>
<div class="line">                    transaction, image_api, target_code,</div>
<div class="line">                    i, m_texture_objects[cur_tex_offs + i - 1]))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Sets all collected material data in the OpenGL program.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_opengl_context::set_material_data()</div>
<div class="line">{</div>
<div class="line">    GLsizei total_textures = GLsizei(m_texture_objects.size());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span>(total_textures &gt; MAX_TEXTURES)</div>
<div class="line">    {</div>
<div class="line">        fprintf( stderr, <span class="stringliteral">&quot;Number of required textures (%d) is not supported (max: %d)\n&quot;</span>,</div>
<div class="line">        total_textures, MAX_TEXTURES);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordflow">if</span> (glfwExtensionSupported(<span class="stringliteral">&quot;GL_ARB_bindless_texture&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (total_textures &gt; 0) {</div>
<div class="line">            std::vector&lt;GLuint64&gt; texture_handles;</div>
<div class="line">            texture_handles.resize(total_textures);</div>
<div class="line">            <span class="keywordflow">for</span> (GLsizei i = 0; i &lt; total_textures; ++i) {</div>
<div class="line">                texture_handles[i] = glGetTextureHandleARB(m_texture_objects[i]);</div>
<div class="line">                glMakeTextureHandleResidentARB(texture_handles[i]);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            glUniformHandleui64vARB(</div>
<div class="line">                glGetUniformLocation(m_program, <span class="stringliteral">&quot;material_texture_samplers_2d&quot;</span>),</div>
<div class="line">                total_textures,</div>
<div class="line">                &amp;texture_handles[0]);</div>
<div class="line"></div>
<div class="line">            glUniform1uiv(</div>
<div class="line">                glGetUniformLocation(m_program, <span class="stringliteral">&quot;material_texture_starts&quot;</span>),</div>
<div class="line">                GLsizei(m_material_texture_starts.size()),</div>
<div class="line">                &amp;m_material_texture_starts[0]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (glfwExtensionSupported(<span class="stringliteral">&quot;GL_NV_bindless_texture&quot;</span>))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (total_textures &gt; 0) {</div>
<div class="line">            std::vector&lt;GLuint64&gt; texture_handles;</div>
<div class="line">            texture_handles.resize(total_textures);</div>
<div class="line">            <span class="keywordflow">for</span> (GLsizei i = 0; i &lt; total_textures; ++i) {</div>
<div class="line">                texture_handles[i] = glGetTextureHandleNV(m_texture_objects[i]);</div>
<div class="line">                glMakeTextureHandleResidentNV(texture_handles[i]);</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            glUniformHandleui64vARB(</div>
<div class="line">                glGetUniformLocation(m_program, <span class="stringliteral">&quot;material_texture_samplers_2d&quot;</span>),</div>
<div class="line">                total_textures,</div>
<div class="line">                &amp;texture_handles[0]);</div>
<div class="line"></div>
<div class="line">            glUniform1uiv(</div>
<div class="line">                glGetUniformLocation(m_program, <span class="stringliteral">&quot;material_texture_starts&quot;</span>),</div>
<div class="line">                GLsizei(m_material_texture_starts.size()),</div>
<div class="line">                &amp;m_material_texture_starts[0]);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Sample requires Bindless Textures, &quot;</span></div>
<div class="line">                        <span class="stringliteral">&quot;that are not supported by the current system.\n&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif  // USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Check for any errors. If you get an error, check whether MAX_TEXTURES and MAX_MATERIALS</span></div>
<div class="line">    <span class="comment">// in example_execution_glsl.frag still fit to your needs.</span></div>
<div class="line">    <span class="keywordflow">return</span> glGetError() == GL_NO_ERROR;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MDL material compilation code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Material_compiler {</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    Material_compiler(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generates GLSL target code for a subexpression of a given material.</span></div>
<div class="line">    <span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line">    <span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material_subexpr(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* fname);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generates GLSL target code for a subexpression of a given compiled material.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> generate_glsl();</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Creates an instance of the given material.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* create_material_instance(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* compile_material_instance(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a> m_factory;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> m_mdl_impexp_api;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend&gt;</a> m_be_glsl;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a> m_transaction;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_execution_context&gt;</a> m_context;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ILink_unit&gt;</a> m_link_unit;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creates an instance of the given material.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* Material_compiler::create_material_instance(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> material_definition(</div>
<div class="line">        m_transaction-&gt;access&lt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(material_db_name.c_str()));</div>
<div class="line">    <span class="keywordflow">if</span> (!material_definition)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to access material definition &#39;%s&#39;.&quot;</span>, material_db_name.c_str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a material instance from the material definition</span></div>
<div class="line">    <span class="comment">// with the default arguments.</span></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> result;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        material_definition-&gt;create_function_call(0, &amp;result));</div>
<div class="line">    check_success(result == 0);</div>
<div class="line">    <span class="keywordflow">if</span> (result != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to instantiate material &#39;%s&#39;.&quot;</span>, material_db_name.c_str());</div>
<div class="line"></div>
<div class="line">    material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> material_instance.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a> *Material_compiler::compile_material_instance(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> flags = class_compilation</div>
<div class="line">        ? <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959a7474d76ee055edda39a494edf06cfc36" title="Selects class compilation instead of instance compilation. ">mi::neuraylib::IMaterial_instance::CLASS_COMPILATION</a></div>
<div class="line">        : <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959afdcc06252ec8a89909ddd69006031766" title="Default compilation options (e.g., instance compilation). ">mi::neuraylib::IMaterial_instance::DEFAULT_OPTIONS</a>;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMaterial_instance&gt;</a> material_instance2(</div>
<div class="line">        material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#aa24ef1b57dcff38f9abafc420978df5c" title="Acquires a const interface from another. ">get_interface</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a>&gt;());</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        material_instance2-&gt;create_compiled_material(flags, m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line"></div>
<div class="line">    compiled_material-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> compiled_material.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generates GLSL target code for a subexpression of a given compiled material.</span></div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> Material_compiler::generate_glsl()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> code_glsl(</div>
<div class="line">        m_be_glsl-&gt;translate_link_unit(m_link_unit.get(), m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line">    check_success(code_glsl);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_GLSL</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping GLSL code:\n\n&quot;</span> &lt;&lt; code_glsl-&gt;get_code() &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">return</span> code_glsl;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generates GLSL target code for a subexpression of a given material.</span></div>
<div class="line"><span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line"><span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material_subexpr(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* fname)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Load the given module and create a material instance</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        create_material_instance(qualified_module_name, material_db_name));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compile the material instance in instance compilation mode</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        compile_material_instance(material_instance.get(), <span class="comment">/*class_compilation=*/</span><span class="keyword">false</span>));</div>
<div class="line"></div>
<div class="line">    m_link_unit-&gt;add_material_expression(compiled_material.get(), path, fname,</div>
<div class="line">        m_context.get());</div>
<div class="line">    <span class="keywordflow">return</span> print_messages(m_context.get());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor.</span></div>
<div class="line">Material_compiler::Material_compiler(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction)</div>
<div class="line">: m_factory(mi::base::<a class="code" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">make_handle_dup</a>(mdl_factory))</div>
<div class="line">, m_mdl_impexp_api(mi::base::<a class="code" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">make_handle_dup</a>(mdl_impexp_api))</div>
<div class="line">, m_be_glsl(mdl_backend_api-&gt;get_backend(mi::neuraylib::IMdl_backend_api::MB_GLSL))</div>
<div class="line">, m_transaction(mi::base::<a class="code" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">make_handle_dup</a>(transaction))</div>
<div class="line">, m_context(mdl_factory-&gt;create_execution_context())</div>
<div class="line">, m_link_unit()</div>
<div class="line">{</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;num_texture_spaces&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// SSBO requires GLSL 4.30</span></div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_version&quot;</span>, <span class="stringliteral">&quot;430&quot;</span>) == 0);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_version&quot;</span>, <span class="stringliteral">&quot;330&quot;</span>) == 0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Specify the implementation modes for some state functions.</span></div>
<div class="line">    <span class="comment">// Note that &quot;geometry_normal&quot;, &quot;normal&quot; and &quot;position&quot; default to &quot;field&quot; mode.</span></div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_state_animation_time_mode&quot;</span>, <span class="stringliteral">&quot;field&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_state_position_mode&quot;</span>, <span class="stringliteral">&quot;func&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_state_texture_coordinate_mode&quot;</span>, <span class="stringliteral">&quot;arg&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_state_texture_tangent_u_mode&quot;</span>, <span class="stringliteral">&quot;field&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_state_texture_tangent_v_mode&quot;</span>, <span class="stringliteral">&quot;field&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SSBO</span></div>
<div class="line"><span class="preprocessor"></span>    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_max_const_data&quot;</span>, <span class="stringliteral">&quot;0&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_place_uniforms_into_ssbo&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_max_const_data&quot;</span>, <span class="stringliteral">&quot;1024&quot;</span>) == 0);</div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_place_uniforms_into_ssbo&quot;</span>, <span class="stringliteral">&quot;off&quot;</span>) == 0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#ifdef REMAP_NOISE_FUNCTIONS</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// remap noise functions that access the constant tables</span></div>
<div class="line">    check_success(m_be_glsl-&gt;set_option(<span class="stringliteral">&quot;glsl_remap_functions&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;_ZN4base12perlin_noiseEu6float4=noise_float4&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;,_ZN4base12worley_noiseEu6float3fi=noise_worley&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;,_ZN4base8mi_noiseEu6float3=noise_mi_float3&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;,_ZN4base8mi_noiseEu4int3=noise_mi_int3&quot;</span>) == 0);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// After we set the options, we can create the link unit</span></div>
<div class="line">    m_link_unit = <a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(m_be_glsl-&gt;create_link_unit(transaction, m_context.get()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Application logic</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Context structure for window callback functions.</span></div>
<div class="line"><span class="keyword">struct </span>Window_context</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// A number from 1 to 7 specifying the material pattern to display.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> material_pattern;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW callback handler for keyboard inputs.</span></div>
<div class="line"><span class="keywordtype">void</span> handle_key(GLFWwindow *window, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> <span class="comment">/*scancode*/</span>, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> <span class="comment">/*mods*/</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Handle key press events</span></div>
<div class="line">    <span class="keywordflow">if</span> (action == GLFW_PRESS) {</div>
<div class="line">        <span class="comment">// Map keypad numbers to normal numbers</span></div>
<div class="line">        <span class="keywordflow">if</span> (GLFW_KEY_KP_0 &lt;= key &amp;&amp; key &lt;= GLFW_KEY_KP_9)</div>
<div class="line">            key += GLFW_KEY_0 - GLFW_KEY_KP_0;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">switch</span> (key) {</div>
<div class="line">            <span class="comment">// Escape closes the window</span></div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_ESCAPE:</div>
<div class="line">                glfwSetWindowShouldClose(window, GLFW_TRUE);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Numbers 1 - 7 select the different material patterns</span></div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_1:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_2:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_3:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_4:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_5:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_6:</div>
<div class="line">            <span class="keywordflow">case</span> GLFW_KEY_7:</div>
<div class="line">            {</div>
<div class="line">                Window_context *ctx = <span class="keyword">static_cast&lt;</span>Window_context*<span class="keyword">&gt;</span>(</div>
<div class="line">                    glfwGetWindowUserPointer(window));</div>
<div class="line">                ctx-&gt;material_pattern = key - GLFW_KEY_0;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// GLFW callback handler for framebuffer resize events (when window size or resolution changes).</span></div>
<div class="line"><span class="keywordtype">void</span> handle_framebuffer_size(GLFWwindow* <span class="comment">/*window*/</span>, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)</div>
<div class="line">{</div>
<div class="line">    glViewport(0, 0, width, height);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Initializes OpenGL, creates the shader program and the scene and executes the animation loop.</span></div>
<div class="line"><span class="keywordtype">void</span> show_and_animate_scene(</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>        transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a>     mdl_impexp_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a>          image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a>  target_code,</div>
<div class="line">    Options <span class="keyword">const</span>                                       &amp;options)</div>
<div class="line">{</div>
<div class="line">    Window_context window_context = { options.material_pattern };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Init OpenGL window</span></div>
<div class="line">    GLFWwindow *window = init_opengl(options);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create shader program</span></div>
<div class="line">    GLuint program = create_shader_program(target_code);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create scene data</span></div>
<div class="line">    GLuint quad_vertex_buffer;</div>
<div class="line">    GLuint quad_vao = create_quad(program, &amp;quad_vertex_buffer);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Scope for material context resources</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Prepare the needed material data of all target codes for the fragment shader</span></div>
<div class="line">        Material_opengl_context material_opengl_context(program);</div>
<div class="line">        check_success(material_opengl_context.prepare_material_data(</div>
<div class="line">                transaction, image_api, target_code));</div>
<div class="line">        check_success(material_opengl_context.set_material_data());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get locations of uniform parameters for fragment shader</span></div>
<div class="line">        GLint   material_pattern_index = glGetUniformLocation(program, <span class="stringliteral">&quot;material_pattern&quot;</span>);</div>
<div class="line">        GLint   animation_time_index   = glGetUniformLocation(program, <span class="stringliteral">&quot;animation_time&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (!options.no_window) {</div>
<div class="line">            GLfloat animation_time = 0;</div>
<div class="line">            <span class="keywordtype">double</span>  last_frame_time = glfwGetTime();</div>
<div class="line"></div>
<div class="line">            glfwSetWindowUserPointer(window, &amp;window_context);</div>
<div class="line">            glfwSetKeyCallback(window, handle_key);</div>
<div class="line">            glfwSetFramebufferSizeCallback(window, handle_framebuffer_size);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Loop until the user closes the window</span></div>
<div class="line">            <span class="keywordflow">while</span> (!glfwWindowShouldClose(window))</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Update animation time</span></div>
<div class="line">                <span class="keywordtype">double</span> cur_frame_time = glfwGetTime();</div>
<div class="line">                animation_time += GLfloat(cur_frame_time - last_frame_time);</div>
<div class="line">                last_frame_time = cur_frame_time;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Set uniform frame parameters</span></div>
<div class="line">                glUniform1ui(material_pattern_index, window_context.material_pattern);</div>
<div class="line">                glUniform1f(animation_time_index, animation_time);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Render the scene</span></div>
<div class="line">                glClear(GL_COLOR_BUFFER_BIT);</div>
<div class="line">                glBindVertexArray(quad_vao);</div>
<div class="line">                glDrawArrays(GL_TRIANGLES, 0, 6);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Swap front and back buffers</span></div>
<div class="line">                glfwSwapBuffers(window);</div>
<div class="line"></div>
<div class="line">                <span class="comment">// Poll for events and process them</span></div>
<div class="line">                glfwPollEvents();</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {  <span class="comment">// no_window</span></div>
<div class="line">            <span class="comment">// Set up frame buffer</span></div>
<div class="line">            GLuint frame_buffer = 0, color_buffer = 0;</div>
<div class="line">            glGenFramebuffers(1, &amp;frame_buffer);</div>
<div class="line">            glBindFramebuffer(GL_FRAMEBUFFER, frame_buffer);</div>
<div class="line">            glGenRenderbuffers(1, &amp;color_buffer);</div>
<div class="line">            glBindRenderbuffer(GL_RENDERBUFFER, color_buffer);</div>
<div class="line">            glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, options.res_x, options.res_y);</div>
<div class="line">            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,</div>
<div class="line">                GL_RENDERBUFFER, color_buffer);</div>
<div class="line">            check_gl_success();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Set uniform frame parameters</span></div>
<div class="line">            glUniform1ui(material_pattern_index, window_context.material_pattern);</div>
<div class="line">            glUniform1f(animation_time_index, 0.f);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Render the scene</span></div>
<div class="line">            glClear(GL_COLOR_BUFFER_BIT);</div>
<div class="line">            glViewport(0, 0, options.res_x, options.res_y);</div>
<div class="line">            check_gl_success();</div>
<div class="line">            glBindVertexArray(quad_vao);</div>
<div class="line">            check_gl_success();</div>
<div class="line">            glDrawArrays(GL_TRIANGLES, 0, 6);</div>
<div class="line">            check_gl_success();</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Create a canvas and copy the result image to it</span></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> canvas(</div>
<div class="line">                image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a4f776e1c0271e6898a3585c0bf8099cd" title="Creates a canvas with given pixel type, resolution, and layers. ">create_canvas</a>(<span class="stringliteral">&quot;Rgba&quot;</span>, options.res_x, options.res_y));</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">            glReadPixels(0, 0, options.res_x, options.res_y,</div>
<div class="line">                GL_RGBA, GL_UNSIGNED_BYTE, tile-&gt;get_data());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Save the image to disk</span></div>
<div class="line">            mdl_impexp_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a1b544c77874b97eae0003c39e27e2103" title="Exports a canvas to a file on disk. ">export_canvas</a>(options.outputfile.c_str(), canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Cleanup frame buffer</span></div>
<div class="line">            glDeleteRenderbuffers(1, &amp;color_buffer);</div>
<div class="line">            glBindFramebuffer(GL_FRAMEBUFFER, 0);</div>
<div class="line">            glDeleteFramebuffers(1, &amp;frame_buffer);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup OpenGL</span></div>
<div class="line">    glDeleteVertexArrays(1, &amp;quad_vao);</div>
<div class="line">    glDeleteBuffers(1, &amp;quad_vertex_buffer);</div>
<div class="line">    glDeleteProgram(program);</div>
<div class="line">    check_gl_success();</div>
<div class="line">    glfwDestroyWindow(window);</div>
<div class="line">    glfwTerminate();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> usage(<span class="keywordtype">char</span> <span class="keyword">const</span> *prog_name)</div>
<div class="line">{</div>
<div class="line">    std::cout</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; prog_name &lt;&lt; <span class="stringliteral">&quot; [options] [&lt;material_pattern&gt;]\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Options:\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --nowin             don&#39;t show interactive display\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --res &lt;x&gt; &lt;y&gt;       resolution (default: 1024x768)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  -o &lt;outputfile&gt;     image file to write result in nowin mode (default: output.png)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  &lt;material_pattern&gt;  a number from 1 to 7 choosing which material combination to use&quot;</span></div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line">    exit_failure();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main function</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> MAIN_UTF8(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parse command line options</span></div>
<div class="line">    Options options;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; argc; ++i) {</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> *opt = argv[i];</div>
<div class="line">        <span class="keywordflow">if</span> (opt[0] == <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--nowin&quot;</span>) == 0)</div>
<div class="line">                options.no_window = <span class="keyword">true</span>;</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-o&quot;</span>) == 0) {</div>
<div class="line">                <span class="keywordflow">if</span> (i &lt; argc - 1)</div>
<div class="line">                    options.outputfile = argv[++i];</div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    usage(argv[0]);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--res&quot;</span>) == 0) {</div>
<div class="line">                <span class="keywordflow">if</span> (i &lt; argc - 2) {</div>
<div class="line">                    options.res_x = std::max(atoi(argv[++i]), 1);</div>
<div class="line">                    options.res_y = std::max(atoi(argv[++i]), 1);</div>
<div class="line">                } <span class="keywordflow">else</span></div>
<div class="line">                    usage(argv[0]);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                usage(argv[0]);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            options.material_pattern = unsigned(atoi(opt));</div>
<div class="line">            <span class="keywordflow">if</span> (options.material_pattern &lt; 1 || options.material_pattern &gt; 7) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid material_pattern parameter.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                usage(argv[0]);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Access the MDL SDK</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::INeuray&gt;</a> neuray(mi::examples::mdl::load_and_get_ineuray());</div>
<div class="line">    <span class="keywordflow">if</span> (!neuray.is_valid_interface())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to load the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Configure the MDL SDK</span></div>
<div class="line">    mi::examples::mdl::Configure_options configure_options;</div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::configure(neuray.get(), configure_options))</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Start the MDL SDK</span></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> ret = neuray-&gt;start();</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK. Result code: %d&quot;</span>, ret);</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create a transaction</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IDatabase&gt;</a> database(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IDatabase.html" title="This interface is used to interact with the distributed database. ">mi::neuraylib::IDatabase</a>&gt;());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IScope&gt;</a> scope(database-&gt;get_global_scope());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a> transaction(scope-&gt;create_transaction());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Access needed API components</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a> mdl_factory(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> mdl_impexp_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend_api&gt;</a> mdl_backend_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_execution_context&gt;</a> context(</div>
<div class="line">            mdl_factory-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a78a9a6489592c90ea49e0fe0ac8be235" title="Creates an execution context. ">create_execution_context</a>());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Load the module.</span></div>
<div class="line">        std::string module_name = <span class="stringliteral">&quot;::nvidia::sdk_examples::tutorials&quot;</span>;</div>
<div class="line">        mdl_impexp_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a5e195d80915190eb40c5995ccfeaa4c9" title="Loads an MDL module from disk (or a builtin module) into the database. ">load_module</a>(transaction.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), module_name.c_str(), context.get());</div>
<div class="line">        <span class="keywordflow">if</span> (!print_messages(context.get()))</div>
<div class="line">            exit_failure(<span class="stringliteral">&quot;Loading module &#39;%s&#39; failed.&quot;</span>, module_name.c_str());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Get the database name for the module we loaded</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::IString&gt;</a> module_db_name(</div>
<div class="line">            mdl_factory-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a72a27c9e0d66e79391ff9a8e3ce4a119" title="Returns the DB name for the MDL name of a module (or file path for MDLE modules). ...">get_db_module_name</a>(module_name.c_str()));</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IModule&gt;</a> module(</div>
<div class="line">            transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>&gt;(module_db_name-&gt;get_c_str()));</div>
<div class="line">        <span class="keywordflow">if</span> (!module)</div>
<div class="line">            exit_failure(<span class="stringliteral">&quot;Failed to access the loaded module.&quot;</span>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set up the materials.</span></div>
<div class="line">        std::vector&lt;std::string&gt; material_simple_names;</div>
<div class="line">        std::vector&lt;std::string&gt; fnames;</div>
<div class="line"><span class="preprocessor">#if defined(USE_SSBO) || defined(REMAP_NOISE_FUNCTIONS)</span></div>
<div class="line"><span class="preprocessor"></span>        material_simple_names.push_back(<span class="stringliteral">&quot;example_execution1&quot;</span>);</div>
<div class="line">        fnames.push_back(<span class="stringliteral">&quot;tint&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>        material_simple_names.push_back(<span class="stringliteral">&quot;example_execution2&quot;</span>);</div>
<div class="line">        fnames.push_back(<span class="stringliteral">&quot;tint_2&quot;</span>);</div>
<div class="line"><span class="preprocessor">#if defined(USE_SSBO) || defined(REMAP_NOISE_FUNCTIONS)</span></div>
<div class="line"><span class="preprocessor"></span>        material_simple_names.push_back(<span class="stringliteral">&quot;example_execution3&quot;</span>);</div>
<div class="line">        fnames.push_back(<span class="stringliteral">&quot;tint_3&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        <span class="comment">// Construct material DB names.</span></div>
<div class="line">        <span class="keywordtype">size_t</span> n = material_simple_names.size();</div>
<div class="line">        std::vector&lt;std::string&gt; material_db_names(n);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            material_db_names[i]</div>
<div class="line">                = std::string(module_db_name-&gt;get_c_str()) + <span class="stringliteral">&quot;::&quot;</span> + material_simple_names[i];</div>
<div class="line">            material_db_names[i] = mi::examples::mdl::add_missing_material_signature(</div>
<div class="line">                module.get(), material_db_names[i]);</div>
<div class="line">            <span class="keywordflow">if</span> (material_db_names[i].empty())</div>
<div class="line">                exit_failure(<span class="stringliteral">&quot;Failed to find the material %s in the module %s.&quot;</span>,</div>
<div class="line">                    material_simple_names[i].c_str(), module_name.c_str());</div>
<div class="line">        }</div>
<div class="line">        module.reset();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add material sub-expressions of different materials to the link unit.</span></div>
<div class="line">        Material_compiler mc(</div>
<div class="line">            mdl_impexp_api.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>(), mdl_backend_api.get(), mdl_factory.get(), transaction.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>());</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; n; ++i) {</div>
<div class="line">            mc.add_material_subexpr(</div>
<div class="line">                module_name, material_db_names[i], <span class="stringliteral">&quot;surface.scattering.tint&quot;</span>, fnames[i].c_str());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Generate the GLSL code for the link unit.</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> target_code(mc.generate_glsl());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Acquire image API needed to prepare the textures</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a> image_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        show_and_animate_scene(transaction, mdl_impexp_api, image_api, target_code, options);</div>
<div class="line"></div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#aa4ff8152107db238986b364273bceb0c" title="Commits the transaction. ">commit</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shut down the MDL SDK</span></div>
<div class="line">    <span class="keywordflow">if</span> (neuray-&gt;shutdown() != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to shutdown the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Unload the MDL SDK</span></div>
<div class="line">    neuray = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::unload())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to unload the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    exit_success();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Convert command line arguments to UTF8 on Windows</span></div>
<div class="line">COMMANDLINE_TO_UTF8</div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/execution_glsl/example_execution_glsl.vert</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"><span class="preprocessor">#version 330 core</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">layout (location = 0) in vec3 Position;</div>
<div class="line">layout (location = 1) in vec2 TexCoord;</div>
<div class="line"></div>
<div class="line">out vec3 vPosition;</div>
<div class="line">out vec3[1] texture_coordinate;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> main()</div>
<div class="line">{</div>
<div class="line">    gl_Position = vec4(Position, 1.0);</div>
<div class="line">    vPosition = Position;</div>
<div class="line">    texture_coordinate = vec3[1](vec3(TexCoord.x, TexCoord.y, 0.0));</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/execution_glsl/example_execution_glsl.frag</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/execution_glsl/example_execution_glsl.frag</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This file contains the implementations of the texture access functions</span></div>
<div class="line"><span class="comment">// and the fragment shader used to evaluate the material sub-expressions.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Material pattern as chosen by the user.</span></div>
<div class="line">uniform uint material_pattern;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Current time in seconds since the start of the render loop.</span></div>
<div class="line">uniform <span class="keywordtype">float</span> animation_time;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Mapping from material index to start index in material_texture_samplers_2d.</span></div>
<div class="line">uniform uint material_texture_starts[MAX_MATERIALS];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Array containg all 2D texture samplers of all used materials.</span></div>
<div class="line">uniform sampler2D material_texture_samplers_2d[MAX_TEXTURES];</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Start offset of the current material inside material_texture_samplers_2d, set in main.</span></div>
<div class="line">uint tex_start;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The input variables coming from the vertex shader.</span></div>
<div class="line">in vec3[1] texture_coordinate;    <span class="comment">// used for state::texture_coordinate(tex_space) in &quot;arg&quot; mode</span></div>
<div class="line">in vec3    vPosition;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The color output variable of this fragment shader.</span></div>
<div class="line">out vec4 FragColor;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The MDL material state structure as configured via the GLSL backend options.</span></div>
<div class="line"><span class="comment">// Note: Must be in sync with the state struct in generate_glsl_switch_func and the code generated</span></div>
<div class="line"><span class="comment">//       by the MDL SDK (see dumped code when enabling DUMP_GLSL in example_execution_glsl.cpp).</span></div>
<div class="line"><span class="keyword">struct </span>State {</div>
<div class="line">    vec3 normal;</div>
<div class="line">    vec3 geometry_normal;</div>
<div class="line">    <span class="keywordtype">float</span> animation_time;</div>
<div class="line">    vec3[1] texture_tangent_u;</div>
<div class="line">    vec3[1] texture_tangent_v;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// The prototypes of the functions generated in our generate_glsl_switch_func() function.</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return the number of available MDL material subexpressions.</span></div>
<div class="line">uint get_mdl_num_mat_subexprs();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Return the result of the MDL material subexpression given by the id.</span></div>
<div class="line">vec3 mdl_mat_subexpr(uint <span class="keywordtype">id</span>, State state);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if __VERSION__ &lt; 400</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">int</span> bitCount(uint x)</div>
<div class="line">{</div>
<div class="line">    x = x - ((x &gt;&gt; 1u) &amp; 0x55555555u);</div>
<div class="line">    x = (x &amp; 0x33333333u) + ((x &gt;&gt; 2u) &amp; 0x33333333u);</div>
<div class="line">    x = (x + (x &gt;&gt; 4u)) &amp; 0x0F0F0F0Fu;</div>
<div class="line">    x = x + (x &gt;&gt; 8u);</div>
<div class="line">    x = x + (x &gt;&gt; 16u);</div>
<div class="line">    <span class="keywordflow">return</span> int(x &amp; 0x0000003Fu);</div>
<div class="line">}</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_*() for a texture_2d texture.</span></div>
<div class="line">vec4 tex_lookup_2d(uint tex, vec2 coord, <span class="keywordtype">int</span> wrap_u, <span class="keywordtype">int</span> wrap_v, vec2 crop_u, vec2 crop_v, <span class="keywordtype">float</span> frame)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (tex == 0u) <span class="keywordflow">return</span> vec4(0);</div>
<div class="line">    <span class="keywordflow">return</span> texture(material_texture_samplers_2d[tex_start + tex - 1u], coord);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::texel_*() for a texture_2d texture.</span></div>
<div class="line">vec4 tex_texel_2d(uint tex, ivec2 coord, ivec2 uv_tile)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (tex == 0u) <span class="keywordflow">return</span> vec4(0);</div>
<div class="line">    <span class="keywordflow">return</span> texelFetch(material_texture_samplers_2d[tex_start + tex - 1u], coord, 0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of state::position() in &quot;func&quot; mode.</span></div>
<div class="line">vec3 position()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Mirror the position across the center in this example.</span></div>
<div class="line">    <span class="keywordflow">return</span> -vPosition;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The fragment shader main function evaluating the MDL sub-expression.</span></div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">    <span class="comment">// Set number of materials to use according to selected pattern</span></div>
<div class="line">    uint num_materials = uint(bitCount(material_pattern));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Assign materials in a checkerboard pattern</span></div>
<div class="line">    uint material_index =</div>
<div class="line">        (uint(texture_coordinate[0].x * 4) ^ uint(texture_coordinate[0].y * 4)) % num_materials;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Change material index according to selected pattern</span></div>
<div class="line">    <span class="keywordflow">switch</span> (material_pattern)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">case</span> 2u: material_index = 1u; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 4u: material_index = 2u; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 5u: <span class="keywordflow">if</span> (material_index == 1u) material_index = 2u; <span class="keywordflow">break</span>;</div>
<div class="line">        <span class="keywordflow">case</span> 6u: material_index += 1u; <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (material_index &gt; get_mdl_num_mat_subexprs())</div>
<div class="line">        material_index = get_mdl_num_mat_subexprs();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set up texture access for the chosen material</span></div>
<div class="line">    tex_start = material_texture_starts[material_index];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Set MDL material state for state functions in &quot;field&quot; mode</span></div>
<div class="line">    State state = State(</div>
<div class="line">        <span class="comment">/*normal=*/</span>              vec3(0.0, 0.0, 1.0),</div>
<div class="line">        <span class="comment">/*geometry_normal=*/</span>     vec3(0.0, 0.0, 1.0),</div>
<div class="line">        <span class="comment">/*animation_time=*/</span>      animation_time,</div>
<div class="line">        <span class="comment">/*texture_tangent_u=*/</span>   vec3[1](vec3(1.0, 0.0, 0.0)),</div>
<div class="line">        <span class="comment">/*texture_tangent_v=*/</span>   vec3[1](vec3(0.0, 1.0, 0.0))</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Evaluate material sub-expression</span></div>
<div class="line">    vec3 res = mdl_mat_subexpr(material_index, state);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Apply gamma correction and write to output variable</span></div>
<div class="line">    FragColor = <a class="code" href="group__mi__math__color.html#gacdaad24bbf75e76ff277a6c52adb4d8a" title="Returns the color a elementwise to the power of b. ">pow</a>(vec4(res, 1.0), vec4(1.0 / 2.2));</div>
<div class="line">}</div>
</div><!-- fragment --><div align="right"> [<a class="el" href="mi_neuray_example_execution_ptx.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_df_cuda.html">Next</a>] </div> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
