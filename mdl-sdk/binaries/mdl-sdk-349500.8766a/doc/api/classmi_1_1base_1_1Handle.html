<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>mi::base::Handle&lt; Interface &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmi_1_1base_1_1Handle.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmi_1_1base_1_1Handle-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mi::base::Handle&lt; Interface &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__mi__base__iinterface.html">Interface Framework Technology</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Handle class template for interfaces, automatizing the lifetime control via reference counting.  
 <a href="classmi_1_1base_1_1Handle.html#details"><span class="morelink">More...</span></a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89567a719878d77a6c3693f759693cf0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a></td></tr>
<tr class="memdesc:a89567a719878d77a6c3693f759693cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Own type.  <a href="#a89567a719878d77a6c3693f759693cf0"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a89567a719878d77a6c3693f759693cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae14654a39501ec0ac923c1753c83978"><td class="memItemLeft" align="right" valign="top">typedef Interface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#aae14654a39501ec0ac923c1753c83978">Interface_type</a></td></tr>
<tr class="memdesc:aae14654a39501ec0ac923c1753c83978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying interface.  <a href="#aae14654a39501ec0ac923c1753c83978"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aae14654a39501ec0ac923c1753c83978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe47cf67edbdf73d4e221ea79cc615f2"><td class="memItemLeft" align="right" valign="top">typedef Interface&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#abe47cf67edbdf73d4e221ea79cc615f2">value_type</a></td></tr>
<tr class="memdesc:abe47cf67edbdf73d4e221ea79cc615f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the underlying interface.  <a href="#abe47cf67edbdf73d4e221ea79cc615f2"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:abe47cf67edbdf73d4e221ea79cc615f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fab85b54c7062a854408cb6cea365a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="group__mi__base__types.html#gaa4f96b02768795e1677775e94c1cd1c6">Difference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a2fab85b54c7062a854408cb6cea365a8">difference_type</a></td></tr>
<tr class="memdesc:a2fab85b54c7062a854408cb6cea365a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference type (signed integral type to hold pointer differences).  <a href="#a2fab85b54c7062a854408cb6cea365a8"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a2fab85b54c7062a854408cb6cea365a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095a86ef122f4d91457f4622589608a0"><td class="memItemLeft" align="right" valign="top">typedef Interface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a095a86ef122f4d91457f4622589608a0">pointer</a></td></tr>
<tr class="memdesc:a095a86ef122f4d91457f4622589608a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable-pointer type to underlying interface.  <a href="#a095a86ef122f4d91457f4622589608a0"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a095a86ef122f4d91457f4622589608a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebe81a0aa049045ca0a0c479b2e9c9e"><td class="memItemLeft" align="right" valign="top">typedef Interface &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#adebe81a0aa049045ca0a0c479b2e9c9e">reference</a></td></tr>
<tr class="memdesc:adebe81a0aa049045ca0a0c479b2e9c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutable-reference type to underlying interface.  <a href="#adebe81a0aa049045ca0a0c479b2e9c9e"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:adebe81a0aa049045ca0a0c479b2e9c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ce3fb985b697bd35aabae79bec867c"><td class="memItemLeft" align="right" valign="top">typedef bool(Handle::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a11ce3fb985b697bd35aabae79bec867c">bool_conversion_support</a> )() const </td></tr>
<tr class="memdesc:a11ce3fb985b697bd35aabae79bec867c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper typedef.  <a href="#a11ce3fb985b697bd35aabae79bec867c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a11ce3fb985b697bd35aabae79bec867c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0c8e780b9a8a5b8d47d93186964614aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a0c8e780b9a8a5b8d47d93186964614aa">Handle</a> ()</td></tr>
<tr class="memdesc:a0c8e780b9a8a5b8d47d93186964614aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor, initializes handle to hold an invalid interface.  <a href="#a0c8e780b9a8a5b8d47d93186964614aa"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a0c8e780b9a8a5b8d47d93186964614aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b40ff55868f57195d688325416c8023"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a8b40ff55868f57195d688325416c8023">Handle</a> (Interface *ptr)</td></tr>
<tr class="memdesc:a8b40ff55868f57195d688325416c8023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from interface pointer, takes ownership of interface.  <a href="#a8b40ff55868f57195d688325416c8023"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a8b40ff55868f57195d688325416c8023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc90f14d7ce021c7145683a59fa61fd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a3dc90f14d7ce021c7145683a59fa61fd">Handle</a> (Interface *ptr, <a class="el" href="group__mi__base__iinterface.html#gab070a230365c4ed340841de836d25fbb">Dup_interface</a>)</td></tr>
<tr class="memdesc:a3dc90f14d7ce021c7145683a59fa61fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from interface pointer, does not take ownership of interface but duplicates it.  <a href="#a3dc90f14d7ce021c7145683a59fa61fd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a3dc90f14d7ce021c7145683a59fa61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208c2cdcdfc25026adadcd735b532a60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a208c2cdcdfc25026adadcd735b532a60">Handle</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;other)</td></tr>
<tr class="memdesc:a208c2cdcdfc25026adadcd735b532a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor, increments reference count if interface is valid.  <a href="#a208c2cdcdfc25026adadcd735b532a60"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a208c2cdcdfc25026adadcd735b532a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139b208cc8896babdb19488482536f04"><td class="memTemplParams" colspan="2">template&lt;class Interface2 &gt; </td></tr>
<tr class="memitem:a139b208cc8896babdb19488482536f04"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a139b208cc8896babdb19488482536f04">Handle</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a139b208cc8896babdb19488482536f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor template which allows the construction from assignment compatible interface pointers, increments reference count if interface is valid.  <a href="#a139b208cc8896babdb19488482536f04"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a139b208cc8896babdb19488482536f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cfe2c7866a3ea308f689bafa296250"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a49cfe2c7866a3ea308f689bafa296250">Handle</a> (<a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a49cfe2c7866a3ea308f689bafa296250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a49cfe2c7866a3ea308f689bafa296250"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a49cfe2c7866a3ea308f689bafa296250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b04a4f5a116c4e733ccd97a41a370d"><td class="memTemplParams" colspan="2">template&lt;class Interface2 &gt; </td></tr>
<tr class="memitem:af7b04a4f5a116c4e733ccd97a41a370d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#af7b04a4f5a116c4e733ccd97a41a370d">Handle</a> (<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:af7b04a4f5a116c4e733ccd97a41a370d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move constructor.  <a href="#af7b04a4f5a116c4e733ccd97a41a370d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:af7b04a4f5a116c4e733ccd97a41a370d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31630d72596f9a670cfb7bfd471c96ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a31630d72596f9a670cfb7bfd471c96ee">swap</a> (<a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;other)</td></tr>
<tr class="memdesc:a31630d72596f9a670cfb7bfd471c96ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two interfaces.  <a href="#a31630d72596f9a670cfb7bfd471c96ee"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a31630d72596f9a670cfb7bfd471c96ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bf8621b3924ada56ca45a46c71d4e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a80bf8621b3924ada56ca45a46c71d4e2">operator=</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;other)</td></tr>
<tr class="memdesc:a80bf8621b3924ada56ca45a46c71d4e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator, releases old interface and increments reference count of the new interface if interface is valid.  <a href="#a80bf8621b3924ada56ca45a46c71d4e2"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a80bf8621b3924ada56ca45a46c71d4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6a1a89504e9c321c32ac549366460f"><td class="memTemplParams" colspan="2">template&lt;class Interface2 &gt; </td></tr>
<tr class="memitem:a4c6a1a89504e9c321c32ac549366460f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a4c6a1a89504e9c321c32ac549366460f">operator=</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;other)</td></tr>
<tr class="memdesc:a4c6a1a89504e9c321c32ac549366460f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator template, releases old interface and increments reference count of the new interface if interface is valid.  <a href="#a4c6a1a89504e9c321c32ac549366460f"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a4c6a1a89504e9c321c32ac549366460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76968552e613e05e05cb29998f11545d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a76968552e613e05e05cb29998f11545d">operator=</a> (<a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a76968552e613e05e05cb29998f11545d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator, releases old interface.  <a href="#a76968552e613e05e05cb29998f11545d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a76968552e613e05e05cb29998f11545d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f8059dfa4e63b5d661e78101545d62"><td class="memTemplParams" colspan="2">template&lt;class Interface2 &gt; </td></tr>
<tr class="memitem:a10f8059dfa4e63b5d661e78101545d62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a10f8059dfa4e63b5d661e78101545d62">operator=</a> (<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&amp;other)</td></tr>
<tr class="memdesc:a10f8059dfa4e63b5d661e78101545d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converting move assignment operator, releases old interface.  <a href="#a10f8059dfa4e63b5d661e78101545d62"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a10f8059dfa4e63b5d661e78101545d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46f915352413118c6f722eda607c2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#ae46f915352413118c6f722eda607c2bd">operator=</a> (Interface *ptr)</td></tr>
<tr class="memdesc:ae46f915352413118c6f722eda607c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator from interface pointer, releases old interface and assigns new interface <code>ptr</code>, takes ownership of interface.  <a href="#ae46f915352413118c6f722eda607c2bd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae46f915352413118c6f722eda607c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0b775c1e3592c3343a486f226d9c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#aef0b775c1e3592c3343a486f226d9c7b">reset</a> ()</td></tr>
<tr class="memdesc:aef0b775c1e3592c3343a486f226d9c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the current interface, decrementing the reference count.  <a href="#aef0b775c1e3592c3343a486f226d9c7b"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aef0b775c1e3592c3343a486f226d9c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216ccfe332edefe00c81de30a365629c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a216ccfe332edefe00c81de30a365629c">~Handle</a> ()</td></tr>
<tr class="memdesc:a216ccfe332edefe00c81de30a365629c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor, releases the interface if it is valid, which decrements the reference count, and triggers thus the deletion of the interface implementation once the reference count reaches zero.  <a href="#a216ccfe332edefe00c81de30a365629c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a216ccfe332edefe00c81de30a365629c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bb173f0dba8b83ac6fcf8f08cda05b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a38bb173f0dba8b83ac6fcf8f08cda05b">is_valid_interface</a> () const </td></tr>
<tr class="memdesc:a38bb173f0dba8b83ac6fcf8f08cda05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the interface is valid.  <a href="#a38bb173f0dba8b83ac6fcf8f08cda05b"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a38bb173f0dba8b83ac6fcf8f08cda05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28423d4121459d4026449e4991f5486"><td class="memItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486">get</a> () const </td></tr>
<tr class="memdesc:ab28423d4121459d4026449e4991f5486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the interface. Returns 0 for an invalid interface.  <a href="#ab28423d4121459d4026449e4991f5486"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ab28423d4121459d4026449e4991f5486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f57fda59ee6d082b5e779d9e14f7f6"><td class="memItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a02f57fda59ee6d082b5e779d9e14f7f6">extract</a> ()</td></tr>
<tr class="memdesc:a02f57fda59ee6d082b5e779d9e14f7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the interface and releases the handle.  <a href="#a02f57fda59ee6d082b5e779d9e14f7f6"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a02f57fda59ee6d082b5e779d9e14f7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa5fbf5fe388c9ed17d0db91e0e74a3"><td class="memItemLeft" align="right" valign="top">Interface &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a3fa5fbf5fe388c9ed17d0db91e0e74a3">operator*</a> () const </td></tr>
<tr class="memdesc:a3fa5fbf5fe388c9ed17d0db91e0e74a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dereference operator accesses the interface.  <a href="#a3fa5fbf5fe388c9ed17d0db91e0e74a3"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a3fa5fbf5fe388c9ed17d0db91e0e74a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced97d38237aed6b65d720dbd071bea"><td class="memItemLeft" align="right" valign="top">Interface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#aeced97d38237aed6b65d720dbd071bea">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:aeced97d38237aed6b65d720dbd071bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The arrow operator accesses the interface.  <a href="#aeced97d38237aed6b65d720dbd071bea"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aeced97d38237aed6b65d720dbd071bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf476807cc128c7e1052bc9f21633f8"><td class="memTemplParams" colspan="2">template&lt;class New_interface &gt; </td></tr>
<tr class="memitem:abdf476807cc128c7e1052bc9f21633f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; New_interface &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#abdf476807cc128c7e1052bc9f21633f8">get_interface</a> () const </td></tr>
<tr class="memdesc:abdf476807cc128c7e1052bc9f21633f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new handle for a possibly different interface type, which is the equivalent of a dynamic cast.  <a href="#abdf476807cc128c7e1052bc9f21633f8"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:abdf476807cc128c7e1052bc9f21633f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86500724acda8fd7a1de0786c10c1f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#ad86500724acda8fd7a1de0786c10c1f9">operator bool_conversion_support</a> () const </td></tr>
<tr class="memdesc:ad86500724acda8fd7a1de0786c10c1f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for the conversion of a Handle&lt;Interface&gt; to a bool.  <a href="#ad86500724acda8fd7a1de0786c10c1f9"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ad86500724acda8fd7a1de0786c10c1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a24f2fdf0dee35a216abb0812c6f26a6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a24f2fdf0dee35a216abb0812c6f26a6b">operator==</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;lhs, const Interface *rhs)</td></tr>
<tr class="memdesc:a24f2fdf0dee35a216abb0812c6f26a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the underlying interface pointer of <code>lhs</code> is equal to <code>rhs</code>.  <a href="#a24f2fdf0dee35a216abb0812c6f26a6b"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a24f2fdf0dee35a216abb0812c6f26a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2153a1d66cbd6732418fb26d564c8315"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a2153a1d66cbd6732418fb26d564c8315">operator==</a> (const Interface *lhs, const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2153a1d66cbd6732418fb26d564c8315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is equal to the underlying interface pointer of <code>rhs</code>.  <a href="#a2153a1d66cbd6732418fb26d564c8315"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a2153a1d66cbd6732418fb26d564c8315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e90fa5ebea681c1e37cc7c95e01dce3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a4e90fa5ebea681c1e37cc7c95e01dce3">operator!=</a> (const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;lhs, const Interface *rhs)</td></tr>
<tr class="memdesc:a4e90fa5ebea681c1e37cc7c95e01dce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the underlying interface pointer of <code>lhs</code> is not equal to <code>rhs</code>.  <a href="#a4e90fa5ebea681c1e37cc7c95e01dce3"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a4e90fa5ebea681c1e37cc7c95e01dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963c4ff45de1afecf9a483a76de24a4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Handle.html#a963c4ff45de1afecf9a483a76de24a4f">operator!=</a> (const Interface *lhs, const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a963c4ff45de1afecf9a483a76de24a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>lhs</code> is not equal to the underlying interface pointer of <code>rhs</code>.  <a href="#a963c4ff45de1afecf9a483a76de24a4f"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a963c4ff45de1afecf9a483a76de24a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Interface&gt;<br/>
class mi::base::Handle&lt; Interface &gt;</h3>

<p>Handle class template for interfaces, automatizing the lifetime control via reference counting. </p>
<p>The <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">Handle</a> class is smart-pointer class that handles the reference counting of interface classes automatically. A handle stores internally a pointer to the underlying interface class.</p>
<p>Template parameter:</p>
<ul>
<li><code>Interface:</code> an interface class, i.e., either the <a class="el" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a> class itself or a class derived from it.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">Handle</a> class is const correct: Use Handle&lt; const I &gt; for a const pointer to an interface class <code>I</code> and Handle&lt; I &gt; for a mutable pointer to an interface class <code>I</code>.</dd></dl>
<p>The <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">Handle</a> class has two constructors which differ in the way they handle ownership of the interface pointer they are constructed from (actually, there is a third constructor, the default constructor, which constructs an invalid handle). In the first form mi::base::Handle&lt;I&gt;(I*) the <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">Handle</a> instance takes ownership of the interface. In the second form mi::base::Handle&lt;I&gt;(I*,Dup_interface) it does not take ownership of the interface, but duplicates it.</p>
<p>The following two examples, based on the neuraylib API, illustrate the use of both constructors. The first example demonstrates the prevailing use case where you want to locally store the interface pointer returned from an API function for subsequent usage. In this case you should use the first form of the constructor which takes ownership of the interface.</p>
<div class="fragment"><div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::INeuray&gt;</a> neuray( mi_neuray_factory());</div>
<div class="line">neuray-&gt;start( <span class="keyword">true</span>);</div>
</div><!-- fragment --><p>On the other hand, assume that you want to store a pointer to an interface whose lifetime you do not control. This typically happens when a pointer is passed as parameter to a function. By convention such pointers are owned by the function caller.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo( <a class="code" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a>* interface)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::base::IInterface&gt;</a> handle( interface, <a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">mi::base::DUP_INTERFACE</a>);</div>
<div class="line">    <span class="comment">// do something with handle</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><a class="code" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a>* <span class="keyword">interface </span>= ...</div>
<div class="line">foo( interface);</div>
<div class="line"><span class="comment">// do more things with interface</span></div>
</div><!-- fragment --><p>If you had not used the second form of the handle constructor in this example, the handle destructor would have decremented the reference counter of <code>interface</code> to 0 at the end of foo(). Therefore, the corresponding interface would have been destroyed and the <code>interface</code> pointer would be invalid after the foo() call.</p>
<p>In contrast, the second form of the handle constructor does not take ownership of the <code>interface</code> pointer, but increments the reference count once more. Consequently, when the handle is destroyed, the reference count does not drop to 0.</p>
<p>Note that this use case often shows up when you store a pointer passed in via a member function as a class member.</p>
<p>See also <a class="el" href="mi_neuray_design.html#mi_neuray_handle">Handle class</a> for an extended example (and <a class="el" href="mi_neuray_design.html#mi_neuray_refcounting">Reference counting</a> for the same example without handle class). </p>
<dl class="section user"><dt>Include File:</dt><dd><code> #include &lt;<a class="el" href="handle_8h.html" title="Smart-pointer handle class for interfaces, const and non-const version. ">mi/base/handle.h</a>&gt;</code></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">make_handle()</a> and <a class="el" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">make_handle_dup()</a> for creating a typed handle from a typed interface pointer </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a11ce3fb985b697bd35aabae79bec867c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(Handle::* <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::bool_conversion_support)() const </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper typedef. </p>
<p>This typedef represent the type of <a class="el" href="classmi_1_1base_1_1Handle.html#a38bb173f0dba8b83ac6fcf8f08cda05b" title="Returns true if the interface is valid. ">is_valid_interface()</a> used by the <a class="el" href="classmi_1_1base_1_1Handle.html#a11ce3fb985b697bd35aabae79bec867c" title="Helper typedef. ">bool_conversion_support()</a> operator. </p>

</div>
</div>
<a class="anchor" id="a2fab85b54c7062a854408cb6cea365a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__mi__base__types.html#gaa4f96b02768795e1677775e94c1cd1c6">Difference</a> <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#a2fab85b54c7062a854408cb6cea365a8">difference_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference type (signed integral type to hold pointer differences). </p>

</div>
</div>
<a class="anchor" id="aae14654a39501ec0ac923c1753c83978"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Interface <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#aae14654a39501ec0ac923c1753c83978">Interface_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the underlying interface. </p>

</div>
</div>
<a class="anchor" id="a095a86ef122f4d91457f4622589608a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Interface* <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#a095a86ef122f4d91457f4622589608a0">pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable-pointer type to underlying interface. </p>

</div>
</div>
<a class="anchor" id="adebe81a0aa049045ca0a0c479b2e9c9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Interface&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#adebe81a0aa049045ca0a0c479b2e9c9e">reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mutable-reference type to underlying interface. </p>

</div>
</div>
<a class="anchor" id="a89567a719878d77a6c3693f759693cf0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt;Interface&gt; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Own type. </p>

</div>
</div>
<a class="anchor" id="abe47cf67edbdf73d4e221ea79cc615f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Interface <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html#abe47cf67edbdf73d4e221ea79cc615f2">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of the underlying interface. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0c8e780b9a8a5b8d47d93186964614aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor, initializes handle to hold an invalid interface. </p>

</div>
</div>
<a class="anchor" id="a8b40ff55868f57195d688325416c8023"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype">Interface *&#160;</td>
          <td class="paramname"><em>ptr</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from interface pointer, takes ownership of interface. </p>
<p>The constructor does not increment the reference count of <code>ptr</code> assuming it is already set properly, e.g., by a corresponding <a class="el" href="classmi_1_1base_1_1Handle.html#abdf476807cc128c7e1052bc9f21633f8" title="Returns a new handle for a possibly different interface type, which is the equivalent of a dynamic ca...">get_interface()</a> call. It therefore takes over the ownership of the interface pointer. </p>

</div>
</div>
<a class="anchor" id="a3dc90f14d7ce021c7145683a59fa61fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype">Interface *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__iinterface.html#gab070a230365c4ed340841de836d25fbb">Dup_interface</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor from interface pointer, does not take ownership of interface but duplicates it. </p>
<p>The constructor increments the reference count of <code>ptr</code> so that it does not influence the interface when it decrements the reference count later on. You can use this constructor for example to hold interfaces that are passed into functions as parameters because by convention they are owned by the function caller. You can pass the constant DUP_INTERFACE as the second argument. </p>

</div>
</div>
<a class="anchor" id="a208c2cdcdfc25026adadcd735b532a60"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor, increments reference count if interface is valid. </p>

</div>
</div>
<a class="anchor" id="a139b208cc8896babdb19488482536f04"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<div class="memtemplate">
template&lt;class Interface2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor template which allows the construction from assignment compatible interface pointers, increments reference count if interface is valid. </p>
<p>This constructor allows specifically the construction of a <code>Handle&lt; const I &gt;</code> from a <code>Handle&lt; I &gt;</code> value, which corresponds to the assignment of a mutable pointer to a const pointer. In addition, promotion of derived interfaces to base interfaces is allowed. </p>

</div>
</div>
<a class="anchor" id="a49cfe2c7866a3ea308f689bafa296250"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<a class="anchor" id="af7b04a4f5a116c4e733ccd97a41a370d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<div class="memtemplate">
template&lt;class Interface2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move constructor. </p>

</div>
</div>
<a class="anchor" id="a216ccfe332edefe00c81de30a365629c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::~<a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor, releases the interface if it is valid, which decrements the reference count, and triggers thus the deletion of the interface implementation once the reference count reaches zero. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a02f57fda59ee6d082b5e779d9e14f7f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Interface* <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::extract </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the interface and releases the handle. </p>
<p>Returns 0 for an invalid interface.</p>
<p>Note that the owner takes responsible for managing the lifetime of the interface. </p>

</div>
</div>
<a class="anchor" id="ab28423d4121459d4026449e4991f5486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Interface* <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::get </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access to the interface. Returns 0 for an invalid interface. </p>

</div>
</div>
<a class="anchor" id="abdf476807cc128c7e1052bc9f21633f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<div class="memtemplate">
template&lt;class New_interface &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt;New_interface&gt; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::get_interface </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new handle for a possibly different interface type, which is the equivalent of a dynamic cast. </p>
<p>Returns a handle with an invalid interface if the requested interface type is not supported by the underlying interface implementation or if this interface is itself already invalid. </p>

</div>
</div>
<a class="anchor" id="a38bb173f0dba8b83ac6fcf8f08cda05b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::is_valid_interface </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the interface is valid. </p>

</div>
</div>
<a class="anchor" id="ad86500724acda8fd7a1de0786c10c1f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator <a class="el" href="classmi_1_1base_1_1Handle.html#a11ce3fb985b697bd35aabae79bec867c">bool_conversion_support</a> </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for the conversion of a Handle&lt;Interface&gt; to a bool. </p>
<p>This helper function allows to write </p>
<div class="fragment"><div class="line">Handle&lt;T&gt; h(...);</div>
<div class="line"><span class="keywordflow">if</span>( h) ...</div>
</div><!-- fragment --><p> instead of </p>
<div class="fragment"><div class="line">Handle&lt;T&gt; h(...);</div>
<div class="line"><span class="keywordflow">if</span>( h.is_valid_interface()) ...</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a3fa5fbf5fe388c9ed17d0db91e0e74a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Interface&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator* </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The dereference operator accesses the interface. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classmi_1_1base_1_1Handle.html#a38bb173f0dba8b83ac6fcf8f08cda05b" title="Returns true if the interface is valid. ">is_valid_interface()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aeced97d38237aed6b65d720dbd071bea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Interface* <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The arrow operator accesses the interface. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="classmi_1_1base_1_1Handle.html#a38bb173f0dba8b83ac6fcf8f08cda05b" title="Returns true if the interface is valid. ">is_valid_interface()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a80bf8621b3924ada56ca45a46c71d4e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a>&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator, releases old interface and increments reference count of the new interface if interface is valid. </p>

</div>
</div>
<a class="anchor" id="a4c6a1a89504e9c321c32ac549366460f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<div class="memtemplate">
template&lt;class Interface2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a>&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator template, releases old interface and increments reference count of the new interface if interface is valid. </p>
<p>This assignment operator allows specifically the assignment of a <code>Handle&lt; I &gt;</code> to a <code>Handle&lt; const I &gt;</code> value, which corresponds to the assignment of a mutable pointer to a const pointer. In addition, promotion of derived interfaces to base interfaces is allowed. </p>

</div>
</div>
<a class="anchor" id="a76968552e613e05e05cb29998f11545d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a>&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator, releases old interface. </p>

</div>
</div>
<a class="anchor" id="a10f8059dfa4e63b5d661e78101545d62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<div class="memtemplate">
template&lt;class Interface2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a>&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface2 &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converting move assignment operator, releases old interface. </p>

</div>
</div>
<a class="anchor" id="ae46f915352413118c6f722eda607c2bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a>&amp; <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">Interface *&#160;</td>
          <td class="paramname"><em>ptr</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator from interface pointer, releases old interface and assigns new interface <code>ptr</code>, takes ownership of interface. </p>
<p>Does not increment reference count of <code>ptr</code> assuming it is already set properly, e.g., by a corresponding <a class="el" href="classmi_1_1base_1_1Handle.html#abdf476807cc128c7e1052bc9f21633f8" title="Returns a new handle for a possibly different interface type, which is the equivalent of a dynamic ca...">get_interface()</a> call. </p>

</div>
</div>
<a class="anchor" id="aef0b775c1e3592c3343a486f226d9c7b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::reset </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the current interface, decrementing the reference count. </p>

</div>
</div>
<a class="anchor" id="a31630d72596f9a670cfb7bfd471c96ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmi_1_1base_1_1Handle.html">mi::base::Handle</a>&lt; Interface &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1base_1_1Handle.html#a89567a719878d77a6c3693f759693cf0">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two interfaces. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a4e90fa5ebea681c1e37cc7c95e01dce3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interface *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the underlying interface pointer of <code>lhs</code> is not equal to <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a963c4ff45de1afecf9a483a76de24a4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const Interface *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is not equal to the underlying interface pointer of <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a24f2fdf0dee35a216abb0812c6f26a6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Interface *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the underlying interface pointer of <code>lhs</code> is equal to <code>rhs</code>. </p>

</div>
</div>
<a class="anchor" id="a2153a1d66cbd6732418fb26d564c8315"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Interface&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const Interface *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1Handle.html">Handle</a>&lt; Interface &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>lhs</code> is equal to the underlying interface pointer of <code>rhs</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
