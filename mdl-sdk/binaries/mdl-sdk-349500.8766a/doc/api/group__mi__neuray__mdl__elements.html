<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>MDL-related elements</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__mi__neuray__mdl__elements.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">MDL-related elements<div class="ingroups"><a class="el" href="group__mi__neuray__scene__element.html">Scene elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>MDL-related elements comprise a set of interfaces related to the Material Definition Language (MDL).  
<a href="#details"><span class="morelink">More...</span></a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1Annotation__wrapper.html">mi::neuraylib::Annotation_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around the interfaces for MDL annotations.  <a href="classmi_1_1neuraylib_1_1Annotation__wrapper.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1Argument__editor.html">mi::neuraylib::Argument_editor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around the interface for MDL material instances and function calls.  <a href="classmi_1_1neuraylib_1_1Argument__editor.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1Definition__wrapper.html">mi::neuraylib::Definition_wrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around the interface for MDL material and function definitions.  <a href="classmi_1_1neuraylib_1_1Definition__wrapper.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html">mi::neuraylib::ICompiled_material</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a compiled material.  <a href="classmi_1_1neuraylib_1_1ICompiled__material.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html">mi::neuraylib::IFunction_call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a function call.  <a href="classmi_1_1neuraylib_1_1IFunction__call.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html">mi::neuraylib::IFunction_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a function definition.  <a href="classmi_1_1neuraylib_1_1IFunction__definition.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html">mi::neuraylib::IMaterial_definition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a material definition.  <a href="classmi_1_1neuraylib_1_1IMaterial__definition.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html">mi::neuraylib::IMaterial_instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents a material instance.  <a href="classmi_1_1neuraylib_1_1IMaterial__instance.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IModule.html">mi::neuraylib::IModule</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface represents an MDL module.  <a href="classmi_1_1neuraylib_1_1IModule.html#details"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4e2cebe47d60cf89b56196471b9ec162"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mi__neuray__mdl__elements.html#ga4e2cebe47d60cf89b56196471b9ec162">mi::neuraylib::Material_slot</a> { <br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162aa9723dd0385d5c2c72d00df154aeb0cd">mi::neuraylib::SLOT_THIN_WALLED</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a95356115b56fa4672f7e57a887261186">mi::neuraylib::SLOT_SURFACE_SCATTERING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162addda6e4a2a88fcd9c9606685e891f2e5">mi::neuraylib::SLOT_SURFACE_EMISSION_EDF_EMISSION</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a3f0b5973556604e36dcfd9addbc8f7a0">mi::neuraylib::SLOT_SURFACE_EMISSION_INTENSITY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162af1b8a4bea1c95adcda6a5573d2cc6301">mi::neuraylib::SLOT_SURFACE_EMISSION_MODE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a1ef3c4a0f4a892679f761d38aa0853d9">mi::neuraylib::SLOT_BACKFACE_SCATTERING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162abb84473e252871614ad2aba0103a884f">mi::neuraylib::SLOT_BACKFACE_EMISSION_EDF_EMISSION</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a022577607f0a7d10583a937637448d0a">mi::neuraylib::SLOT_BACKFACE_EMISSION_INTENSITY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162ad4bd129833381c46ff60f1b2ae7cc4cb">mi::neuraylib::SLOT_BACKFACE_EMISSION_MODE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a710f8b080ecb835a935d8628603711a3">mi::neuraylib::SLOT_IOR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162ae7b8c1f175b3f4667e1e95d67dc195e2">mi::neuraylib::SLOT_VOLUME_SCATTERING</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162aaa882cd2014f15517554cb703778b112">mi::neuraylib::SLOT_VOLUME_ABSORPTION_COEFFICIENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162af4f26fff6e922e62749eb67995722e99">mi::neuraylib::SLOT_VOLUME_SCATTERING_COEFFICIENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a713485357fe1774bfdb93b97e54f340b">mi::neuraylib::SLOT_GEOMETRY_DISPLACEMENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162abdea8ac97d995e303c38b00cff9fb50e">mi::neuraylib::SLOT_GEOMETRY_CUTOUT_OPACITY</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a8500bcd1983247b7014028f73b31c013">mi::neuraylib::SLOT_GEOMETRY_NORMAL</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162aac5dd6fbad07453b6c05f2404f1ea486">mi::neuraylib::SLOT_HAIR</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162a54b9af4f48afe62567b3b03b03fc586f">mi::neuraylib::SLOT_FIRST</a> = SLOT_THIN_WALLED, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga4e2cebe47d60cf89b56196471b9ec162ad9e9c11a53ef2eb55a674a3ad2591202">mi::neuraylib::SLOT_LAST</a> = SLOT_HAIR
<br/>
 }</td></tr>
<tr class="memdesc:ga4e2cebe47d60cf89b56196471b9ec162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Material slots identify parts of a compiled material.  <a href="group__mi__neuray__mdl__elements.html#ga4e2cebe47d60cf89b56196471b9ec162"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga4e2cebe47d60cf89b56196471b9ec162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e91f00d174ec5630869ebe156419d09"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mi__neuray__mdl__elements.html#ga5e91f00d174ec5630869ebe156419d09">mi::neuraylib::Material_opacity</a> { <br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga5e91f00d174ec5630869ebe156419d09af39122f493e2661c11dff5e216a0b182">mi::neuraylib::OPACITY_OPAQUE</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga5e91f00d174ec5630869ebe156419d09a0b348a2fb9b931c37faadfb447d5e8d8">mi::neuraylib::OPACITY_TRANSPARENT</a>, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga5e91f00d174ec5630869ebe156419d09a682c0e533a9724fa6e8089971ccc60bb">mi::neuraylib::OPACITY_UNKNOWN</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga5e91f00d174ec5630869ebe156419d09"><td class="mdescLeft">&#160;</td><td class="mdescRight">The compiled material's opacity.  <a href="group__mi__neuray__mdl__elements.html#ga5e91f00d174ec5630869ebe156419d09"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga5e91f00d174ec5630869ebe156419d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ccced0757d210d79f0308ade130ae39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__mi__neuray__mdl__elements.html#ga8ccced0757d210d79f0308ade130ae39">mi::neuraylib::Mdl_repair_options</a> { <br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga8ccced0757d210d79f0308ade130ae39a79a8d7ced4ce778f05446a24799a90a2">mi::neuraylib::MDL_REPAIR_DEFAULT</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga8ccced0757d210d79f0308ade130ae39a5077f357fe88d8c9474d8ef1684e73c0">mi::neuraylib::MDL_REMOVE_INVALID_ARGUMENTS</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="group__mi__neuray__mdl__elements.html#gga8ccced0757d210d79f0308ade130ae39a9e284e783a70e3cce8bf364a7860dca6">mi::neuraylib::MDL_REPAIR_INVALID_ARGUMENTS</a> = 2
<br/>
 }</td></tr>
<tr class="memdesc:ga8ccced0757d210d79f0308ade130ae39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for repairing function calls.  <a href="group__mi__neuray__mdl__elements.html#ga8ccced0757d210d79f0308ade130ae39"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ga8ccced0757d210d79f0308ade130ae39"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>MDL-related elements comprise a set of interfaces related to the Material Definition Language (MDL). </p>
<p>See [<a class="el" href="mi_neuray_biblio.html#MDLTI">MDLTI</a>] for a technical introduction into the Material Definition Language and [<a class="el" href="mi_neuray_biblio.html#MDLLS">MDLLS</a>] for the language specification. See also <a class="el" href="group__mi__neuray__mdl__types.html">MDL type system</a>.</p>
<p>The unit of compilation in MDL is a module. Importing an MDL module creates an instance of <a class="el" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a> in the DB. A module allows to retrieve the referenced (aka imported) modules, as well as the exported material and function definitions. For all exported definitions, DB elements of type <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> are created in the DB accordingly. Both, material and function definitions can be instantiated. Those instantiations are represented by the interface <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>.</p>
<h1><a class="anchor" id="mi_mdl_names"></a>
Naming scheme for MDL elements</h1>
<p>There are four different types of names for MDL elements: DB names, MDL names, simple MDL names, and serialized names. In addition, there is a global configuration option to enable encoded names.</p>
<h2><a class="anchor" id="mi_mdl_encoded_names"></a>
Encoded names</h2>
<p>Encoded names are a new naming scheme for MDL elements. Its purpose is to avoid certain problems that exist with the old naming scheme, especially in the context of package and module names containing certain meta-characters. For example, given the function name <code>"::f::g(int)::h::i(j::k)"</code>: does the signature start at the first or second left parenthesis?</p>
<p>This new naming scheme can be enabled or disabled using <a class="el" href="classmi_1_1neuraylib_1_1IMdl__configuration.html#ae383ac9ad48b23c85766347d25befd43" title="Defines whether encoded names are enabled. ">mi::neuraylib::IMdl_configuration::set_encoded_names_enabled()</a>.</p>
<p>The main idea is to use percent-encoding for certain characters when they do <em>not</em> appear as meta-character.</p>
<table class="doxtable">
<tr>
<th>Decoded character</th><th>Encoded character </th></tr>
<tr>
<td><code>(</code> </td><td><code>%28</code> </td></tr>
<tr>
<td><code>)</code> </td><td><code>%29</code> </td></tr>
<tr>
<td><code>&lt;</code></td><td><code>%3C</code> </td></tr>
<tr>
<td><code>&gt;</code></td><td><code>%3E</code> </td></tr>
<tr>
<td><code>,</code> </td><td><code>%2C</code> </td></tr>
<tr>
<td><code>:</code> </td><td><code>%3A</code> </td></tr>
<tr>
<td><code>$</code> </td><td><code>%24</code> </td></tr>
<tr>
<td><code>#</code> </td><td><code>%23</code> </td></tr>
<tr>
<td><code>?</code> </td><td><code>%3F</code> </td></tr>
<tr>
<td><code>@</code> </td><td><code>%40</code> </td></tr>
<tr>
<td><code>%</code> </td><td><code>%25</code> </td></tr>
</table>
<p>To avoid redundant representations, only upper-case letters are used as hexadecimal digits of encoded characters. All characters not listed in the table above are never encoded.</p>
<p>Encoding these characters when they do <em>not</em> appear as meta-characters avoids the known ambiguities. With encoded names enabled, the example from above would be either <code>"::f::g(int%29::h::i%28j::k)"</code> (if the signature starts at the first left parenthesis) or <code>"::f::g%28int%29::h::i(j::k)"</code> (if the signature starts at the second left parenthesis).</p>
<p>An important consequence from resolving such ambiguities is the fact that it is always possible to decode an encoded name, whereas (in general) it is <em>not</em> possible to encode a name without context. Therefore, you should use encoded names as much as possible, and use decoded names <em>only</em> e.g. for display purposes.</p>
<dl class="section note"><dt>Note</dt><dd>If encoded names are enabled, then all DB names of modules, material and function definitions, their MDL names and simple names, and all MDL-related type names in the API are encoded; exceptions from this rule are explicitly documented. One such exception are the functions <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a8ff441870d2f259ae17715a385bc690f" title="Decodes a DB or MDL name. ">mi::neuraylib::IMdl_factory::decode_name()</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a5270770f64b02463aeac5df668b9c85b" title="Encodes a DB or MDL module name. ">mi::neuraylib::IMdl_factory::encode_module_name()</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a13c93658b0fea8078719d642a1801bdb" title="Encodes a DB or MDL function or material definition name. ">mi::neuraylib::IMdl_factory::encode_function_definition_name()</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a76cf47f4113d4109071e7d576507689c" title="Encodes an MDL type name. ">mi::neuraylib::IMdl_factory::encode_type_name()</a>, which help with decoding and encoding of names.</dd></dl>
<p>Enabling the encoded names also activates another change for material definitions: Their name also includes the signature (as for function definitions). This avoids ambiguities between names of modules and material definitions.</p>
<h2><a class="anchor" id="mi_mdl_db_names"></a>
DB names</h2>
<p>DB names are the most prominent type of names for MDL elements in the MDL SDK API. These type names are mainly used to identify MDL elements, in particular, to access them in the database.</p>
<p>The DB names for modules as well as for function and material definitions have an <code>"mdl"</code> or <code>"mdle"</code> prefix. This prefix is also used for automatically created function calls and materials instances used as parameter defaults. User-generated function calls, material instances, and compiled materials might use the prefix, but are not required to.</p>
<p>If the interface of an MDL element is given, then its DB name can be obtained from <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a0db9733124735032153593b1a6710ebb" title="Returns the name of a database element. ">mi::neuraylib::ITransaction::name_of()</a>.</p>
<table class="doxtable">
<tr>
<th>MDL entity </th><th>Encoded names disabled </th><th>Encoded names enabled  </th></tr>
<tr>
<td>module with builtins </td><td><code>mdl::&lt;builtins&gt;</code> </td><td><code>mdl::%3Cbuiltins%3E</code>  </td></tr>
<tr>
<td>user module </td><td><code>mdl::foo</code> </td><td><code>mdl::foo</code>  </td></tr>
<tr>
<td>MDLE module (Linux) </td><td><code>mdle::/path/to/bar.mdle</code>&#160;&#160;&#160;(1) </td><td><code>mdle::/path/to/bar.mdle</code>&#160;&#160;&#160;(1)  </td></tr>
<tr>
<td>MDLE module (Windows) </td><td><code>mdle::/C:/path/to/bar.mdle</code>&#160;&#160;&#160;(1) </td><td><code>mdle::/C%3A/path/to/bar.mdle</code>&#160;&#160;&#160;(1)  </td></tr>
<tr>
<td>builtin function </td><td><code>mdl::operator+(float,float)</code> </td><td><code>mdl::operator+(float,float)</code>  </td></tr>
<tr>
<td>builtin function, affected by encoding </td><td><code>mdl::operator&lt;&lt;(int,int)</code> </td><td><code>mdl::operator%3%3C(int,int)</code>  </td></tr>
<tr>
<td>builtin template-like function </td><td><code>mdl::operator?(bool,&lt;0&gt;,&lt;0&gt;)</code> </td><td><code>mdl::operator%3F(bool,%3C0%3E,%3C0%3E)</code>  </td></tr>
<tr>
<td>user function </td><td><code>mdl::foo::my_func(color)</code> </td><td><code>mdl::foo::my_func(color)</code>  </td></tr>
<tr>
<td>user function, module name affected by encoding </td><td><code>mdl::foo,bar::my_func(::foo,bar::my_enum)</code> </td><td><code>mdl::foo%2Cbar::my_func(::foo%2Cbar::my_enum)</code>  </td></tr>
<tr>
<td>user material </td><td><code>mdl::foo::my_mat</code> </td><td><code>mdl::foo::my_mat(color)</code>  </td></tr>
</table>
<p>(1) Note that the DB name for an MDLE module is <em>not</em> the same as the filename (modulo <code>"mdle::"</code> prefix), in particular on Windows (slash before drive letter, encoded colon after drive letter, slashes vs backslashes). Even on non-Windows systems there might be differences due to filename normalization. Use <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a72a27c9e0d66e79391ff9a8e3ce4a119" title="Returns the DB name for the MDL name of a module (or file path for MDLE modules). ...">mi::neuraylib::IMdl_factory::get_db_module_name()</a> to obtain the DB name for an MDLE module from the filename.</p>
<h2><a class="anchor" id="mi_mdl_mdl_names"></a>
MDL names</h2>
<p>MDL names are useful for display purposes. They are similar to the DB names, except that they lack the <code>"mdl"</code> or <code>"mdle"</code> prefix. Entities from the <code></code>::&lt;builtins&gt; module also lack the leading scope <code>"::"</code>.</p>
<p>The interfaces for modules as well as for function and material definitions provide methods to obtain the MDL name, see <a class="el" href="classmi_1_1neuraylib_1_1IModule.html#a14af9a039c9933987211937acb562352" title="Returns the MDL name of the module. ">mi::neuraylib::IModule::get_mdl_name()</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a0fb5559a03a1213778934f7bd81d2657" title="Returns the MDL name of the function definition. ">mi::neuraylib::IFunction_definition::get_mdl_name()</a>. The corresponding DB name can be obtained from an MDL name with the help of the methods <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a72a27c9e0d66e79391ff9a8e3ce4a119" title="Returns the DB name for the MDL name of a module (or file path for MDLE modules). ...">mi::neuraylib::IMdl_factory::get_db_module_name()</a> and <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a0b363e785c0406eb4bac2da4b928d898" title="Returns the DB name for the MDL name of an material or function definition. ">mi::neuraylib::IMdl_factory::get_db_definition_name()</a>. Note that there is no MDL name for function calls, material instances, or compiled materials.</p>
<p>For display purposes you might want to decode the MDL name using <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a8ff441870d2f259ae17715a385bc690f" title="Decodes a DB or MDL name. ">mi::neuraylib::IMdl_factory::decode_name()</a>.</p>
<table class="doxtable">
<tr>
<th>MDL entity </th><th>Encoded names disabled </th><th>Encoded names enabled  </th></tr>
<tr>
<td>module with builtins </td><td><code>::&lt;builtins&gt;</code> </td><td><code>::%3Cbuiltins%3E</code>  </td></tr>
<tr>
<td>user module </td><td><code>::foo</code> </td><td><code>::foo</code>  </td></tr>
<tr>
<td>MDLE module (Linux) </td><td><code>::/path/to/bar.mdle</code>&#160;&#160;&#160;(2) </td><td><code>::/path/to/bar.mdle</code>&#160;&#160;&#160;(2)  </td></tr>
<tr>
<td>MDLE module (Windows) </td><td><code>::/C:/path/to/bar.mdle</code>&#160;&#160;&#160;(2) </td><td><code>::/C%3A/path/to/bar.mdle</code>&#160;&#160;&#160;(2)  </td></tr>
<tr>
<td>builtin function </td><td><code>operator+(float,float)</code> </td><td><code>operator+(float,float)</code>  </td></tr>
<tr>
<td>builtin function, affected by encoding </td><td><code>operator&lt;&lt;(int,int)</code> </td><td><code>operator%3C%3C(int,int)</code>  </td></tr>
<tr>
<td>builtin template-like function </td><td><code>operator?(bool,&lt;0&gt;,&lt;0&gt;)</code> </td><td><code>operator%3F(bool,%3C0%3E,%3C0%3E)</code>  </td></tr>
<tr>
<td>user function </td><td><code>::foo::my_func(color)</code> </td><td><code>::foo::my_func(color)</code>  </td></tr>
<tr>
<td>user function, module name affected by encoding </td><td><code>::foo,bar::my_func(::foo,bar::my_enum)</code> </td><td><code>::foo%2Cbar::my_func(::foo%2Cbar::my_enum)</code>  </td></tr>
<tr>
<td>user material </td><td><code>::foo::my_mat</code> </td><td><code>::foo::my_mat(color)</code>  </td></tr>
</table>
<p>(2) Note that the MDL name for an MDLE module is <em>not</em> the same as the filename (modulo <code>"::"</code> prefix), in particular on Windows (slash before drive letter, encoded colon after drive letter, slashes vs backslashes). Even on non-Windows systems there might be differences due to filename normalization.</p>
<h2><a class="anchor" id="mi_mdl_simple_mdl_names"></a>
Simple MDL names</h2>
<p>Simple MDL names are a variant of the MDL names above. They are used in a few places when the context is clear. Simple MDL names for modules lack the package name prefix including the scope separator. Simple MDL names for function, material, and annotation definitions lack the module name prefix including the scope separator and the signature suffix.</p>
<p>Note that due to function overloading, multiple functions within a module might share the same simple name.</p>
<p>The interfaces for modules as well as for function and material definitions provide methods to obtain the simple MDL name, see <a class="el" href="classmi_1_1neuraylib_1_1IModule.html#aeb6a43776d79dfc8d0560ecd68778394" title="Returns the simple MDL name of the module. ">mi::neuraylib::IModule::get_mdl_simple_name()</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a37a774c407dfd8f8be033de0e6e16cb1" title="Returns the simple MDL name of the function definition. ">mi::neuraylib::IFunction_definition::get_mdl_simple_name()</a>.</p>
<p>For display purposes you might want to decode the simple MDL name using <a class="el" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a8ff441870d2f259ae17715a385bc690f" title="Decodes a DB or MDL name. ">mi::neuraylib::IMdl_factory::decode_name()</a>.</p>
<table class="doxtable">
<tr>
<th>MDL entity </th><th>Encoded names disabled </th><th>Encoded names enabled  </th></tr>
<tr>
<td>module with builtins </td><td><code>&lt;builtins&gt;</code> </td><td><code>%3Cbuiltins%3E</code>  </td></tr>
<tr>
<td>user module </td><td><code>foo</code> </td><td><code>foo</code>  </td></tr>
<tr>
<td>MDLE module (Linux) </td><td><code>/path/to/bar.mdle</code>&#160;&#160;&#160;(3) </td><td><code>/path/to/bar.mdle</code>&#160;&#160;&#160;(3)  </td></tr>
<tr>
<td>MDLE module (Windows) </td><td><code>/C:/path/to/bar.mdle</code>&#160;&#160;&#160;(3) </td><td><code>/C%3A/path/to/bar.mdle</code>&#160;&#160;&#160;(3)  </td></tr>
<tr>
<td>builtin function </td><td><code>operator+</code> </td><td><code>operator+</code>  </td></tr>
<tr>
<td>builtin function, affected by encoding </td><td><code>operator&lt;&lt;</code> </td><td><code>operator%3C%3C</code>  </td></tr>
<tr>
<td>builtin template-like function </td><td><code>operator?</code> </td><td><code>operator%3F</code>  </td></tr>
<tr>
<td>user function </td><td><code>my_func</code> </td><td><code>my_func</code>  </td></tr>
<tr>
<td>user function, module name affected by encoding </td><td><code>my_func</code> </td><td><code>my_func</code>  </td></tr>
<tr>
<td>user material </td><td><code>my_mat</code> </td><td><code>my_mat</code>  </td></tr>
</table>
<p>(3) Note that the simple MDL name for an MDLE module is <em>not</em> the same as the filename, in particular on Windows (slash before drive letter, encoded colon after drive letter, slashes vs backslashes) Even on non-Windows systems there might be differences due to filename normalization.</p>
<h2><a class="anchor" id="mi_mdl_serialized_names"></a>
Serialized names</h2>
<p>Serialized names are identical to DB names with the exception of <a class="el" href="group__mi__neuray__mdl__elements.html#mi_neuray_mdl_template_like_function_definitions">Template-like function definitions</a>. For these functions, the serialized names have a suffix in angle brackets that contains additional information about the template parameters. This extra information is useful to reconstruct the correct template instance upon deserialization. See <a class="el" href="group__mi__neuray__mdl__elements.html#mi_neuray_mdl_template_like_function_definitions">Template-like function definitions</a> for an example of serialized names for each template-like function.</p>
<p>The methods <a class="el" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a4dc6943abfc6e7deadcb624963ee1221" title="Serializes the name of a function or material definition. ">mi::neuraylib::IMdl_impexp_api::serialize_function_name()</a>, <a class="el" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a1faa0ba46a2354cbce3d877e12fe787a" title="Deserializes the serialized name of a function or material definition (first overload) ...">mi::neuraylib::IMdl_impexp_api::deserialize_function_name()</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a6d6e94ea7764abf5613d445a4449b777" title="Deserializes the serialized name of a module. ">mi::neuraylib::IMdl_impexp_api::deserialize_module_name()</a> deal with serialized names.</p>
<p>Serialized names exist only if encoded names are enabled.</p>
<table class="doxtable">
<tr>
<th>MDL entity </th><th>Encoded names disabled </th><th>Encoded names enabled  </th></tr>
<tr>
<td>module with builtins </td><td>&mdash; </td><td><code>mdl::%3Cbuiltins%3E</code>  </td></tr>
<tr>
<td>user module </td><td>&mdash; </td><td><code>mdl::foo</code>  </td></tr>
<tr>
<td>MDLE module (Linux) </td><td>&mdash; </td><td><code>mdle::bar.mdle</code>&#160;&#160;&#160;(4)  </td></tr>
<tr>
<td>MDLE module (Windows) </td><td>&mdash; </td><td><code>mdle::bar.mdle</code>&#160;&#160;&#160;(5)  </td></tr>
<tr>
<td>builtin function </td><td>&mdash; </td><td><code>mdl::operator+(float,float)</code>  </td></tr>
<tr>
<td>builtin function, affected by encoding </td><td>&mdash; </td><td><code>mdl::operator%3C%3C(int,int)</code>  </td></tr>
<tr>
<td>builtin template-like function </td><td>&mdash; </td><td><code>mdl::operator%3F(bool,%3C0%3E,%3C0%3E)&lt;int&gt;</code>  </td></tr>
<tr>
<td>user function </td><td>&mdash; </td><td><code>mdl::foo::my_func(color)</code>  </td></tr>
<tr>
<td>user function, module name affected by encoding </td><td>&mdash; </td><td><code>mdl::foo%2Cbar::my_func(::foo%2Cbar::my_enum)</code>  </td></tr>
<tr>
<td>user material </td><td>&mdash; </td><td><code>mdl::foo::my_mat(color)</code>  </td></tr>
</table>
<p>(4) With an MDLE callback that strips all directory components during serialization (see <a class="el" href="classmi_1_1neuraylib_1_1IMdle__serialization__callback.html" title="Callback to map references to MDLE modules during serialization. ">mi::neuraylib::IMdle_serialization_callback</a>). <br/>
 (5) With an MDLE callback that strips all drive and directory components during serialization (see <a class="el" href="classmi_1_1neuraylib_1_1IMdle__serialization__callback.html" title="Callback to map references to MDLE modules during serialization. ">mi::neuraylib::IMdle_serialization_callback</a>).</p>
<h1><a class="anchor" id="mi_neuray_mdl_structs"></a>
Structs</h1>
<p>For each exported struct type function definitions for its constructors are created in the DB. There is a default constructor and a so-called elemental constructor which has a parameter for each field of the struct. The name of these constructors is the name of the struct type including the signature.</p>
<dl class="section user"><dt>Example</dt><dd>The MDL code <div class="fragment"><div class="line">export <span class="keyword">struct </span>Foo {</div>
<div class="line">    <span class="keywordtype">int</span> param_int;</div>
<div class="line">    <span class="keywordtype">float</span> param_float = 0;</div>
<div class="line">};</div>
</div><!-- fragment --> in a module <code>"mod_struct"</code> creates the following function definitions:<ul>
<li>a default constructor named <code>"mdl::mod_struct::Foo()"</code>,</li>
<li>an elemental constructor named <code>"mdl::mod_struct::Foo(int,float)"</code>, and</li>
</ul>
The elemental constructor has a parameter <code>"param_int"</code> of type <a class="el" href="classmi_1_1neuraylib_1_1IType__int.html" title="The type of kind int. ">mi::neuraylib::IType_int</a> and a parameter <code>"param_float"</code> of type <a class="el" href="classmi_1_1neuraylib_1_1IType__float.html" title="The type of kind float. ">mi::neuraylib::IType_float</a>. Both function definitions have the return type <a class="el" href="classmi_1_1neuraylib_1_1IType__struct.html" title="The type of kind struct. ">mi::neuraylib::IType_struct</a> with name <code>"::mod_struct::Foo"</code>.</dd></dl>
<p>In addition, for each exported struct type, and for each of its fields, a function definition for the corresponding member selection operator is created in the DB. The name of that function definition is obtained by concatenating the name of the struct type with the name of the field with an intervening dot, e.g., <code>"foo.param_int"</code>. The function definition has a single parameter <code>"s"</code> of the struct type and the corresponding field type as return type.</p>
<dl class="section user"><dt>Example</dt><dd>The MDL code <div class="fragment"><div class="line">export <span class="keyword">struct </span>Foo {</div>
<div class="line">    <span class="keywordtype">int</span> param_int;</div>
<div class="line">    <span class="keywordtype">float</span> param_float = 0;</div>
<div class="line">};</div>
</div><!-- fragment --> in a module <code>"mod_struct"</code> creates the two function definitions named <code>"mdl::struct::Foo.param_int(::struct::Foo)"</code> and <code>"mdl::struct::Foo.param_float(::struct::Foo)"</code> to represent the member selection operators <code>"Foo.param_int"</code> and <code>"Foo.param_float"</code>. The function definitions have a single parameter <code>"s"</code> of type <code>"mdl::struct::Foo"</code> and return type <a class="el" href="classmi_1_1neuraylib_1_1IType__int.html" title="The type of kind int. ">mi::neuraylib::IType_int</a> and <a class="el" href="classmi_1_1neuraylib_1_1IType__float.html" title="The type of kind float. ">mi::neuraylib::IType_float</a>, respectively.</dd></dl>
<h1><a class="anchor" id="mi_neuray_mdl_arrays"></a>
Arrays</h1>
<p>In contrast to struct types which are explicitly declared there are infinitely many array types (considering pairs of element type and array length). Deferred-sized arrays make the situation even more complicated. Each of these array types would have its own constructor and index operator. Therefore, template-like functions definitions are used in the context of arrays to satisfy this need. See the next section for details</p>
<h1><a class="anchor" id="mi_neuray_mdl_template_like_function_definitions"></a>
Template-like function definitions</h1>
<p>Usually, function definitions have a fixed set of parameter types and a fixed return type. Exceptions of this rule are the following five function definitions which rather have the character of template functions with generic parameter and/or return types.</p>
<ul>
<li>the array constructor (<a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51aa80481ce4d07e5f7ec2111ebd0184078" title="The array constructor. See Array constructor. ">mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR</a>),</li>
<li>the array length operator (<a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a17c1b618b2e39813c07589e6c0656b0a" title="The array length operator. See Array length operator. ">mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH</a>),</li>
<li>the array index operator (<a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51adb147fe184acb3e3227326f518572cf3" title="The array index operator. See Array index operator. ">mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX</a>),</li>
<li>the ternary operator (<a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a699ce5f7b408f7f7b42fd8ba772657b2" title="The ternary operator (conditional). See Ternary operator. ">mi::neuraylib::IFunction_definition::DS_TERNARY</a>), and</li>
<li>the cast operator (<a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a8b3a7463c932be4d3bdc2cc7b40d8ef3" title="The cast operator. See Cast operator. ">mi::neuraylib::IFunction_definition::DS_CAST</a>).</li>
</ul>
<p>The MDL and DB names of these function definitions use <code>"&lt;0&gt;"</code> or <code>"T"</code> to indicate such a generic parameter or return type. When querying the actual type, <a class="el" href="classmi_1_1neuraylib_1_1IType__int.html" title="The type of kind int. ">mi::neuraylib::IType_int</a> (arbitrary choice) is returned for lack of a better alternative.</p>
<p>When creating function calls from such template-like function definitions, the parameter and return types are fixed, i.e., the function call itself has concrete parameter and return types as usual, and has no template-like behavior as the definition from which it was created. This implies that, for example, after creating a ternary operator on floats, you cannot set its arguments to expressions of a different type than float (this would require creation of another function call with the desired parameter types).</p>
<p>Template-like functions are those functions for which serialized name and DB name differ (see <a class="el" href="group__mi__neuray__mdl__elements.html#mi_mdl_names">Naming scheme for MDL elements</a>).</p>
<p>More details about the five different template-like function definitions follow.</p>
<h2><a class="anchor" id="mi_neuray_mdl_array_constructor"></a>
Array constructor</h2>
<p>Semantic: <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51aa80481ce4d07e5f7ec2111ebd0184078" title="The array constructor. See Array constructor. ">mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR</a> <br/>
 DB name (encoded names disabled/enabled): <code>"mdl::T[](...)"</code> <br/>
 MDL name (encoded names disabled/enabled): <code>"T[](...)"</code> <br/>
 Serialized named (encoded names enabled, example): <code>"mdl::T[](...)&lt;int,42&gt;"</code> </p>
<p>The following requirements apply when creating function calls of the array constructor:</p>
<ul>
<li>the expression list for the arguments contains a non-zero number of arguments named "0", "1", and so on,</li>
<li>all arguments must be of the same type (which is the element type of the constructed array).</li>
</ul>
<p>The suffix for the serialized name has two arguments, the type name of the element type, and the size of the array.</p>
<h2><a class="anchor" id="mi_neuray_mdl_array_length_operator"></a>
Array length operator</h2>
<p>Semantic: <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a17c1b618b2e39813c07589e6c0656b0a" title="The array length operator. See Array length operator. ">mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH</a> <br/>
 DB name (encoded names disabled): <code>"mdl::operator_len(&lt;0&gt;[])"</code> <br/>
 DB name (encoded names enabled): <code>"mdl::operator_len(%3C0%3E[])"</code> <br/>
 MDL name (encoded names disabled): <code>"operator_len(&lt;0&gt;[])"</code> <br/>
 MDL name (encoded names enabled): <code>"operator_len(%3C0%3E[])"</code> <br/>
 Serialized name (encoded names enabled, example): <code>"operator_len(%3C0%3E[])&lt;float[42]&gt;"</code> </p>
<p>The following requirements apply when creating function calls of the array length operator:</p>
<ul>
<li>the expression list for the arguments contains a single expression named <code>"a"</code> of type <a class="el" href="classmi_1_1neuraylib_1_1IType__array.html" title="The type of kind array. ">mi::neuraylib::IType_array</a>.</li>
</ul>
<p>The suffix for the serialized name has one argument, the type name of the array.</p>
<h2><a class="anchor" id="mi_neuray_mdl_array_index_operator"></a>
Array index operator</h2>
<p>Semantic: <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51adb147fe184acb3e3227326f518572cf3" title="The array index operator. See Array index operator. ">mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX</a> <br/>
 DB name (encoded names disabled): <code>"mdl::operator[](&lt;0&gt;[],int)"</code> <br/>
 DB name (encoded names enabled): <code>"mdl::operator[](%3C0%3E[],int)"</code> <br/>
 MDL name (encoded names disabled): <code>"operator[](&lt;0&gt;[],int)"</code> <br/>
 MDL name (encoded names enabled): <code>"operator[](%3C0%3E[],int)"</code> <br/>
 Serialized name (encoded names enabled, example): <code>"operator[](%3C0%3E[],int)&lt;float[42]&gt;"</code> </p>
<p>Despite its name, the array index operator can also be used on vectors and matrices.</p>
<p>The following requirements apply when creating function calls of the array index operator:</p>
<ul>
<li>the expression list for the arguments contains two expressions named <code>"a"</code> and <code>"i"</code>, respectively,</li>
<li>the expression named <code>"a"</code> is of type <a class="el" href="classmi_1_1neuraylib_1_1IType__array.html" title="The type of kind array. ">mi::neuraylib::IType_array</a>, <a class="el" href="classmi_1_1neuraylib_1_1IType__vector.html" title="The type of kind vector. ">mi::neuraylib::IType_vector</a>, or <a class="el" href="classmi_1_1neuraylib_1_1IType__matrix.html" title="The type of kind matrix. ">mi::neuraylib::IType_matrix</a>, and</li>
<li>the expression named <code>"i"</code> is of type <a class="el" href="classmi_1_1neuraylib_1_1IType__int.html" title="The type of kind int. ">mi::neuraylib::IType_int</a>.</li>
</ul>
<p>The suffix for the serialized name has one argument, the type name of the array, vector, or matrix.</p>
<h2><a class="anchor" id="mi_neuray_mdl_ternary_operator"></a>
Ternary operator</h2>
<p>Semantic: <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a699ce5f7b408f7f7b42fd8ba772657b2" title="The ternary operator (conditional). See Ternary operator. ">mi::neuraylib::IFunction_definition::DS_TERNARY</a> <br/>
 DB name (encoded names disabled): <code>"mdl::operator?(bool,&lt;0&gt;,&lt;0&gt;)"</code> <br/>
 DB name (encoded names enabled): <code>"mdl::operator%3F(bool,%3C0%3E,%3C0%3E)"</code> <br/>
 MDL name (encoded names disabled): <code>"operator?(bool,&lt;0&gt;,&lt;0&gt;)"</code> <br/>
 MDL name (encoded names enabled): <code>"operator%3F(bool,%3C0%3E,%3C0%3E)"</code> <br/>
 Serialized name (encoded names enabled, example): <code>"operator%3F(bool,%3C0%3E,%3C0%3E)&lt;float&gt;"</code> </p>
<p>The following requirements apply when creating function calls of the ternary operator:</p>
<ul>
<li>the expression list for the arguments contains three expressions named <code>"cond"</code>, <code>"true_exp"</code>, and <code>"false_exp"</code>, respectively,</li>
<li>the expression named <code>"cond"</code> is of type <a class="el" href="classmi_1_1neuraylib_1_1IType__bool.html" title="The type of kind bool. ">mi::neuraylib::IType_bool</a>, and</li>
<li>the two other expressions are of the same type.</li>
</ul>
<p>The suffix for the serialized name has one argument, the type name of the <code>"true_exp"</code> expression (which is equal to the type name of the <code>"false_exp"</code> expression).</p>
<h2><a class="anchor" id="mi_neuray_mdl_cast_operator"></a>
Cast operator</h2>
<p>Semantic: <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51a8b3a7463c932be4d3bdc2cc7b40d8ef3" title="The cast operator. See Cast operator. ">mi::neuraylib::IFunction_definition::DS_CAST</a> <br/>
 DB name (encoded names disabled): <code>"mdl::operator_cast(&lt;0&gt;)"</code> <br/>
 DB name (encoded names enabled): <code>"mdl::operator_cast(%3C0%3E)"</code> <br/>
 MDL name (encoded names disabled): <code>"operator_cast(&lt;0&gt;)"</code> <br/>
 MDL name (encoded names enabled): <code>"operator_cast(%3C0%3E)"</code> <br/>
 Serialized name (encoded names enabled, example): <code>"operator_cast(%3C0%3E)&lt;::foo::my_enum,::bar::my_enum&gt;"</code> </p>
<p>The following requirements apply when creating function calls of the ternary operator:</p>
<ul>
<li>the expression list for the arguments contains <em>two</em> expressions named <code>"cast"</code> and <code>"cast_return"</code>, respectively,</li>
<li>the expression named <code>"cast"</code> is of an arbitrary type (this is the intended argument of the function call),</li>
<li>the type of the expression named <code>"cast_return"</code> specifies the return type of the function call (no frequency qualifiers; the expression itself is not used), and</li>
<li>the types of <code>"cast"</code> and <code>"cast_return"</code> are compatible.</li>
</ul>
<p>The suffix for the serialized name has two arguments, the type name of the <code>"cast"</code> expression, followed by the type name of the <code>"cast_return"</code> expression.</p>
<p>See also <a class="el" href="classmi_1_1neuraylib_1_1IExpression__factory.html#a772d9d7b9070d6cb4621cb8a266473d7" title="Returns an expression which casts the source expression to the target_type. ">mi::neuraylib::IExpression_factory::create_cast()</a>.</p>
<h1><a class="anchor" id="mi_mdl_materials_are_functions"></a>
Materials are functions</h1>
<p>From an MDL language point of view [<a class="el" href="mi_neuray_biblio.html#MDLLS">MDLLS</a>], materials look quite similar to functions with the <code>material</code> struct as return type. However, in the past the MDL SDK API used separate interfaces like <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a> and <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> for materials, in contrast to <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a> for functions (although these interfaces are quite similar). This required that code that acts in a similar way on both, functions and materials, needed to be written twice.</p>
<p>Nowadays, it is possible to treat materials as functions, i.e., it is possible to use <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a> instead of <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a>, and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a> instead of <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a>. This allows to write code that acts on both, functions and materials, just once. The only exception is the method <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#a12f0f87c5d139d452777b3154796eb52" title="Creates a compiled material. ">mi::neuraylib::IMaterial_instance::create_compiled_material()</a>, which still requires to use the <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> interface.</p>
<p>This feature is now enabled by default. It can still be disabled by <a class="el" href="classmi_1_1neuraylib_1_1IMdl__configuration.html#a3246903e423b0d132c26d4ba3fdf30b2" title="Defines whether materials are treated as functions. ">mi::neuraylib::IMdl_configuration::set_materials_are_functions()</a>, but this possibility will be deprecated and removed in a future release. Likewise for the interfaces <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a> and almost all methods of <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> (one exception is <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#a12f0f87c5d139d452777b3154796eb52" title="Creates a compiled material. ">mi::neuraylib::IMaterial_instance::create_compiled_material()</a>).</p>
<p>It is recommended to avoid using <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__definition.html" title="This interface represents a material definition. ">mi::neuraylib::IMaterial_definition</a> and <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a> as much as possible in new code, and eventually to replace usage of these interfaces in existing code. If <a class="el" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#a12f0f87c5d139d452777b3154796eb52" title="Creates a compiled material. ">mi::neuraylib::IMaterial_instance::create_compiled_material()</a> is to be used, it is recommended to obtain that interface right before that call, and to use it only for that call itself.</p>
<h2><a class="anchor" id="mi_mdl_materials_are_functions_api_changes"></a>
API Changes when materials are functions</h2>
<p>Treating materials as functions comes with a few API changes that need to be takes into account. Code shared between different applications, i.e., in plugins, should be able to handle both settings.</p>
<ul>
<li><b>Values returned by <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html#ab504af66b7cade58614fcc57d923ad1b" title="Indicates the actual scene element represented by interfaces derived from this interface. ">mi::neuraylib::IScene_element::get_element_type()</a> (and derived interfaces)</b> <br/>
 <br/>
 The method <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html#ab504af66b7cade58614fcc57d923ad1b" title="Indicates the actual scene element represented by interfaces derived from this interface. ">mi::neuraylib::IScene_element::get_element_type()</a> returns <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685ae31379c44660127c403239db8d96c676" title="mi::neuraylib::IFunction_definition ">mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION</a> instead of <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a80d0a33d09e51fecf8e36ad97f2eadb0" title="mi::neuraylib::IMaterial_definition ">mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION</a>. The value <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a80d0a33d09e51fecf8e36ad97f2eadb0" title="mi::neuraylib::IMaterial_definition ">mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION</a> is only returned by <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html#ab504af66b7cade58614fcc57d923ad1b" title="Indicates the actual scene element represented by interfaces derived from this interface. ">mi::neuraylib::IMaterial_definition::get_element_type()</a> (for backward compatibility), but no longer by its base class <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html" title="Common base interface for all scene elements. ">mi::neuraylib::IScene_element</a>. <br/>
 <br/>
 Similarly, the method <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html#ab504af66b7cade58614fcc57d923ad1b" title="Indicates the actual scene element represented by interfaces derived from this interface. ">mi::neuraylib::IScene_element::get_element_type()</a> returns <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a04089d8928100713e706fca2baf92a33" title="mi::neuraylib::IFunction_call ">mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL</a> instead of <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a8b3e7d0518f089ad935f994c8b7e8b69" title="mi::neuraylib::IMaterial_instance ">mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE</a>. The value <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a8b3e7d0518f089ad935f994c8b7e8b69" title="mi::neuraylib::IMaterial_instance ">mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE</a> is only returned by <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html#ab504af66b7cade58614fcc57d923ad1b" title="Indicates the actual scene element represented by interfaces derived from this interface. ">mi::neuraylib::IMaterial_instance::get_element_type()</a> (for backward compatibility), but no longer by its base class <a class="el" href="classmi_1_1neuraylib_1_1IScene__element.html" title="Common base interface for all scene elements. ">mi::neuraylib::IScene_element</a>. <br/>
 <br/>
 As a consequence, <a class="el" href="classmi_1_1neuraylib_1_1Definition__wrapper.html#af68ac0c3f111da7d9743b0c2ea3ab2e6" title="Indicates whether the definition wrapper acts on a material definition or on a function definition...">mi::neuraylib::Definition_wrapper::get_type()</a> and <a class="el" href="classmi_1_1neuraylib_1_1Definition__wrapper.html#a46124e15d7202138b7917a0594fa8194" title="Get the element type. ">mi::neuraylib::Definition_wrapper::get_element_type()</a> only return <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685ae31379c44660127c403239db8d96c676" title="mi::neuraylib::IFunction_definition ">mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION</a>. Similarly, <a class="el" href="classmi_1_1neuraylib_1_1Argument__editor.html#a9f8b7e81161898b23bf9271a9f76ee0a" title="Indicates whether the argument editor acts on a material instance or on a function call...">mi::neuraylib::Argument_editor::get_type()</a> and <a class="el" href="classmi_1_1neuraylib_1_1Argument__editor.html#a0b330fe46dbb74bb211aed63ada12ae9" title="Get the element type. ">mi::neuraylib::Argument_editor::get_element_type()</a> only return <a class="el" href="group__mi__neuray__scene__element.html#gga5c486d4da65090282b44a16ea3f1c685a04089d8928100713e706fca2baf92a33" title="mi::neuraylib::IFunction_call ">mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL</a>.</li>
</ul>
<ul>
<li><b>Interface queries to distinguish functions and materials</b> <br/>
 <br/>
 Interface queries like <a class="el" href="classmi_1_1base_1_1IInterface.html#a86453facde792c70a46741cc206f6894" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface&lt;mi::neuraylib::IFunction_definition&gt;()</a> can no longer be used to distinguish functions and materials. Note that such queries might occur inside other template inline methods, e.g., they occur as part of <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">mi::neuraylib::ITransaction::access&lt;mi::neuraylib::IFunction_definition&gt;()</a>. The recommended way to do this is using <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#af29d387193be06f9f216870072872cbe" title="Indicates whether the definition represents a material. ">mi::neuraylib::IFunction_definition::is_material()</a>. Similarly for <a class="el" href="classmi_1_1base_1_1IInterface.html#a86453facde792c70a46741cc206f6894" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface&lt;mi::neuraylib::IFunction_call&gt;()</a> and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html#aab7659c84b799fe2c9635a96e4897b93" title="Indicates whether the call represents a material instance. ">mi::neuraylib::IFunction_call::is_material()</a>.</li>
</ul>
<ul>
<li><b>Type names passed to <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a470eb1b7674345c4669bd9faff1029d3" title="Returns scene elements of a subgraph originating at a given scene element. ">mi::neuraylib::ITransaction::list_elements()</a></b> <br/>
 <br/>
 The method <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#a470eb1b7674345c4669bd9faff1029d3" title="Returns scene elements of a subgraph originating at a given scene element. ">mi::neuraylib::ITransaction::list_elements()</a> will not return any hits for type names <code>"Material_definition"</code> and <code>"Material_instance"</code>. Use the type names <code>"Function_definition"</code> and <code>"Function_call"</code> instead, and, if necessary, <a class="el" href="classmi_1_1neuraylib_1_1IFunction__definition.html#af29d387193be06f9f216870072872cbe" title="Indicates whether the definition represents a material. ">mi::neuraylib::IFunction_definition::is_material()</a> and <a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html#aab7659c84b799fe2c9635a96e4897b93" title="Indicates whether the call represents a material instance. ">mi::neuraylib::IFunction_call::is_material()</a> to discriminate the results. </li>
</ul>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga5e91f00d174ec5630869ebe156419d09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mi__neuray__mdl__elements.html#ga5e91f00d174ec5630869ebe156419d09">mi::neuraylib::Material_opacity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The compiled material's opacity. </p>
<p>See <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html#ae68ae1cb285ef8055751b69643bae57c" title="Returns the opacity of the material. ">mi::neuraylib::ICompiled_material::get_opacity()</a> and <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html#abc6ac1f0441697101c00877b2d9a1e42" title="Returns the surface opacity of the material by checking, if a transmissive BSDF is present in the sur...">mi::neuraylib::ICompiled_material::get_surface_opacity()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga5e91f00d174ec5630869ebe156419d09af39122f493e2661c11dff5e216a0b182"></a>OPACITY_OPAQUE</em>&nbsp;</td><td class="fielddoc">
<p>material is opaque </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e91f00d174ec5630869ebe156419d09a0b348a2fb9b931c37faadfb447d5e8d8"></a>OPACITY_TRANSPARENT</em>&nbsp;</td><td class="fielddoc">
<p>material is transparent </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5e91f00d174ec5630869ebe156419d09a682c0e533a9724fa6e8089971ccc60bb"></a>OPACITY_UNKNOWN</em>&nbsp;</td><td class="fielddoc">
<p>material might be transparent </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga4e2cebe47d60cf89b56196471b9ec162"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mi__neuray__mdl__elements.html#ga4e2cebe47d60cf89b56196471b9ec162">mi::neuraylib::Material_slot</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Material slots identify parts of a compiled material. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a> and <a class="el" href="classmi_1_1neuraylib_1_1ICompiled__material.html#add323fa76aa11b71829ebfc0ada40f1b" title="Returns the hash of a particular material slot. ">mi::neuraylib::ICompiled_material::get_slot_hash()</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162aa9723dd0385d5c2c72d00df154aeb0cd"></a>SLOT_THIN_WALLED</em>&nbsp;</td><td class="fielddoc">
<p>Slot thin_walled. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a95356115b56fa4672f7e57a887261186"></a>SLOT_SURFACE_SCATTERING</em>&nbsp;</td><td class="fielddoc">
<p>Slot surface.scattering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162addda6e4a2a88fcd9c9606685e891f2e5"></a>SLOT_SURFACE_EMISSION_EDF_EMISSION</em>&nbsp;</td><td class="fielddoc">
<p>Slot surface.emission.emission. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a3f0b5973556604e36dcfd9addbc8f7a0"></a>SLOT_SURFACE_EMISSION_INTENSITY</em>&nbsp;</td><td class="fielddoc">
<p>Slot surface.emission.intensity. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162af1b8a4bea1c95adcda6a5573d2cc6301"></a>SLOT_SURFACE_EMISSION_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Slot surface.emission.mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a1ef3c4a0f4a892679f761d38aa0853d9"></a>SLOT_BACKFACE_SCATTERING</em>&nbsp;</td><td class="fielddoc">
<p>Slot backface.scattering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162abb84473e252871614ad2aba0103a884f"></a>SLOT_BACKFACE_EMISSION_EDF_EMISSION</em>&nbsp;</td><td class="fielddoc">
<p>Slot backface.emission.emission. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a022577607f0a7d10583a937637448d0a"></a>SLOT_BACKFACE_EMISSION_INTENSITY</em>&nbsp;</td><td class="fielddoc">
<p>Slot backface.emission.intensity. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162ad4bd129833381c46ff60f1b2ae7cc4cb"></a>SLOT_BACKFACE_EMISSION_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Slot backface.emission.mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a710f8b080ecb835a935d8628603711a3"></a>SLOT_IOR</em>&nbsp;</td><td class="fielddoc">
<p>Slot ior. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162ae7b8c1f175b3f4667e1e95d67dc195e2"></a>SLOT_VOLUME_SCATTERING</em>&nbsp;</td><td class="fielddoc">
<p>Slot volume.scattering. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162aaa882cd2014f15517554cb703778b112"></a>SLOT_VOLUME_ABSORPTION_COEFFICIENT</em>&nbsp;</td><td class="fielddoc">
<p>Slot volume.absorption_coefficient. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162af4f26fff6e922e62749eb67995722e99"></a>SLOT_VOLUME_SCATTERING_COEFFICIENT</em>&nbsp;</td><td class="fielddoc">
<p>Slot volume.scattering_coefficient. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a713485357fe1774bfdb93b97e54f340b"></a>SLOT_GEOMETRY_DISPLACEMENT</em>&nbsp;</td><td class="fielddoc">
<p>Slot geometry.displacement. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162abdea8ac97d995e303c38b00cff9fb50e"></a>SLOT_GEOMETRY_CUTOUT_OPACITY</em>&nbsp;</td><td class="fielddoc">
<p>Slot geometry.cutout_opacity. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a8500bcd1983247b7014028f73b31c013"></a>SLOT_GEOMETRY_NORMAL</em>&nbsp;</td><td class="fielddoc">
<p>Slot geometry.normal. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162aac5dd6fbad07453b6c05f2404f1ea486"></a>SLOT_HAIR</em>&nbsp;</td><td class="fielddoc">
<p>Slot hair. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162a54b9af4f48afe62567b3b03b03fc586f"></a>SLOT_FIRST</em>&nbsp;</td><td class="fielddoc">
<p>First slot. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga4e2cebe47d60cf89b56196471b9ec162ad9e9c11a53ef2eb55a674a3ad2591202"></a>SLOT_LAST</em>&nbsp;</td><td class="fielddoc">
<p>Last slot. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga8ccced0757d210d79f0308ade130ae39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__mi__neuray__mdl__elements.html#ga8ccced0757d210d79f0308ade130ae39">mi::neuraylib::Mdl_repair_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Options for repairing function calls. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1IFunction__call.html#a61ab23720c612125e8e38e1b8dac9ae5" title="Attempts to repair an invalid function call. ">mi::neuraylib::IFunction_call::repair()</a>. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga8ccced0757d210d79f0308ade130ae39a79a8d7ced4ce778f05446a24799a90a2"></a>MDL_REPAIR_DEFAULT</em>&nbsp;</td><td class="fielddoc">
<p>Default mode, do not alter any inputs. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8ccced0757d210d79f0308ade130ae39a5077f357fe88d8c9474d8ef1684e73c0"></a>MDL_REMOVE_INVALID_ARGUMENTS</em>&nbsp;</td><td class="fielddoc">
<p>Remove an invalid call attached to an argument. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga8ccced0757d210d79f0308ade130ae39a9e284e783a70e3cce8bf364a7860dca6"></a>MDL_REPAIR_INVALID_ARGUMENTS</em>&nbsp;</td><td class="fielddoc">
<p>Attempt to repair invalid calls attached to an argument. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
