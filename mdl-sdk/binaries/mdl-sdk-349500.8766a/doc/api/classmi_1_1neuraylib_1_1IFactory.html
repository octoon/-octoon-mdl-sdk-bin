<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>mi::neuraylib::IFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmi_1_1neuraylib_1_1IFactory.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmi_1_1neuraylib_1_1IFactory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mi::neuraylib::IFactory Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__mi__neuray__types.html">Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This API component allows the creation, assignment, and cloning of instances of types.  
 <a href="classmi_1_1neuraylib_1_1IFactory.html#details"><span class="morelink">More...</span></a></p>
<div class="dynheader">
Inheritance diagram for mi::neuraylib::IFactory:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmi_1_1neuraylib_1_1IFactory.png" usemap="#mi::neuraylib::IFactory_map" alt=""/>
  <map id="mi::neuraylib::IFactory_map" name="mi::neuraylib::IFactory_map">
<area href="classmi_1_1base_1_1Interface__declare.html" alt="mi::base::Interface_declare&lt; 0x8afad838, 0xe597, 0x4a81, 0x92, 0x34, 0x51, 0xfe, 0xa4, 0xff, 0x04, 0x31 &gt;" shape="rect" coords="0,56,632,80"/>
<area href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. " alt="mi::base::IInterface" shape="rect" coords="0,0,632,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acd66a49233429885b068b149374201a2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2">Assign_result</a> { <br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a34155b212d4342942ff5885043b157af">NULL_POINTER</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a587d717a2e1f00abe19425279472ac97">STRUCTURAL_MISMATCH</a> = 2, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a67fed1291b503ba7783d7415d7e304ec">NO_CONVERSION</a> = 4, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a9bedd0b35026b9a8493415e9fbaa7415">TARGET_KEY_MISSING</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a955259464ec92228f39c408702a7991e">SOURCE_KEY_MISSING</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a0027293cd9173c10d5719a6aca202b5e">DIFFERENT_COLLECTIONS</a> = 32, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2af686ce8bab762ac42214e7cfa82facc4">NON_IDATA_VALUES</a> = 64, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a80d0156a03cc7c12974594fc9e972b53">INCOMPATIBLE_POINTER_TYPES</a> = 128, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a5e4106d4385e53919593f4a0ee66e058">DEEP_ASSIGNMENT_TO_CONST_POINTER</a> = 256, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2aad14ce6dafe912b121fcd644a0adc04f">INCOMPATIBLE_PRIVACY_LEVELS</a> = 1024, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a53f242bcff8b93e1e6f56be61898a877">INCOMPATIBLE_ENUM_TYPES</a> = 2048, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2afbbf5b90b99b427ef1098a1273124860">INCOMPATIBLE_OPTIONS</a> = 4096
<br/>
 }</td></tr>
<tr class="memdesc:acd66a49233429885b068b149374201a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum represents possible events that can happen during assignment of types.  <a href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:acd66a49233429885b068b149374201a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92929d716d06ab9a5c8ae229a2595d23"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23">Assign_clone_options</a> { <br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23a27a15c74cdf0cd8ba78656fc1d3a2fb9">DEEP_ASSIGNMENT_OR_CLONE</a> = 1, 
<br/>
&#160;&#160;<a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23ab3a2fb62c8f07533bb0b949dfad0e8f8">FIX_SET_OF_TARGET_KEYS</a> = 4
<br/>
 }</td></tr>
<tr class="memdesc:a92929d716d06ab9a5c8ae229a2595d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This enum represents various options for the assignment or cloning of types.  <a href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a92929d716d06ab9a5c8ae229a2595d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x8afad838, 0xe597, 0x4a81, 0x92, 0x34, 0x51, 0xfe, 0xa4, 0xff, 0x04, 0x31 &gt;</a></td></tr>
<tr class="memitem:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Interface__declare.html">Interface_declare</a>&lt; id1, <br class="typebreak"/>
id2, id3, id4, id5, id6, id7, <br class="typebreak"/>
id8, id9, id10, id11, <br class="typebreak"/>
<a class="el" href="classmi_1_1base_1_1IInterface.html">IInterface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#aaa2da9cb0b963fed938e3e19dcb912cd">Self</a></td></tr>
<tr class="memdesc:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Own type.  <a href="#aaa2da9cb0b963fed938e3e19dcb912cd"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:aaa2da9cb0b963fed938e3e19dcb912cd inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Uuid__t.html">Uuid_t</a>&lt; id1, id2, id3, <br class="typebreak"/>
id4, id5, id6, id7, id8, id9, <br class="typebreak"/>
id10, id11 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#a7ab89c594dc3cbbbb9aeffaf33b72a52">IID</a></td></tr>
<tr class="memdesc:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the interface ID (IID) of this interface.  <a href="#a7ab89c594dc3cbbbb9aeffaf33b72a52"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a7ab89c594dc3cbbbb9aeffaf33b72a52 inherit pub_types_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmi_1_1base_1_1IInterface"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmi_1_1base_1_1IInterface')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmi_1_1base_1_1IInterface.html">mi::base::IInterface</a></td></tr>
<tr class="memitem:a2663c396bb90c34279751ed25e5da64b inherit pub_types_classmi_1_1base_1_1IInterface"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classmi_1_1base_1_1Uuid__t.html">Uuid_t</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1IInterface.html#a2663c396bb90c34279751ed25e5da64b">IID</a></td></tr>
<tr class="memdesc:a2663c396bb90c34279751ed25e5da64b inherit pub_types_classmi_1_1base_1_1IInterface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the interface ID (IID) of this interface.  <a href="#a2663c396bb90c34279751ed25e5da64b"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a2663c396bb90c34279751ed25e5da64b inherit pub_types_classmi_1_1base_1_1IInterface"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a953eb56b2d0902e7e21041fed5f6a801"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a953eb56b2d0902e7e21041fed5f6a801">create</a> (const char *type_name, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> argc=0, const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *argv[]=0)=0</td></tr>
<tr class="memdesc:a953eb56b2d0902e7e21041fed5f6a801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>type_name</code>.  <a href="#a953eb56b2d0902e7e21041fed5f6a801"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a953eb56b2d0902e7e21041fed5f6a801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a0b55aca1f645a1824c29b6f51e266"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae6a0b55aca1f645a1824c29b6f51e266"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#ae6a0b55aca1f645a1824c29b6f51e266">create</a> (const char *type_name, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> argc=0, const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *argv[]=0)</td></tr>
<tr class="memdesc:ae6a0b55aca1f645a1824c29b6f51e266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>type_name</code>.  <a href="#ae6a0b55aca1f645a1824c29b6f51e266"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae6a0b55aca1f645a1824c29b6f51e266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a229a76c22734b2606a088c8e5f522"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a93a229a76c22734b2606a088c8e5f522"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a93a229a76c22734b2606a088c8e5f522">create</a> ()</td></tr>
<tr class="memdesc:a93a229a76c22734b2606a088c8e5f522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an object of the type <code>T</code>.  <a href="#a93a229a76c22734b2606a088c8e5f522"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a93a229a76c22734b2606a088c8e5f522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c64c0fb4de3c547da110812f4b3544"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92c64c0fb4de3c547da110812f4b3544">assign_from_to</a> (const <a class="el" href="classmi_1_1IData.html">IData</a> *source, <a class="el" href="classmi_1_1IData.html">IData</a> *target, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> options=0)=0</td></tr>
<tr class="memdesc:a92c64c0fb4de3c547da110812f4b3544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the value(s) of <code>source</code> to <code>target</code>.  <a href="#a92c64c0fb4de3c547da110812f4b3544"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a92c64c0fb4de3c547da110812f4b3544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a3150c5320bea5d513be2f34e44288"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a67a3150c5320bea5d513be2f34e44288">clone</a> (const <a class="el" href="classmi_1_1IData.html">IData</a> *source, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> options=0)=0</td></tr>
<tr class="memdesc:a67a3150c5320bea5d513be2f34e44288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of a type.  <a href="#a67a3150c5320bea5d513be2f34e44288"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a67a3150c5320bea5d513be2f34e44288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1223297430e9d6713160427065e9922"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae1223297430e9d6713160427065e9922"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#ae1223297430e9d6713160427065e9922">clone</a> (const <a class="el" href="classmi_1_1IData.html">IData</a> *source, <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> options=0)</td></tr>
<tr class="memdesc:ae1223297430e9d6713160427065e9922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of a type.  <a href="#ae1223297430e9d6713160427065e9922"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae1223297430e9d6713160427065e9922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536a81de52cb591e78d23df4f661b2dc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a536a81de52cb591e78d23df4f661b2dc">compare</a> (const <a class="el" href="classmi_1_1IData.html">IData</a> *lhs, const <a class="el" href="classmi_1_1IData.html">IData</a> *rhs)=0</td></tr>
<tr class="memdesc:a536a81de52cb591e78d23df4f661b2dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>.  <a href="#a536a81de52cb591e78d23df4f661b2dc"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a536a81de52cb591e78d23df4f661b2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbcc47c00dd93ccd423b924c700ce9c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmi_1_1IString.html">IString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#afbbcc47c00dd93ccd423b924c700ce9c">dump</a> (const <a class="el" href="classmi_1_1IData.html">IData</a> *data, const char *name=0, <a class="el" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791">Size</a> depth=0)=0</td></tr>
<tr class="memdesc:afbbcc47c00dd93ccd423b924c700ce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a textual representation of a type.  <a href="#afbbcc47c00dd93ccd423b924c700ce9c"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:afbbcc47c00dd93ccd423b924c700ce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae662f6193db05da3dca5093dab5075f3"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmi_1_1IString.html">IString</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#ae662f6193db05da3dca5093dab5075f3">dump</a> (<a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html">neuraylib::ITransaction</a> *transaction, const <a class="el" href="classmi_1_1IData.html">IData</a> *data, const char *name=0, <a class="el" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791">Size</a> depth=0)=0</td></tr>
<tr class="memdesc:ae662f6193db05da3dca5093dab5075f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a textual representation of a type.  <a href="#ae662f6193db05da3dca5093dab5075f3"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ae662f6193db05da3dca5093dab5075f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf5ee3cd9f18469af61fc15804dd65d"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmi_1_1IStructure__decl.html">IStructure_decl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a8bf5ee3cd9f18469af61fc15804dd65d">get_structure_decl</a> (const char *structure_name) const =0</td></tr>
<tr class="memdesc:a8bf5ee3cd9f18469af61fc15804dd65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a registered structure declaration.  <a href="#a8bf5ee3cd9f18469af61fc15804dd65d"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:a8bf5ee3cd9f18469af61fc15804dd65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd62973cdee5c48eb2976364fd12759a"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classmi_1_1IEnum__decl.html">IEnum_decl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#afd62973cdee5c48eb2976364fd12759a">get_enum_decl</a> (const char *enum_name) const =0</td></tr>
<tr class="memdesc:afd62973cdee5c48eb2976364fd12759a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a registered enum declaration.  <a href="#afd62973cdee5c48eb2976364fd12759a"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:afd62973cdee5c48eb2976364fd12759a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmi_1_1base_1_1Interface__declare"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmi_1_1base_1_1Interface__declare')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmi_1_1base_1_1Interface__declare.html">mi::base::Interface_declare&lt; 0x8afad838, 0xe597, 0x4a81, 0x92, 0x34, 0x51, 0xfe, 0xa4, 0xff, 0x04, 0x31 &gt;</a></td></tr>
<tr class="memitem:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmi_1_1base_1_1Interface__declare.html#ac18291e29369f959218926e0fe7d1667">compare_iid</a> (const <a class="el" href="structmi_1_1base_1_1Uuid.html">Uuid</a> &amp;iid)</td></tr>
<tr class="memdesc:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares the interface ID <code>iid</code> against the interface ID of this interface and of its ancestors.  <a href="#ac18291e29369f959218926e0fe7d1667"><span class="morelink">More...</span></a><br/></td></tr>
<tr class="separator:ac18291e29369f959218926e0fe7d1667 inherit pub_static_methods_classmi_1_1base_1_1Interface__declare"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This API component allows the creation, assignment, and cloning of instances of types. </p>
<p>It also provides a comparison function for types.</p>
<p>Types are interfaces derived from <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>. See <a class="el" href="group__mi__neuray__types.html">Types</a> for an explanation of the type system. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a92929d716d06ab9a5c8ae229a2595d23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23">mi::neuraylib::IFactory::Assign_clone_options</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum represents various options for the assignment or cloning of types. </p>
<p>The enum values are powers of two such that they can be combined in a bitmask. Such a bitmask van be is passed to <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92c64c0fb4de3c547da110812f4b3544" title="Assigns the value(s) of source to target. ">assign_from_to()</a> and <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a67a3150c5320bea5d513be2f34e44288" title="Creates a clone of a type. ">clone()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a92929d716d06ab9a5c8ae229a2595d23a27a15c74cdf0cd8ba78656fc1d3a2fb9"></a>DEEP_ASSIGNMENT_OR_CLONE</em>&nbsp;</td><td class="fielddoc">
<p>By default, assignment or cloning of instances of <a class="el" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a> and <a class="el" href="classmi_1_1IConst__pointer.html" title="This interface represents const pointers. ">mi::IConst_pointer</a> is shallow, i.e., the pointer represented by these interfaces is assigned or cloned as a plain value and both pointers point to the same interface afterwards. </p>
<p>If this option is given the assignment or cloning is deep, i.e., the operations happens on the wrapped pointers themselves. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a92929d716d06ab9a5c8ae229a2595d23ab3a2fb62c8f07533bb0b949dfad0e8f8"></a>FIX_SET_OF_TARGET_KEYS</em>&nbsp;</td><td class="fielddoc">
<p>By default, assignment might change the set of keys if the for target is a dynamic array or map. </p>
<p>If this option is given the set of keys in the target remains fixed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="acd66a49233429885b068b149374201a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2">mi::neuraylib::IFactory::Assign_result</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This enum represents possible events that can happen during assignment of types. </p>
<p>The enum values are powers of two such that they can be combined in a bitmask. Such a bitmask is returned by <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92c64c0fb4de3c547da110812f4b3544" title="Assigns the value(s) of source to target. ">assign_from_to()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a34155b212d4342942ff5885043b157af"></a>NULL_POINTER</em>&nbsp;</td><td class="fielddoc">
<p>One of the arguments <code>source</code> or <code>target</code> is <code>NULL</code>. </p>
<p>Alternatively, a deep assignment to an instance of <a class="el" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a> failed due to a <code>NULL</code> value. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a587d717a2e1f00abe19425279472ac97"></a>STRUCTURAL_MISMATCH</em>&nbsp;</td><td class="fielddoc">
<p>There is a structural mismatch between <code>source</code> and <code>target</code>. </p>
<p>One of the two arguments is of type <a class="el" href="classmi_1_1IData__simple.html" title="This interface represents simple types. ">mi::IData_simple</a> and the other one is of <a class="el" href="classmi_1_1IData__collection.html" title="This interface represents collections. ">mi::IData_collection</a>, or alternatively, both arguments are of type <a class="el" href="classmi_1_1IData__collection.html" title="This interface represents collections. ">mi::IData_collection</a> and there is at least one key which is of type <a class="el" href="classmi_1_1IData__simple.html" title="This interface represents simple types. ">mi::IData_simple</a> in one argument, and of type <a class="el" href="classmi_1_1IData__collection.html" title="This interface represents collections. ">mi::IData_collection</a> in the other argument. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a67fed1291b503ba7783d7415d7e304ec"></a>NO_CONVERSION</em>&nbsp;</td><td class="fielddoc">
<p>Both arguments (or at least one key thereof) are of different interfaces derived from <a class="el" href="classmi_1_1IData__simple.html" title="This interface represents simple types. ">mi::IData_simple</a> and there is no conversion between them. </p>
<p>This happens for example if an instance of <a class="el" href="classmi_1_1ISint32.html" title="This interface represents mi::Sint32. ">mi::ISint32</a> is assigned to an instance of <a class="el" href="classmi_1_1IString.html" title="A simple string class. ">mi::IString</a>). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a9bedd0b35026b9a8493415e9fbaa7415"></a>TARGET_KEY_MISSING</em>&nbsp;</td><td class="fielddoc">
<p>There is at least one key in <code>source</code> which does not exist in <code>target</code>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a955259464ec92228f39c408702a7991e"></a>SOURCE_KEY_MISSING</em>&nbsp;</td><td class="fielddoc">
<p>There is at least one key in <code>target</code> which does not exist in <code>source</code>. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a0027293cd9173c10d5719a6aca202b5e"></a>DIFFERENT_COLLECTIONS</em>&nbsp;</td><td class="fielddoc">
<p>Both arguments <code>source</code> and <code>target</code> (or the types of at least one key thereof) are collections, but of different type. </p>
<p>For example, this flag is set when assigning from static to dynamic arrays, from arrays to maps, or from arrays or maps to compounds, or vice versa. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2af686ce8bab762ac42214e7cfa82facc4"></a>NON_IDATA_VALUES</em>&nbsp;</td><td class="fielddoc">
<p>The argument <code>source</code> is a collection and contains at least one key which is not of type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>, e.g., in untyped arrays or maps. </p>
<p>Or <code>source</code> is a pointer or contains a key that is a pointer that wraps an instance not derived from <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>. Such types cannot get assigned with this method. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a80d0156a03cc7c12974594fc9e972b53"></a>INCOMPATIBLE_POINTER_TYPES</em>&nbsp;</td><td class="fielddoc">
<p>Shallow assignment (the default) was requested and the assignment failed due to incompatible pointer types, e.g., assigning from <a class="el" href="classmi_1_1IConst__pointer.html" title="This interface represents const pointers. ">mi::IConst_pointer</a> to <a class="el" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a>, or between different typed pointers (<a class="el" href="classmi_1_1IPointer.html#a57bc71eb6d5a9afcd5e27836f4fcea8e" title="Sets the pointer. ">mi::IPointer::set_pointer()</a> or <a class="el" href="classmi_1_1IConst__pointer.html#ac43434bf8dce5b52d1bd27f17f3d9b71" title="Sets the const pointer. ">mi::IConst_pointer::set_pointer()</a> failed). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a5e4106d4385e53919593f4a0ee66e058"></a>DEEP_ASSIGNMENT_TO_CONST_POINTER</em>&nbsp;</td><td class="fielddoc">
<p>Deep assignment was requested and <code>target</code> is an instance of <a class="el" href="classmi_1_1IConst__pointer.html" title="This interface represents const pointers. ">mi::IConst_pointer</a> (or a key of <code>target</code> is an instance of <a class="el" href="classmi_1_1IConst__pointer.html" title="This interface represents const pointers. ">mi::IConst_pointer</a>). </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2aad14ce6dafe912b121fcd644a0adc04f"></a>INCOMPATIBLE_PRIVACY_LEVELS</em>&nbsp;</td><td class="fielddoc">
<p>The assignment failed due to incompatible privacy levels, i.e., <a class="el" href="classmi_1_1IRef.html#ade48db4d0e929157ec8edb1cb6cb5fd3" title="Sets the reference to db_element. ">mi::IRef::set_reference()</a> returned error code -4. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2a53f242bcff8b93e1e6f56be61898a877"></a>INCOMPATIBLE_ENUM_TYPES</em>&nbsp;</td><td class="fielddoc">
<p>The assignment failed due to incompatible enum types. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="acd66a49233429885b068b149374201a2afbbf5b90b99b427ef1098a1273124860"></a>INCOMPATIBLE_OPTIONS</em>&nbsp;</td><td class="fielddoc">
<p>The assignment failed due to incompatible options. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a92c64c0fb4de3c547da110812f4b3544"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a> mi::neuraylib::IFactory::assign_from_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the value(s) of <code>source</code> to <code>target</code>. </p>
<p>Assignment succeeds if both <code>source</code> and <code>target</code> are of the same type. If not, the method tries to perform an assignment on a best effort basis. For example, an assignment between interfaces derived from <a class="el" href="classmi_1_1INumber.html" title="This interface represents simple numeric types. ">mi::INumber</a> might require a conversion as defined in the C/C++ standard. If both arguments are of type <a class="el" href="classmi_1_1IData__collection.html" title="This interface represents collections. ">mi::IData_collection</a>, assignment happens for all keys existing in both parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The instance to assign from. </td></tr>
    <tr><td class="paramname">target</td><td>The instance to assign to. </td></tr>
    <tr><td class="paramname">options</td><td>See <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23" title="This enum represents various options for the assignment or cloning of types. ">Assign_clone_options</a> for possible options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value is a bit field that indicates which events occurred during assignment. See <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2" title="This enum represents possible events that can happen during assignment of types. ">Assign_result</a> for possible events. </dd></dl>
<dl class="section user"><dt></dt><dd>The value 0 indicates that the assignment took place without any problems. Note that a non-zero value is not necessarily an error, it is up to the caller to interpret the result according to the context. For example, assigning from an instance of <a class="el" href="classmi_1_1IFloat32__3.html" title="This interface represents a vector of three Float32. ">mi::IFloat32_3</a> to an instance of <a class="el" href="classmi_1_1IFloat32__2.html" title="This interface represents a vector of two Float32. ">mi::IFloat32_2</a> will result in <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#acd66a49233429885b068b149374201a2a9bedd0b35026b9a8493415e9fbaa7415" title="There is at least one key in source which does not exist in target. ">TARGET_KEY_MISSING</a> because there is no key named <code>"z"</code> in <a class="el" href="classmi_1_1IFloat32__2.html" title="This interface represents a vector of two Float32. ">mi::IFloat32_2</a>. It is up to the caller to decide whether this is the intended behavior or not. </dd></dl>

</div>
</div>
<a class="anchor" id="a67a3150c5320bea5d513be2f34e44288"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1IData.html">IData</a>* mi::neuraylib::IFactory::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of a type. </p>
<p>It is not possible to clone untyped pointers and collections that wrap/contain interface pointers that are not of type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The instance to clone. </td></tr>
    <tr><td class="paramname">options</td><td>See <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23" title="This enum represents various options for the assignment or cloning of types. ">Assign_clone_options</a> for possible options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1223297430e9d6713160427065e9922"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::IFactory::clone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a clone of a type. </p>
<p>It is not possible to clone untyped pointers and collections that wrap/contain interface pointers that are not of type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The instance to clone. </td></tr>
    <tr><td class="paramname">options</td><td>See <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#a92929d716d06ab9a5c8ae229a2595d23" title="This enum represents various options for the assignment or cloning of types. ">Assign_clone_options</a> for possible options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the class to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a536a81de52cb591e78d23df4f661b2dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6">Sint32</a> mi::neuraylib::IFactory::compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>. </p>
<p>The comparison operator for instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a> is defined as follows:</p>
<ul>
<li>If <code>lhs</code> or <code>rhs</code> is <code>NULL</code>, the result is the lexicographic comparison of the pointer addresses themselves.</li>
<li>Otherwise, the type names of <code>lhs</code> and <code>rhs</code> are considered. If they are different, the result is determined by <code>strcmp()</code> on the type names. For example, this method never returns 0 if you compare a dynamic array and a static array, even if they have the same element type, length, and equal element values.</li>
<li>Finally, the values of the elements are compared lexicographically, as defined by <code>operator&lt;</code> or <code>strcmp()</code> with the following special cases for selected interfaces:<ul>
<li><a class="el" href="classmi_1_1IRef.html" title="A reference is an object that acts as a pointer to other database elements. ">mi::IRef</a>: If <a class="el" href="classmi_1_1IRef.html#ad1983ce7a9fa6b92c2c2c1a63900e9f8" title="Returns the name of the referenced element. ">mi::IRef::get_reference_name()</a> returns <code>NULL</code> for at least one operand, the result is the lexicographic comparison of the pointer addresses. Otherwise, the result is determined by <code>strcmp()</code> on the names of the referenced DB elements.</li>
<li><a class="el" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a> and <a class="el" href="classmi_1_1IConst__pointer.html" title="This interface represents const pointers. ">mi::IConst_pointer</a>: If <a class="el" href="classmi_1_1IPointer.html#a7fb71e78bb2e4765359e46e396cbd33c" title="Returns the pointer. ">mi::IPointer::get_pointer()</a> or <a class="el" href="classmi_1_1IConst__pointer.html#aa22e3d6fd6104d36c10fc2975066d5bf" title="Returns the const pointer. ">mi::IConst_pointer::get_pointer()</a> returns <code>NULL</code> for at least one operand, the result is the lexicographic comparison of the pointer addresses. Otherwise, if at least one pointer is not of the type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>, the result is the lexicographic comparison of the pointer addresses. Finally (both pointers are of type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>), the result is determined by the recursive invocation of this method on these pointers.</li>
<li><a class="el" href="classmi_1_1IData__collection.html" title="This interface represents collections. ">mi::IData_collection</a>: First, if the collections have different length, this decides the comparison. Next, the elements are compared pairwise in lexicographic order of the element index. If the element keys are different, <code>strcmp()</code> on the element keys determines the result. Otherwise, the element values are compared by recursive invocation of this method (or lexicographic comparison of the pointer addresses if one element is not of type <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a>). If they are different, this decides the result, otherwise the comparison continues with the next element. If all elements are equal, the result is 0.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side operand for the comparison. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side operand for the comparison. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>lhs</code> &lt; <code>rhs</code>, 0 if <code>lhs</code> == <code>rhs</code>, and +1 if <code>lhs</code> &gt; <code>rhs</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a953eb56b2d0902e7e21041fed5f6a801"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a>* mi::neuraylib::IFactory::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>argc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>argv</em>[] = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>type_name</code>. </p>
<p>The arguments passed to this method are passed to the constructor of the created object.</p>
<p>This factory allows the creation of instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a> and derived interfaces. For other kind of objects like DB elements use <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a>. It is not possible to create instances of <a class="el" href="classmi_1_1IRef.html" title="A reference is an object that acts as a pointer to other database elements. ">mi::IRef</a> or collections of references. Use::mi::neuraylib::ITransaction::create()instead.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the object to create. See <a class="el" href="group__mi__neuray__types.html">Types</a> for possible type names. </td></tr>
    <tr><td class="paramname">argc</td><td>The number of elements in <code>argv</code>. </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments passed to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object on success, or <code>NULL</code> on failure (e.g., invalid type name). </dd></dl>

</div>
</div>
<a class="anchor" id="ae6a0b55aca1f645a1824c29b6f51e266"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::IFactory::create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a">Uint32</a>&#160;</td>
          <td class="paramname"><em>argc</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1base_1_1IInterface.html">base::IInterface</a> *&#160;</td>
          <td class="paramname"><em>argv</em>[] = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>type_name</code>. </p>
<p>The arguments passed to this method are passed to the constructor of the created object.</p>
<p>This factory allows the creation of instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a> and derived interfaces. For other kind of objects like DB elements use <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a>. It is not possible to create instances of <a class="el" href="classmi_1_1IRef.html" title="A reference is an object that acts as a pointer to other database elements. ">mi::IRef</a> or collections of references. Use::mi::neuraylib::ITransaction::create()instead.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<p>Note that there are two versions of this templated member function, one that takes no arguments, and another one that takes one or three arguments (the type name, and two optional arguments passed to the factory class). The version with no arguments can only be used to create a subset of supported types: it supports only those types where the type name can be deduced from the template parameter, i.e., it does not support arrays, structures, maps, and pointers. The version with one or three arguments can be used to create any type (but requires the type name as parameter, which is redundant for many types). Attempts to use the version with no arguments with a template parameter where the type name can not be deduced results in compiler errors.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_name</td><td>The type name of the object to create </td></tr>
    <tr><td class="paramname">argc</td><td>The number of elements in <code>argv</code> </td></tr>
    <tr><td class="paramname">argv</td><td>The array of arguments passed to the constructor </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the class to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object on success, or <code>NULL</code> on failure (e.g., invalid type name). </dd></dl>

</div>
</div>
<a class="anchor" id="a93a229a76c22734b2606a088c8e5f522"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* mi::neuraylib::IFactory::create </td>
          <td>(</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an object of the type <code>T</code>. </p>
<p>This factory allows the creation of instances of <a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a> and derived interfaces. For other kind of objects like DB elements use <a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a>. It is not possible to create instances of <a class="el" href="classmi_1_1IRef.html" title="A reference is an object that acts as a pointer to other database elements. ">mi::IRef</a> or collections of references. Use::mi::neuraylib::ITransaction::create()instead.</p>
<p>The created object will be initialized in a manner dependent upon the passed type name. Each class has its own policy on initialization. So, one should not make any assumptions on the values of the various class members.</p>
<p>Note that there are two versions of this templated member function, one that takes no arguments, and another one that takes one or three arguments (the type name, and two optional arguments passed to the factory class). The version with no arguments can only be used to create a subset of supported types: it supports only those types where the type name can be deduced from the template parameter, i.e., it does not support arrays, structures, maps, and pointers. The version with one or three arguments can be used to create any type (but requires the type name as parameter, which is redundant for many types). Attempts to use the version with no arguments with a template parameter where the type name can not be deduced results in compiler errors.</p>
<p>This templated member function is a wrapper of the non-template variant for the user's convenience. It eliminates the need to call <a class="el" href="classmi_1_1base_1_1IInterface.html#a9116a1f3bc9338beff8ba81626a98ad9" title="Acquires a mutable interface from another. ">mi::base::IInterface::get_interface(const Uuid&amp;)</a> on the returned pointer, since the return type already is a pointer to the type <code>T</code> specified as template parameter.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html#abf3b188c45023f86faf2b831d7bf9b9c" title="Creates an object of the type T. ">mi::neuraylib::ITransaction::create()</a> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The interface type of the class to create </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the created object on success, or <code>NULL</code> on failure (e.g., invalid type name). </dd></dl>

</div>
</div>
<a class="anchor" id="afbbcc47c00dd93ccd423b924c700ce9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmi_1_1IString.html">IString</a>* mi::neuraylib::IFactory::dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791">Size</a>&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a textual representation of a type. </p>
<p>The textual representation is of the form "type name = value" if <code>name</code> is not <code>NULL</code>, and of the form "value" if <code>name</code> is <code>NULL</code>. The representation of the value might contain line breaks, for example for structures and arrays. Subsequent lines have a suitable indentation. The assumed indentation level of the first line is specified by <code>depth</code>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#ae662f6193db05da3dca5093dab5075f3" title="Returns a textual representation of a type. ">mi::neuraylib::IFactory::dump(ITransaction*,const IData*,const char*,Size)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae662f6193db05da3dca5093dab5075f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmi_1_1IString.html">IString</a>* mi::neuraylib::IFactory::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmi_1_1neuraylib_1_1ITransaction.html">neuraylib::ITransaction</a> *&#160;</td>
          <td class="paramname"><em>transaction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmi_1_1IData.html">IData</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791">Size</a>&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a textual representation of a type. </p>
<p>This overload of <a class="el" href="classmi_1_1neuraylib_1_1IFactory.html#afbbcc47c00dd93ccd423b924c700ce9c" title="Returns a textual representation of a type. ">mi::neuraylib::IFactory::dump(const IData*,const char*,Size)</a> requires an additional transaction pointer. This is necessary to support the dumping of possibly nested non-<a class="el" href="classmi_1_1IData.html" title="This interface is the base interface of all types. ">mi::IData</a> types. </p>

</div>
</div>
<a class="anchor" id="afd62973cdee5c48eb2976364fd12759a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmi_1_1IEnum__decl.html">IEnum_decl</a>* mi::neuraylib::IFactory::get_enum_decl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>enum_name</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a registered enum declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enum_name</td><td>The name of the enum declaration to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The enum declaration for <code>name</code>, or <code>NULL</code> if there is no enum declaration for that name. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf5ee3cd9f18469af61fc15804dd65d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classmi_1_1IStructure__decl.html">IStructure_decl</a>* mi::neuraylib::IFactory::get_structure_decl </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>structure_name</em>)</td><td></td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a registered structure declaration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">structure_name</td><td>The name of the structure declaration to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The structure declaration for <code>name</code>, or <code>NULL</code> if there is no structure declaration for that name. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
