<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Library Design</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mi_neuray_design.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Library Design </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In addition to the introduction given here, the <a class="el" href="mi_neuray_examples.html">Tutorial and Example Programs</a> explain many topics about the MDL SDK API design.</p>
<p>A list of such topics can be found in the <a class="el" href="mi_neuray_example_topics.html">Index of Topics Explained in the Example Programs</a>.</p>
<h1><a class="anchor" id="mi_neuray_interfaces"></a>
Interfaces</h1>
<p>The MDL SDK API follows conventional modern C++ library design principles for component software to achieve binary compatibility across shared library boundaries and future extensibility. The design provides access to the shared library through interfaces, abstract base classes with pure virtual member functions.</p>
<p>The main interface <a class="el" href="classmi_1_1neuraylib_1_1INeuray.html" title="This is an object representing the MDL SDK library. ">mi::neuraylib::INeuray</a> can be retrieved by calling the global function <a class="el" href="group__mi__neuray__ineuray.html#gaf81abce7a57cc4bebe22bd5547ea1916" title="Unique public access point to the MDL SDK API. ">mi_factory()</a>. <a class="el" href="classmi_1_1neuraylib_1_1INeuray.html" title="This is an object representing the MDL SDK library. ">mi::neuraylib::INeuray</a> allows access to the whole library. From this interface other interfaces of the library can be requested with the <a class="el" href="classmi_1_1neuraylib_1_1INeuray.html#a4e107568bbb0e64f61fb4b59b93607fa" title="Returns an API component from the MDL SDK API. ">mi::neuraylib::INeuray::get_api_component()</a> member function.</p>
<h1><a class="anchor" id="mi_neuray_refcounting"></a>
Reference counting</h1>
<p>Interfaces implement reference counting for life-time control.</p>
<p>Whenever a function returns a pointer to <a class="el" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a> or a subclass thereof, the corresponding reference counter has already been increased by 1. That is, you can use the interface pointer without worrying whether the pointer is still valid. Whenever you do not need an interface any longer, you have to release it by calling its <code>release()</code> method. Omitting such calls leads to memory leaks.</p>
<p>In more detail, the rules for reference counting are as follows:</p>
<ul>
<li>A method that returns an interface increments the reference count for the caller. The caller needs to release the interface when it is done. See Example 1 below.</li>
<li>When a caller passes an interface as method argument the caller has to guarantee that the interface is valid for the runtime of that method, and the callee can safely use the interface for that time without the need to change the reference count.</li>
<li>If the callee wants to reference an interface passed as an argument later (typically via a member variable) then it has to use reference counting to ensure that the interface remains valid. See Example 2 below.</li>
<li>The initial reference count after construction is 1 (such that one can implement methods returning an interface pointer by writing <code>return</code> <code>new</code> <code>Foo()</code>; ).</li>
<li>Interfaces passed as out arguments of methods are treated similar to return values. The callee decrements the reference count for the value passed in and increments it for the value passed back.</li>
</ul>
<p>Example 1:</p>
<p>Assume there is an interface <code>IFoo</code> derived from <a class="el" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a>, and an API method that creates instances of <code>IFoo</code>, e.g.,</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IFactory : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__declare.html" title="Mixin class template for deriving new interface declarations. ">mi::base::Interface_declare</a>...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> IFoo* create_foo() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Let <code>factory</code> be an instance of <code>IFactory</code>. As described by the rules above the implementation of <code>create_foo()</code> increments the reference count for the caller. When you are done with your reference to the instance of <code>IFoo</code>, you need to decrement its reference count again via <a class="el" href="classmi_1_1base_1_1IInterface.html#ad75d76371fab5c1623e5916933af4b82" title="Decrements the reference count. ">mi::base::IInterface::release()</a>.</p>
<div class="fragment"><div class="line">IFoo* foo = factory-&gt;create_foo();</div>
<div class="line"><span class="comment">// use &quot;foo&quot;</span></div>
<div class="line">foo-&gt;release();</div>
<div class="line"><span class="comment">// must no longer use &quot;foo&quot; here</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This example demonstrates the rules above for reference counting. We strongly recommend not to call <code>retain()</code> and <code>release()</code> manually. See the variant of this example in <a class="el" href="mi_neuray_design.html#mi_neuray_handle">Handle class</a> which is simpler, obtain simpler, less error-prone and exception-safe.</dd></dl>
<p>Example 2:</p>
<p>Assume you want to implement the following interface.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IRegistry : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__declare.html" title="Mixin class template for deriving new interface declarations. ">mi::base::Interface_declare</a>...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> register_foo( IFoo* foo) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Further assume that the implementation of <code>IRegistry</code> needs to reference the registered instance of <code>IFoo</code> after the method <code>register_foo()</code> returned. This can be done as follows. Checking <code>foo</code> and <code>m_foo</code> for <code>NULL</code> has been omitted for brevity.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Registry_impl : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__implement.html" title="Mixin class template for deriving interface implementations. ">mi::base::Interface_implement</a>&lt;IRegistry&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Registry_impl( IFoo* foo);</div>
<div class="line">    Registry_impl( <span class="keyword">const</span> Registry_impl&amp; other);</div>
<div class="line">    Registry_impl&amp; <a class="code" href="classmi_1_1base_1_1Interface__implement.html#ab0c7a769c55be0f220641668ef99d19d" title="Assignment operator. ">operator=</a>( <span class="keyword">const</span> Registry_impl&amp; rhs);</div>
<div class="line">    ~Registry_impl();</div>
<div class="line">    <span class="keywordtype">void</span> register_foo( IFoo* foo);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    IFoo* m_foo;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Registry_impl::Registry_impl( IFoo* foo)</div>
<div class="line">{</div>
<div class="line">    m_foo = foo;</div>
<div class="line">    m_foo-&gt;retain();  </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Registry_impl::Registry_impl( <span class="keyword">const</span> Registry_impl&amp; other)</div>
<div class="line">  : mi::base::Interface_implement&lt;IRegistry&gt;( other)</div>
<div class="line">{</div>
<div class="line">    m_foo = other.m_foo;</div>
<div class="line">    m_foo-&gt;retain();  </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Registry_impl&amp; Registry_impl::operator=( <span class="keyword">const</span> Registry_impl&amp; rhs)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Interface__implement.html#ab0c7a769c55be0f220641668ef99d19d" title="Assignment operator. ">mi::base::Interface_implement&lt;IRegistry&gt;::operator=</a>( rhs);</div>
<div class="line">    m_foo-&gt;release();</div>
<div class="line">    m_foo = rhs.m_foo;</div>
<div class="line">    m_foo-&gt;retain();</div>
<div class="line">    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">Registry_impl::~Registry_impl()</div>
<div class="line">{</div>
<div class="line">    m_foo-&gt;release(); </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Registry_impl::register_foo( IFoo* foo)</div>
<div class="line">{</div>
<div class="line">    m_foo-&gt;release(); </div>
<div class="line">    m_foo = foo;</div>
<div class="line">    m_foo-&gt;retain();  </div>
<div class="line">}</div>
</div><!-- fragment --><p>As described by the rules above you need to increment and decrement the reference count of the <code>IFoo</code> instance if you keep a reference that exceeds the lifetime of the called method.</p>
<dl class="section note"><dt>Note</dt><dd>This example demonstrates the rules for reference counting. We strongly recommend not to call <code>retain()</code> and <code>release()</code> manually. See the variant of this example in <a class="el" href="mi_neuray_design.html#mi_neuray_handle">Handle class</a> which is much simpler and where copy constructor, assignment operator, destructor, and <code>NULL</code> handling are for free.</dd></dl>
<h1><a class="anchor" id="mi_neuray_handle"></a>
Handle class</h1>
<p>To simplify your life and to relieve you from keeping track of <code>release()</code> calls, we offer a simple handle class <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a>. This handle class maintains a pointer semantic while supporting reference counting for interface pointers. For example, the <code>-&gt;</code> operator acts on the underlying interface pointer. The destructor calls <code>release()</code> on the interface pointer, copy constructor and assignment operator take care of retaining and releasing the interface pointer as necessary. Note that it is also possible to use other handle class implementations, e.g., <code>std::tr1::shared_ptr&lt;T&gt;</code> (or <code>boost::shared_ptr&lt;T&gt;</code>). See <a class="el" href="mi_neuray_example_start_shutdown.html">Example for Starting and Shutting Down the MDL SDK API</a> for details.</p>
<p>Example 1:</p>
<p>Assume there is an interface <code>IFoo</code> derived from <a class="el" href="classmi_1_1base_1_1IInterface.html" title="The basic extensible interface. ">mi::base::IInterface</a>, and an API method that creates instances of <code>IFoo</code>, e.g.,</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IFactory : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__declare.html" title="Mixin class template for deriving new interface declarations. ">mi::base::Interface_declare</a>...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> IFoo* create_foo() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Let <code>factory</code> be an instance of <code>IFactory</code>. As described by the rules in <a class="el" href="mi_neuray_design.html#mi_neuray_refcounting">Reference counting</a> the implementation of <code>create_foo()</code> increments the reference count for the caller. Since the default constructor of <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> leaves the reference count unchanged, you can simply use it to capture the return value. The destructor or the <code>reset()</code> method of <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> decrement the reference count again via <a class="el" href="classmi_1_1base_1_1IInterface.html#ad75d76371fab5c1623e5916933af4b82" title="Decrements the reference count. ">mi::base::IInterface::release()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;IFoo&gt;</a> foo( factory-&gt;create_foo());</div>
</div><!-- fragment --><p>Using <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> (or similar helper classes) instead of manually calling <code>retain()</code> and <code>release()</code> is strongly recommended for exception-safe code.</p>
<p>Example 2:</p>
<p>Assume you want to implement the following interface.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>IRegistry : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__declare.html" title="Mixin class template for deriving new interface declarations. ">mi::base::Interface_declare</a>...&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> register_foo( IFoo* foo) = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Further assume that the implementation of <code>IRegistry</code> needs to reference the registered instance of <code>IFoo</code> after the method <code>register_foo()</code> returned.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Registry_impl : <span class="keyword">public</span> <a class="code" href="classmi_1_1base_1_1Interface__implement.html" title="Mixin class template for deriving interface implementations. ">mi::base::Interface_implement</a>&lt;IRegistry&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Registry_impl( IFoo* foo);</div>
<div class="line">    <span class="keywordtype">void</span> register_foo( IFoo* foo);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;IFoo&gt;</a> m_foo;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">Registry_impl::Registry_impl( IFoo* foo)</div>
<div class="line">  : m_foo( foo, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>) { } <span class="comment">// or: m_foo( make_handle_dup( foo))</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> Registry_impl::register_foo( IFoo* foo)</div>
<div class="line">{</div>
<div class="line">    m_foo = <a class="code" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">make_handle_dup</a>( foo);</div>
<div class="line">    <span class="comment">// or: m_foo = mi::base::Handle&lt;IFoo&gt;( foo, mi::base::DUP_INTERFACE);</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>In this case you cannot use the default constructor of <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> since you need to increment the reference count as well. This is done by the constructor that takes <a class="el" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">mi::base::DUP_INTERFACE</a> as second argument. Alternatively, you can use the inline function <a class="el" href="group__mi__base__iinterface.html#gae266c35f2b70c271606d56840eca7b96" title="Converts passed-in interface pointer to a handle, without taking interface over. ">mi::base::make_handle_dup()</a> which does that for you.</p>
<p>Note that the default implementation of the copy constructor, assignment operator, and destructor of <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> just do the right thing, and therefore, there is no need to implement them for <code>Registry_impl</code>. Also <code>NULL</code> handling for <code>foo</code> and <code>m_foo</code> is for free.</p>
<h1><a class="anchor" id="mi_neuray_resources"></a>
Resources</h1>
<p>In general, you should aim for minimal resource usage. This implies releasing interface pointers as soon as you no longer need them. When using the <a class="el" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle</a> class, it can be beneficial to introduce additional <code>{</code> <code></code>... <code>}</code> blocks to enforce the destruction of the handle, and release of the corresponding interface pointer, at the end of the block. Alternatively, you can also call <a class="el" href="classmi_1_1base_1_1Handle.html#aef0b775c1e3592c3343a486f226d9c7b" title="Releases the current interface, decrementing the reference count. ">mi::base::Handle::reset()</a> or assign <code>0</code> to the handle.</p>
<h1><a class="anchor" id="mi_neuray_strings"></a>
Strings</h1>
<p>There is an interface <a class="el" href="classmi_1_1IString.html" title="A simple string class. ">mi::IString</a> representing strings. However, some methods return constant strings as a pointer to <code>const</code> <code>char</code> for simplicity. These strings are managed by the MDL SDK API and you must not deallocate the memory pointed to by such a pointer. These pointers are valid as long as the interface from which the pointer was obtained is valid. Exceptions from this rule are documented with the corresponding method. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
