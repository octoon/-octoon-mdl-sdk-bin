<!-- HTML header for doxygen 1.8.4-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Example for Execution of Compiled MDL Materials (PTX)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="images/arcicon.ico" rel="shortcut icon" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_custom_stylesheet_1_8_4.css" rel="stylesheet" type="text/css"/>
<link rel='stylesheet' href='webfonts/librebaskerville/stylesheet.css' type='text/css'/>
<link rel='stylesheet' href='webfonts/sourcesanspro/stylesheet.css' type='text/css'/>
<!--ARC-->
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="blackheader">
<span id="blackheader_title">MDL SDK API</span>
<span>
<img src="images/nvidia_logo_transpbg.gif" alt="nvidia_logo_transpbg.gif" style=" height:1.25em; width:6.806em;"/></span>
<span id="blackheader_uplink">
<a href='../index.html' class='top_page_nav'>Up</a>
</span>
</div>
<!--
<div id="titlearea">
   <span id="projectname">
     <a id="titlelink" href="../../index.html">
       MDL SDK API
     </a>
   </span>
     <a id="projectlogo" href="http://www.nvidia-arc.com">
       <img alt="NVIDIA logo" src="images/nvidia_logo.png" style="height:2em;">
       </a>
     <a href='../index.html' class='top_page_nav'>Up</a>
</div>
-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mi_neuray_example_execution_ptx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Example for Execution of Compiled MDL Materials (PTX) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div align="right"> [<a class="el" href="mi_neuray_example_execution_native.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_execution_glsl.html">Next</a>] </div><p>This example describes the API of the code generated by the "PTX" backend for compiled materials and shows how a renderer can call this generated code to evaluate sub-expressions of multiple materials using CUDA.</p>
<h1><a class="anchor" id="example_execution_ptx_new"></a>
New Topics</h1>
<ul>
<li>MDL material state (PTX)</li>
<li>Execution of generated code (PTX)</li>
<li>Loading textures (PTX)</li>
<li>Texture access functions (PTX)</li>
</ul>
<h1><a class="anchor" id="example_execution_ptx_descr"></a>
Detailed Description</h1>
<dl>
<dt><b>MDL material state (PTX)</b> </dt>
<dd><p class="startdd"><br/>
 The MDL material state structure <a class="el" href="group__mi__neuray__mdl__compiler.html#ga8a42cb80b6772ce4b266f2311b0561c1" title="The MDL material state structure. ">mi::neuraylib::Shading_state_material</a> is a representation of the renderer state as defined in section 19 "Renderer state" in the MDL specification. It is used to make the state of the renderer (like the position of an intersection point on the surface, the shading normal and the texture coordinates) available to the generated code.</p>
<p>Here's a version of the material state structure making use of the types from CUDA's <code>vector_types.h:</code> </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Shading_state_material {</div>
<div class="line">    float3                 normal;                  <span class="comment">// state::normal() result</span></div>
<div class="line">    float3                 geom_normal;             <span class="comment">// state::geom_normal() result</span></div>
<div class="line">    float3                 position;                <span class="comment">// state::position() result</span></div>
<div class="line">    <span class="keywordtype">float</span>                  animation_time;          <span class="comment">// state::animation_time() result</span></div>
<div class="line">    <span class="keyword">const</span> float3          *text_coords;             <span class="comment">// state::texture_coordinate() table</span></div>
<div class="line">    <span class="keyword">const</span> float3          *tangent_u;               <span class="comment">// state::texture_tangent_u() table</span></div>
<div class="line">    <span class="keyword">const</span> float3          *tangent_v;               <span class="comment">// state::texture_tangent_v() table</span></div>
<div class="line">    float4                *text_results;            <span class="comment">// texture results lookup table</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>            *ro_data_segment;         <span class="comment">// read-only data segment</span></div>
<div class="line">    <span class="keyword">const</span> float4          *world_to_object;         <span class="comment">// world-to-object transform matrix</span></div>
<div class="line">    <span class="keyword">const</span> float4          *object_to_world;         <span class="comment">// object-to-world transform matrix</span></div>
<div class="line">    <span class="keywordtype">int</span>                    object_id;               <span class="comment">// state::object_id() result</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>Please refer to the structure documentation for more information.</p>
<p>In this example, we fill the material state structure with some example values and only use one texture space. For the world-to-object and object-to-world transformation matrices we use identity matrices. We will iterate the <code>position</code> and <code>text_coords</code> fields over a 2x2 quad around the center of the world with position <code>x</code> and <code>y</code> coordinates ranging from -1 to 1 and the texture uv-coordinates ranging from 0 to 1, respectively. </p>
<p class="enddd"></p>
</dd>
<dt><b>Execution of generated code (PTX)</b> </dt>
<dd><p class="startdd"><br/>
 For the non-native backends, the generated code has to be called directly from the corresponding framework, so we need to know the prototypes of the functions generated via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga965f9701d653a059364c011762266c96" title="Transforms an expression that is part of an MDL material instance to target code. ...">mi::neuraylib::IMdl_backend::translate_material_expression()</a>. With <code>"NAME"</code> being the function name you provided as <code>fname</code> parameter and <code>"T"</code> being the result type, they look like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> NAME(</div>
<div class="line">    T                             *result,</div>
<div class="line">    Shading_state_material <span class="keyword">const</span>  *state,</div>
<div class="line">    Resource_data <span class="keyword">const</span>           *res_data,</div>
<div class="line">    <span class="keywordtype">void</span> <span class="keyword">const</span>                    *exception_state,</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>                    *captured_args);</div>
</div><!-- fragment --><p>or written as a PTX prototype:</p>
<div class="fragment"><div class="line">.visible .func NAME(</div>
<div class="line">        .param .b64 result,</div>
<div class="line">        .param .b64 state,</div>
<div class="line">        .param .b64 res_data,</div>
<div class="line">        .param .b64 exception_state,</div>
<div class="line">        .param .b64 captured_args</div>
<div class="line">);</div>
</div><!-- fragment --><p>The <code>res_data</code> parameter is used to provide access to resources like textures depending on the way how those resources are accessed (see "Texture access functions" below). If it is not used, the pointers inside the structure may be NULL:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Resource_data {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">void</span>                 *shared_data;</div>
<div class="line">    <span class="keyword">const</span> Texture_handler_base *texture_handler;</div>
<div class="line">};</div>
</div><!-- fragment --><p>The <code>exception_state</code> parameter allows to provide handlers for out-of-bounds array access exceptions and division-by-zero exceptions. But for the PTX backend, this is not supported and the parameter should be set to NULL.</p>
<p>The <code>captured_args</code> parameter is used to provide the data of the <a class="el" href="classmi_1_1neuraylib_1_1ITarget__argument__block.html" title="Represents an argument block of a class-compiled material compiled for a specific target...">mi::neuraylib::ITarget_argument_block</a> object for class-compiled materials. The data can either be manually created using the information from <a class="el" href="classmi_1_1neuraylib_1_1ITarget__value__layout.html" title="Represents the layout of an mi::neuraylib::ITarget_argument_block with support for nested elements...">mi::neuraylib::ITarget_value_layout</a> or by using <a class="el" href="group__mi__neuray__mdl__compiler.html#ga21940811d1cb33be2400ee7e5bd66983" title="Get a target argument block if available. ">mi::neuraylib::ITarget_code::get_argument_block()</a> or <a class="el" href="group__mi__neuray__mdl__compiler.html#ga53477194559841e30694b97d63ac7eb6" title="Create a new target argument block of the class-compiled material for this target code...">mi::neuraylib::ITarget_code::create_argument_block()</a>. For instance-compiled materials, this parameter should be set to NULL. See <a class="el" href="mi_neuray_compiler.html#mi_neuray_compilation_modes">Instance-compilation and class-compilation</a> for more details about instance and class compilation.</p>
<p>To make the generated functions available to our CUDA kernel, we have to link them with the kernel. We could just declare the generated functions with the corresponding names as <code>extern "C"</code> in the CUDA source code of the kernel, but we may want to decide at runtime how many materials will be available. So we will add an indirection through an array of pointers to the generated functions which we provide as an additional PTX source code buffer to the CUDA linker.</p>
<dl class="section note"><dt>Note</dt><dd>We currently have to add a dummy function to the PTX code containing this function pointer array, because the CUDA linker will otherwise just resolve the function addresses to zero.</dd>
<dd>
Also, we need to compile the CUDA kernel with the option <code>-rdc=true</code> (relocatable device code), otherwise the <code>extern</code> declared function array will be treated as a definition resulting in two arrays.</dd></dl>
<p>In this example, we bake multiple materials into a texture with a user-configurable checkerboard pattern by executing a material for every texel updating the material state accordingly. At the end, we write the texture to disk. </p>
<p class="enddd"></p>
</dd>
<dt><b>Loading textures (PTX)</b> </dt>
<dd><p class="startdd"><br/>
 When the <code>nv_freeimage</code> plugin has been loaded via <a class="el" href="classmi_1_1neuraylib_1_1IPlugin__configuration.html#aa8660748a128a9bb925c831dbbf05a0b" title="Loads a plugin library. ">mi::neuraylib::IPlugin_configuration::load_plugin_library()</a> before starting the MDL SDK, the SDK will automatically load textures on the host side for many common image formats and make them available via <a class="el" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">mi::neuraylib::ITarget_code::get_texture()</a>. Note, that the first texture is always the invalid texture, so only if there is more than just one texture according to <a class="el" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">mi::neuraylib::ITarget_code::get_texture_count()</a>, there will be real referenced textures available.</p>
<p>Here's a small code snippet showing how to access the <a class="el" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> of the texture at index <code>i</code>. </p>
<div class="fragment"><div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITexture&gt;</a> texture(</div>
<div class="line">    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(i)));</div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IImage&gt;</a> image(</div>
<div class="line">    transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(texture-&gt;get_image()));</div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas());</div>
</div><!-- fragment --><p>The textures still have to be copied to the GPU and possibly they have to be gamma corrected and converted to a format understood by the texture access functions you provide. In this example, we use the <a class="el" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a> to apply the gamma correction and to convert the image format to a float32 RGBA format.</p>
<p>Depending on the texture shape returned by <a class="el" href="group__mi__neuray__mdl__compiler.html#ga1ffc64d788c1ff52bb994266a242c81c" title="Returns the texture shape of a given texture resource used by the target code. ">mi::neuraylib::ITarget_code::get_texture_shape()</a> the texture image data has to be copied to a CUDA array (2D textures), a 3D array (3D textures) or a 3D array with the <code>cudaArrayCubemap</code> flag set (cube textures). The textures could then be made available via CUDA texture objects.</p>
<dl class="section note"><dt>Note</dt><dd>For cube textures, you should use the <code>cudaAddressModeClamp</code> address mode for the texture objects to avoid visual artifacts in the corners. </dd></dl>
</dd>
<dt><b>Texture access functions (PTX)</b> </dt>
<dd><p class="startdd"><br/>
 For non-native backends, the generated code requires a set of methods implementing texture access functionality:</p>
<ul>
<li>tex_lookup_float4_2d</li>
<li>tex_lookup_float3_2d</li>
<li>tex_texel_float4_2d</li>
<li>tex_lookup_float4_3d</li>
<li>tex_lookup_float3_3d</li>
<li>tex_texel_float4_3d</li>
<li>tex_lookup_float4_cube</li>
<li>tex_lookup_float3_cube</li>
<li>tex_resolution_2d</li>
</ul>
<p>Except for the last one, these correspond directly to the functions described in section 20.3 "Standard library functions - Texture" in the MDL specification.</p>
<p>The <code>tex_lookup_*</code> functions receive floating-point texture coordinates and should provide a sampled value, whereas <code>tex_texel_*</code> functions receive integer texture coordinates and should provide a raw texture value. There are variants for texture lookups with and without alpha channel (float4 / float3) and for the different texture shapes (2d / 3d / cube) as described in section 6.12 "Variables and data types - Textures" in the MDL specification. Note, that PTEX textures are currently not supported by the backends.</p>
<p><code>tex_resolution_2d</code> retrieves the width and height at the given uv-tile coordinates for a texture_2d. For non-uv-tile textures, the uv-tile coordinates are always (0, 0).</p>
<p>For the PTX backend, there are different ways how the methods can be provided, which can be chosen by setting the <code>"tex_lookup_call_mode"</code> option via the <a class="el" href="group__mi__neuray__mdl__compiler.html#ga1301dec05ba862ca7745814367811f15" title="Sets a backend option. ">mi::neuraylib::IMdl_backend::set_option()</a> method to the corresponding mode. Please refer to <a class="el" href="mi_neuray_ptx_texture_lookup_call_modes.html">Texture lookup call modes of the PTX backend</a> for more details.</p>
<p>In this example, you can switch from the <code>"direct_call"</code> mode to the slower <code>"vtable"</code> mode by commenting out this line in <code>example_cuda_shared.h:</code> </p>
<div class="fragment"><div class="line">check_success(be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;tex_lookup_call_mode&quot;</span>, <span class="stringliteral">&quot;direct_call&quot;</span>) == 0);</div>
</div><!-- fragment -->  </dd>
</dl>
<h1><a class="anchor" id="example_execution_ptx"></a>
Example Source</h1>
<p>To compile the source code, you need to install the "CUDA Toolkit 9" available at <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a>.</p>
<p>For Windows, you should install the toolkit with enabled Visual Studio integration to be able to use the provided project files.</p>
<p>For Linux and Mac OS X, you have to provide the path to the CUDA Toolkit installation via a <code>"CUDA_PATH"</code> environment variable or by setting the path in the <code>Makefile</code>.</p>
<p><b>Source Code Location:</b> <code>examples/mdl_sdk/execution_cuda/example_execution_cuda.cpp</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/execution_cuda/example_execution_cuda.cpp</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Introduces execution of the generated code for compiled material sub-expressions</span></div>
<div class="line"><span class="comment">// for the PTX backend with CUDA.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Enable this to dump the generated PTX code to stdout.</span></div>
<div class="line"><span class="comment">// #define DUMP_PTX</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;example_cuda_shared.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Command line options structure.</span></div>
<div class="line"><span class="keyword">struct </span>Options {</div>
<div class="line">    <span class="comment">// The CUDA device ID.</span></div>
<div class="line">    <span class="keywordtype">int</span> cuda_device;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// An result output file name.</span></div>
<div class="line">    std::string outputfile;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The pattern number representing the combination of materials to display.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> material_pattern;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The resolution of the display / image.</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> res_x, res_y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whether class compilation should be used for the materials.</span></div>
<div class="line">    <span class="keywordtype">bool</span> use_class_compilation;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Disables pixel oversampling.</span></div>
<div class="line">    <span class="keywordtype">bool</span> no_aa;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whether derivative support should be enabled.</span></div>
<div class="line">    <span class="keywordtype">bool</span> enable_derivatives;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Whether terninary operators on *df types are executed at runtime or folded at compile time.</span></div>
<div class="line">    <span class="keywordtype">bool</span> fold_ternary_on_df;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of materials to use.</span></div>
<div class="line">    std::vector&lt;std::string&gt; material_names;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The constructor.</span></div>
<div class="line">    Options()</div>
<div class="line">        : cuda_device(0)</div>
<div class="line">        , outputfile()</div>
<div class="line">        , material_pattern(0)</div>
<div class="line">        , res_x(700)</div>
<div class="line">        , res_y(520)</div>
<div class="line">        , use_class_compilation(false)</div>
<div class="line">        , no_aa(false)</div>
<div class="line">        , enable_derivatives(false)</div>
<div class="line">        , fold_ternary_on_df(false)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Bake the material sub-expressions created with the PTX backend into a canvas with the given</span></div>
<div class="line"><span class="comment">// resolution and the given number of samples for super-sampling.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> *bake_expression_cuda_ptx(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>         *image_api,</div>
<div class="line">    std::vector&lt;<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> &gt; <span class="keyword">const</span> &amp;target_codes,</div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span>         &amp;arg_block_indices,</div>
<div class="line">    Options                           &amp;options,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a>                         num_samples)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Build the full CUDA kernel with all the generated code</span></div>
<div class="line">    CUfunction  cuda_function;</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *ptx_name = options.enable_derivatives ?</div>
<div class="line">        <span class="stringliteral">&quot;example_execution_cuda_derivatives.ptx&quot;</span> : <span class="stringliteral">&quot;example_execution_cuda.ptx&quot;</span>;</div>
<div class="line">    CUmodule    cuda_module = build_linked_kernel(</div>
<div class="line">        target_codes,</div>
<div class="line">        (mi::examples::io::get_executable_folder() + <span class="stringliteral">&quot;/&quot;</span> + ptx_name).c_str(),</div>
<div class="line">        <span class="stringliteral">&quot;evaluate_mat_expr&quot;</span>,</div>
<div class="line">        &amp;cuda_function);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the needed data of all target codes for the GPU</span></div>
<div class="line">    Material_gpu_context material_gpu_context(options.enable_derivatives);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, num_target_codes = target_codes.size(); i &lt; num_target_codes; ++i) {</div>
<div class="line">        <span class="keywordflow">if</span> (!material_gpu_context.prepare_target_code_data(</div>
<div class="line">                transaction, image_api, target_codes[i].get(), arg_block_indices))</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line">    CUdeviceptr device_tc_data_list = material_gpu_context.get_device_target_code_data_list();</div>
<div class="line">    CUdeviceptr device_arg_block_list =</div>
<div class="line">        material_gpu_context.get_device_target_argument_block_list();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate GPU output buffer</span></div>
<div class="line">    CUdeviceptr device_outbuf;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;device_outbuf, options.res_x * options.res_y * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Launch kernel for the whole image</span></div>
<div class="line">    dim3 threads_per_block(16, 16);</div>
<div class="line">    dim3 num_blocks((options.res_x + 15) / 16, (options.res_y + 15) / 16);</div>
<div class="line">    <span class="keywordtype">void</span> *kernel_params[] = {</div>
<div class="line">        &amp;device_outbuf,</div>
<div class="line">        &amp;device_tc_data_list,</div>
<div class="line">        &amp;device_arg_block_list,</div>
<div class="line">        &amp;options.res_x,</div>
<div class="line">        &amp;options.res_y,</div>
<div class="line">        &amp;num_samples</div>
<div class="line">    };</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuLaunchKernel(</div>
<div class="line">        cuda_function,</div>
<div class="line">        num_blocks.x, num_blocks.y, num_blocks.z,</div>
<div class="line">        threads_per_block.x, threads_per_block.y, threads_per_block.z,</div>
<div class="line">        0, <span class="keyword">nullptr</span>, kernel_params, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create a canvas (with only one tile) and copy the result image to it</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> canvas(</div>
<div class="line">        image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a4f776e1c0271e6898a3585c0bf8099cd" title="Creates a canvas with given pixel type, resolution, and layers. ">create_canvas</a>(<span class="stringliteral">&quot;Rgb_fp&quot;</span>, options.res_x, options.res_y));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">    float3 *data = <span class="keyword">static_cast&lt;</span>float3 *<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line">    check_cuda_success(cuMemcpyDtoH(</div>
<div class="line">        data, device_outbuf, options.res_x * options.res_y * <span class="keyword">sizeof</span>(float3)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup resources not handled by Material_gpu_context</span></div>
<div class="line">    check_cuda_success(cuMemFree(device_outbuf));</div>
<div class="line">    check_cuda_success(cuModuleUnload(cuda_module));</div>
<div class="line"></div>
<div class="line">    canvas-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> usage(<span class="keywordtype">char</span> <span class="keyword">const</span> *prog_name)</div>
<div class="line">{</div>
<div class="line">    std::cout</div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Usage: &quot;</span> &lt;&lt; prog_name &lt;&lt; <span class="stringliteral">&quot; [options] [(&lt;material_pattern | (&lt;material_name1&gt; ...)]\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;Options:\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --device &lt;id&gt;        run on CUDA device &lt;id&gt; (default: 0)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --res &lt;x&gt; &lt;y&gt;        resolution (default: 700x520)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --cc                 use class compilation\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --noaa               disable pixel oversampling\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  -d                   enable use of derivatives\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  -o &lt;outputfile&gt;      image file to write result to\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                       (default: example_cuda_&lt;material_pattern&gt;.png)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --mdl_path &lt;path&gt;    mdl search path, can occur multiple times.\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  --fold_ternary_on_df fold all ternary operators on *df types\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  &lt;material_pattern&gt;   a number from 1 to 2 ^ num_materials - 1 choosing which\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                       material combination to use (default: 2 ^ num_materials - 1)\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;  &lt;material_name*&gt;     qualified name of materials to use. The example will try to\n&quot;</span></div>
<div class="line">        &lt;&lt; <span class="stringliteral">&quot;                       access the path \&quot;surface.scattering.tint\&quot;.&quot;</span></div>
<div class="line">        &lt;&lt; std::endl;</div>
<div class="line">    exit_failure();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Main function</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> MAIN_UTF8(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Parse command line options</span></div>
<div class="line">    Options options;</div>
<div class="line">    mi::examples::mdl::Configure_options configure_options;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; argc; ++i) {</div>
<div class="line">        <span class="keywordtype">char</span> <span class="keyword">const</span> *opt = argv[i];</div>
<div class="line">        <span class="keywordflow">if</span> (opt[0] == <span class="charliteral">&#39;-&#39;</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-o&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                options.outputfile = argv[++i];</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--device&quot;</span>) == 0 &amp;&amp; i &lt; argc - 2) {</div>
<div class="line">                options.cuda_device = atoi(argv[++i]);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--res&quot;</span>) == 0 &amp;&amp; i &lt; argc - 2) {</div>
<div class="line">                options.res_x = std::max(atoi(argv[++i]), 1);</div>
<div class="line">                options.res_y = std::max(atoi(argv[++i]), 1);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--cc&quot;</span>) == 0) {</div>
<div class="line">                options.use_class_compilation = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--noaa&quot;</span>) == 0) {</div>
<div class="line">                options.no_aa = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;-d&quot;</span>) == 0) {</div>
<div class="line">                options.enable_derivatives = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--mdl_path&quot;</span>) == 0 &amp;&amp; i &lt; argc - 1) {</div>
<div class="line">                configure_options.additional_mdl_paths.push_back(argv[++i]);</div>
<div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(opt, <span class="stringliteral">&quot;--fold_ternary_on_df&quot;</span>) == 0) {</div>
<div class="line">                options.fold_ternary_on_df = <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Unknown option: \&quot;&quot;</span> &lt;&lt; opt &lt;&lt; <span class="stringliteral">&quot;\&quot;&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                usage(argv[0]);</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (opt[0] &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; opt[0] &lt;= <span class="charliteral">&#39;9&#39;</span>) {</div>
<div class="line">            options.material_pattern = unsigned(atoi(opt));</div>
<div class="line">        } <span class="keywordflow">else</span></div>
<div class="line">            options.material_names.push_back(std::string(opt));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use default materials, if none was provided via command line</span></div>
<div class="line">    <span class="keywordflow">if</span> (options.material_names.empty()) {</div>
<div class="line">        options.material_names.push_back(<span class="stringliteral">&quot;::nvidia::sdk_examples::tutorials::example_execution1&quot;</span>);</div>
<div class="line">        options.material_names.push_back(<span class="stringliteral">&quot;::nvidia::sdk_examples::tutorials::example_execution2&quot;</span>);</div>
<div class="line">        options.material_names.push_back(<span class="stringliteral">&quot;::nvidia::sdk_examples::tutorials::example_execution3&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (options.material_pattern == 0)</div>
<div class="line">        options.material_pattern = (1 &lt;&lt; options.material_names.size()) - 1;</div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (options.material_pattern &lt; 1 ||</div>
<div class="line">            options.material_pattern &gt; <span class="keywordtype">unsigned</span>(1 &lt;&lt; options.material_names.size()) - 1) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid material_pattern parameter.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        usage(argv[0]);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (options.outputfile.empty())</div>
<div class="line">        options.outputfile = <span class="stringliteral">&quot;example_cuda_&quot;</span> + to_string(options.material_pattern) + <span class="stringliteral">&quot;.png&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Access the MDL SDK</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::INeuray&gt;</a> neuray(mi::examples::mdl::load_and_get_ineuray());</div>
<div class="line">    <span class="keywordflow">if</span> (!neuray.is_valid_interface())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to load the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Configure the MDL SDK</span></div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::configure(neuray.get(), configure_options))</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Start the MDL SDK</span></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> ret = neuray-&gt;start();</div>
<div class="line">    <span class="keywordflow">if</span> (ret != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to initialize the SDK. Result code: %d&quot;</span>, ret);</div>
<div class="line"></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Create a transaction</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IDatabase&gt;</a> database(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IDatabase.html" title="This interface is used to interact with the distributed database. ">mi::neuraylib::IDatabase</a>&gt;());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IScope&gt;</a> scope(database-&gt;get_global_scope());</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a> transaction(scope-&gt;create_transaction());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Access needed API components</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a> mdl_factory(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> mdl_impexp_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend_api&gt;</a> mdl_backend_api(</div>
<div class="line">            neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_execution_context&gt;</a> context(</div>
<div class="line">            mdl_factory-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a78a9a6489592c90ea49e0fe0ac8be235" title="Creates an execution context. ">create_execution_context</a>());</div>
<div class="line"></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Generate code for material sub-expressions of different materials</span></div>
<div class="line">            <span class="comment">// according to the requested material pattern</span></div>
<div class="line">            std::vector&lt;mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt; &gt; target_codes;</div>
<div class="line"></div>
<div class="line">            Material_compiler mc(</div>
<div class="line">                mdl_impexp_api.get(),</div>
<div class="line">                mdl_backend_api.get(),</div>
<div class="line">                mdl_factory.get(),</div>
<div class="line">                transaction.get(),</div>
<div class="line">                <span class="comment">/*num_texture_results=*/</span> 0,</div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>                <span class="comment">/*use_df_interpreter=*/</span> <span class="keyword">false</span>,</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>                options.enable_derivatives,</div>
<div class="line">                options.fold_ternary_on_df,</div>
<div class="line">                <span class="comment">/*enable_axuiliary_output*/</span> <span class="keyword">false</span>,</div>
<div class="line">                <span class="comment">/*use_adapt_normal*/</span> <span class="keyword">false</span>,</div>
<div class="line">                <span class="comment">/*df_handle_mode*/</span> <span class="stringliteral">&quot;none&quot;</span>);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (std::size_t i = 0, n = options.material_names.size(); i &lt; n; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> ((options.material_pattern &amp; (1 &lt;&lt; i)) != 0) {</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// split module and material name</span></div>
<div class="line">                    std::string module_name, material_simple_name;</div>
<div class="line">                    <span class="keywordflow">if</span> (!mi::examples::mdl::parse_cmd_argument_material_name(</div>
<div class="line">                        options.material_names[i], module_name, material_simple_name, <span class="keyword">true</span>))</div>
<div class="line">                            <span class="keywordflow">continue</span>;</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// load the module.</span></div>
<div class="line">                    mdl_impexp_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a5e195d80915190eb40c5995ccfeaa4c9" title="Loads an MDL module from disk (or a builtin module) into the database. ">load_module</a>(transaction.get(), module_name.c_str(), context.get());</div>
<div class="line">                    <span class="keywordflow">if</span> (!print_messages(context.get()))</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Loading module &#39;%s&#39; failed.&quot;</span>, module_name.c_str());</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// get the database name for the module we loaded</span></div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::IString&gt;</a> module_db_name(</div>
<div class="line">                        mdl_factory-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html#a72a27c9e0d66e79391ff9a8e3ce4a119" title="Returns the DB name for the MDL name of a module (or file path for MDLE modules). ...">get_db_module_name</a>(module_name.c_str()));</div>
<div class="line">                    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IModule&gt;</a> module(</div>
<div class="line">                        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IModule.html" title="This interface represents an MDL module. ">mi::neuraylib::IModule</a>&gt;(module_db_name-&gt;get_c_str()));</div>
<div class="line">                    <span class="keywordflow">if</span> (!module)</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Failed to access the loaded module.&quot;</span>);</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// Attach the material name</span></div>
<div class="line">                    std::string material_db_name</div>
<div class="line">                        = std::string(module_db_name-&gt;get_c_str()) + <span class="stringliteral">&quot;::&quot;</span> + material_simple_name;</div>
<div class="line">                    material_db_name = mi::examples::mdl::add_missing_material_signature(</div>
<div class="line">                        module.get(), material_db_name);</div>
<div class="line">                    <span class="keywordflow">if</span> (material_db_name.empty())</div>
<div class="line">                        exit_failure(<span class="stringliteral">&quot;Failed to find the material %s in the module %s.&quot;</span>,</div>
<div class="line">                            material_simple_name.c_str(), module_name.c_str());</div>
<div class="line"></div>
<div class="line">                    <span class="comment">// add the sub expression</span></div>
<div class="line">                    mc.add_material_subexpr(</div>
<div class="line">                        module_name, material_db_name,</div>
<div class="line">                        <span class="stringliteral">&quot;surface.scattering.tint&quot;</span>, (<span class="stringliteral">&quot;tint_&quot;</span> + to_string(i)).c_str(),</div>
<div class="line">                        options.use_class_compilation);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Generate target code for link unit</span></div>
<div class="line">            target_codes.push_back(mc.generate_cuda_ptx());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Acquire image API needed to prepare the textures and to create a canvas for baking</span></div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IImage_api&gt;</a> image_api(</div>
<div class="line">                neuray-&gt;get_api_component&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>&gt;());</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Bake the material sub-expressions into a canvas</span></div>
<div class="line">            CUcontext cuda_context = init_cuda(options.cuda_device);</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> canvas(</div>
<div class="line">                bake_expression_cuda_ptx(</div>
<div class="line">                    transaction.get(),</div>
<div class="line">                    image_api.get(),</div>
<div class="line">                    target_codes,</div>
<div class="line">                    mc.get_argument_block_indices(),</div>
<div class="line">                    options,</div>
<div class="line">                    options.no_aa ? 1 : 8));</div>
<div class="line">            uninit_cuda(cuda_context);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Export the canvas to an image on disk</span></div>
<div class="line">            <span class="keywordflow">if</span> (canvas)</div>
<div class="line">                mdl_impexp_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html#a1b544c77874b97eae0003c39e27e2103" title="Exports a canvas to a file on disk. ">export_canvas</a>(options.outputfile.c_str(), canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#aa4ff8152107db238986b364273bceb0c" title="Commits the transaction. ">commit</a>();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Shut down the MDL SDK</span></div>
<div class="line">    <span class="keywordflow">if</span> (neuray-&gt;shutdown() != 0)</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to shutdown the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Unload the MDL SDK</span></div>
<div class="line">    neuray = <span class="keyword">nullptr</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!mi::examples::mdl::unload())</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to unload the SDK.&quot;</span>);</div>
<div class="line"></div>
<div class="line">    exit_success();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Convert command line arguments to UTF8 on Windows</span></div>
<div class="line">COMMANDLINE_TO_UTF8</div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/shared/texture_support_cuda.h</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/shared/texture_support_cuda.h</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This file contains the implementations and the vtables of the texture access functions.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEXTURE_SUPPORT_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define TEXTURE_SUPPORT_CUDA_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;cuda.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="target__code__types_8h.html" title="Types required for execution of generated native and CUDA code. ">mi/neuraylib/target_code_types.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define USE_SMOOTHERSTEP_FILTER</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#ifndef M_PI</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define M_PI            3.14159265358979323846</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define M_ONE_OVER_PI       0.318309886183790671538</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga69137bb7a93d941a5a8578ca4c772fbf" title="A float with derivatives. ">mi::neuraylib::tct_deriv_float</a>                     <a class="code" href="group__mi__neuray__mdl__compiler.html#ga69137bb7a93d941a5a8578ca4c772fbf" title="A float with derivatives. ">tct_deriv_float</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga067809015fbce254f57a2d1de28a7a14" title="A float2 with derivatives. ">mi::neuraylib::tct_deriv_float2</a>                    <a class="code" href="group__mi__neuray__mdl__compiler.html#ga067809015fbce254f57a2d1de28a7a14" title="A float2 with derivatives. ">tct_deriv_float2</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_2</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#ga955d747a7ae62b5e18e9f4359743136d" title="A float[2] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_2</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_3</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#gac1f3572aefe12967db565ec2b2dc0a07" title="A float[3] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_3</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1tct__deriv.html" title="A template struct with derivatives. ">mi::neuraylib::tct_deriv_arr_float_4</a>               <a class="code" href="group__mi__neuray__mdl__compiler.html#ga4213c9623560d5dc3839c8c6ebb097ac" title="A float[4] with derivatives (needed to avoid problems with wrong alignment). ">tct_deriv_arr_float_4</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Shading__state__material__impl.html" title="The MDL material state structure inside the MDL SDK is a representation of the renderer state as defi...">mi::neuraylib::Shading_state_material_with_derivs</a>  <a class="code" href="group__mi__neuray__mdl__compiler.html#ga8ffb20982d3063f617cb7fbeccdf7f36" title="The MDL material state structure with derivatives for the texture coordinates. ">Shading_state_material_with_derivs</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Shading__state__material__impl.html" title="The MDL material state structure inside the MDL SDK is a representation of the renderer state as defi...">mi::neuraylib::Shading_state_material</a>              <a class="code" href="group__mi__neuray__mdl__compiler.html#ga8a42cb80b6772ce4b266f2311b0561c1" title="The MDL material state structure. ">Shading_state_material</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__base.html" title="The texture handler structure that is passed to the texturing functions. ">mi::neuraylib::Texture_handler_base</a>                Texture_handler_base;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga852d194e585ada01cc272e85e367ca9b" title="The texture wrap modes as defined by tex::wrap_mode in the MDL specification. ">mi::neuraylib::Tex_wrap_mode</a>                       <a class="code" href="group__mi__neuray__mdl__compiler.html#ga852d194e585ada01cc272e85e367ca9b" title="The texture wrap modes as defined by tex::wrap_mode in the MDL specification. ">Tex_wrap_mode</a>;</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a>                          <a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">Mbsdf_part</a>;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom structure representing an MDL texture, containing filtered and unfiltered CUDA texture</span></div>
<div class="line"><span class="comment">// objects and the size of the texture.</span></div>
<div class="line"><span class="keyword">struct </span>Texture</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Texture()</div>
<div class="line">        : filtered_object(0)</div>
<div class="line">        , unfiltered_object(0)</div>
<div class="line">        , size(make_uint3(0, 0, 0))</div>
<div class="line">        , inv_size(make_float3(0.0f, 0.0f, 0.0f))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keyword">explicit</span> Texture(</div>
<div class="line">        cudaTextureObject_t  filtered_object,</div>
<div class="line">        cudaTextureObject_t  unfiltered_object,</div>
<div class="line">        uint3                size)</div>
<div class="line">        : filtered_object(filtered_object)</div>
<div class="line">        , unfiltered_object(unfiltered_object)</div>
<div class="line">        , size(size)</div>
<div class="line">        , inv_size(make_float3(1.0f / size.x, 1.0f / size.y, 1.0f / size.z))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t  filtered_object;    <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    cudaTextureObject_t  unfiltered_object;  <span class="comment">// uses filter mode cudaFilterModePoint</span></div>
<div class="line">    uint3                size;               <span class="comment">// size of the texture, needed for texel access</span></div>
<div class="line">    float3               inv_size;           <span class="comment">// the inverse values of the size of the texture</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom structure representing an MDL BSDF measurement.</span></div>
<div class="line"><span class="keyword">struct </span>Mbsdf</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span>            has_data[2];            <span class="comment">// true if there is a measurement for this part</span></div>
<div class="line">    cudaTextureObject_t eval_data[2];           <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    <span class="keywordtype">float</span>               max_albedo[2];          <span class="comment">// max albedo used to limit the multiplier</span></div>
<div class="line">    <span class="keywordtype">float</span>*              sample_data[2];         <span class="comment">// CDFs for sampling a BSDF measurement</span></div>
<div class="line">    <span class="keywordtype">float</span>*              albedo_data[2];         <span class="comment">// max albedo for each theta (isotropic)</span></div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution[2];      <span class="comment">// size of the dataset, needed for texel access</span></div>
<div class="line">    float2          inv_angular_resolution[2];  <span class="comment">// the inverse values of the size of the dataset</span></div>
<div class="line">    <span class="keywordtype">unsigned</span>        num_channels[2];            <span class="comment">// number of color channels (1 or 3)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing a Light Profile</span></div>
<div class="line"><span class="keyword">struct </span>Lightprofile</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Lightprofile()</div>
<div class="line">        : angular_resolution(make_uint2(0, 0))</div>
<div class="line">        , inv_angular_resolution(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_start(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">        , theta_phi_inv_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">        , candela_multiplier(0.0f)</div>
<div class="line">        , total_power(0.0f)</div>
<div class="line">        , eval_data(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution;     <span class="comment">// angular resolution of the grid</span></div>
<div class="line">    float2          inv_angular_resolution; <span class="comment">// inverse angular resolution of the grid</span></div>
<div class="line">    float2          theta_phi_start;        <span class="comment">// start of the grid</span></div>
<div class="line">    float2          theta_phi_delta;        <span class="comment">// angular step size</span></div>
<div class="line">    float2          theta_phi_inv_delta;    <span class="comment">// inverse step size</span></div>
<div class="line">    <span class="keywordtype">float</span>           candela_multiplier;     <span class="comment">// factor to rescale the normalized data</span></div>
<div class="line">    <span class="keywordtype">float</span>           total_power;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t eval_data;          <span class="comment">// normalized data sampled on grid</span></div>
<div class="line">    <span class="keywordtype">float</span>*              cdf_data;           <span class="comment">// CDFs for sampling a light profile</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The texture handler structure required by the MDL SDK with custom additional fields.</span></div>
<div class="line"><span class="keyword">struct </span>Texture_handler : Texture_handler_base {</div>
<div class="line">    <span class="comment">// additional data for the texture access functions can be provided here</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_textures;        <span class="comment">// the number of textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Texture <span class="keyword">const</span> *textures;            <span class="comment">// the textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_mbsdfs;          <span class="comment">// the number of mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid mbsdf)</span></div>
<div class="line">    Mbsdf <span class="keyword">const</span>    *mbsdfs;             <span class="comment">// the mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid mbsdf)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>          num_lightprofiles;  <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">    Lightprofile <span class="keyword">const</span> *lightprofiles;  <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The texture handler structure required by the MDL SDK with custom additional fields.</span></div>
<div class="line"><span class="keyword">struct </span>Texture_handler_deriv : <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__deriv__base.html" title="The texture handler structure that is passed to the texturing functions with derivative support...">mi::neuraylib::Texture_handler_deriv_base</a> {</div>
<div class="line">    <span class="comment">// additional data for the texture access functions can be provided here</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_textures;        <span class="comment">// the number of textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Texture <span class="keyword">const</span> *textures;            <span class="comment">// the textures used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>         num_mbsdfs;          <span class="comment">// the number of mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line">    Mbsdf <span class="keyword">const</span>    *mbsdfs;             <span class="comment">// the mbsdfs used by the material</span></div>
<div class="line">                                        <span class="comment">// (without the invalid texture)</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>          num_lightprofiles;  <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">    Lightprofile <span class="keyword">const</span> *lightprofiles;  <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line">                                        <span class="comment">// (without the invalid light profile)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if defined(__CUDACC__)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Stores a float4 in a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(<span class="keywordtype">float</span> res[4], <span class="keyword">const</span> float4 &amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">    res[3] = v.w;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float in all elements of a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(<span class="keywordtype">float</span> res[4], <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    res[0] = res[1] = res[2] = res[3] = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the given float values in a float[4] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result4(</div>
<div class="line">    <span class="keywordtype">float</span> res[4], <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2, <span class="keywordtype">float</span> v3)</div>
<div class="line">{</div>
<div class="line">    res[0] = v0;</div>
<div class="line">    res[1] = v1;</div>
<div class="line">    res[2] = v2;</div>
<div class="line">    res[3] = v3;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float3 in a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], float3 <span class="keyword">const</span>&amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float4 in a float[3] array, ignoring v.w.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keyword">const</span> float4 &amp;v)</div>
<div class="line">{</div>
<div class="line">    res[0] = v.x;</div>
<div class="line">    res[1] = v.y;</div>
<div class="line">    res[2] = v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a float in all elements of a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    res[0] = res[1] = res[2] = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the given float values in a float[3] array.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result3(<span class="keywordtype">float</span> res[3], <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2)</div>
<div class="line">{</div>
<div class="line">    res[0] = v0;</div>
<div class="line">    res[1] = v1;</div>
<div class="line">    res[2] = v2;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the luminance if a given float[3] in a float.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, float3 <span class="keyword">const</span>&amp; v)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// store luminance</span></div>
<div class="line">    *res = 0.212671 * v.x + 0.715160 * v.y + 0.072169 * v.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores the luminance if a given float[3] in a float.</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, <span class="keywordtype">float</span> v0, <span class="keywordtype">float</span> v1, <span class="keywordtype">float</span> v2)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// store luminance</span></div>
<div class="line">    *res = 0.212671 * v0 + 0.715160 * v1 + 0.072169 * v2;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Stores a given float in a float</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> store_result1(<span class="keywordtype">float</span>* res, <span class="keywordtype">float</span> s)</div>
<div class="line">{</div>
<div class="line">    *res = s;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Textures</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Applies wrapping and cropping to the given coordinate.</span></div>
<div class="line"><span class="comment">// Note: This macro returns if wrap mode is clip and the coordinate is out of range.</span></div>
<div class="line"><span class="preprocessor">#define WRAP_AND_CROP_OR_RETURN_BLACK(val, inv_dim, wrap_mode, crop_vals, store_res_func)    \</span></div>
<div class="line"><span class="preprocessor">  do {                                                                                       \</span></div>
<div class="line"><span class="preprocessor">    if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_REPEAT &amp;&amp;                                    \</span></div>
<div class="line"><span class="preprocessor">        (crop_vals)[0] == 0.0f &amp;&amp; (crop_vals)[1] == 1.0f ) {                                 \</span></div>
<div class="line"><span class="preprocessor">      </span><span class="comment">/* Do nothing, use texture sampler default behavior */</span><span class="preprocessor">                                 \</span></div>
<div class="line"><span class="preprocessor">    }                                                                                        \</span></div>
<div class="line"><span class="preprocessor">    else                                                                                     \</span></div>
<div class="line"><span class="preprocessor">    {                                                                                        \</span></div>
<div class="line"><span class="preprocessor">      if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_REPEAT )                                   \</span></div>
<div class="line"><span class="preprocessor">        val = val - floorf(val);                                                             \</span></div>
<div class="line"><span class="preprocessor">      else {                                                                                 \</span></div>
<div class="line"><span class="preprocessor">        if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_CLIP &amp;&amp; (val &lt; 0.0f || val &gt;= 1.0f) ) {  \</span></div>
<div class="line"><span class="preprocessor">          store_res_func(result, 0.0f);                                                      \</span></div>
<div class="line"><span class="preprocessor">          return;                                                                            \</span></div>
<div class="line"><span class="preprocessor">        }                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        else if ( (wrap_mode) == mi::neuraylib::TEX_WRAP_MIRRORED_REPEAT ) {                 \</span></div>
<div class="line"><span class="preprocessor">          float floored_val = floorf(val);                                                   \</span></div>
<div class="line"><span class="preprocessor">          if ( (int(floored_val) &amp; 1) != 0 )                                                 \</span></div>
<div class="line"><span class="preprocessor">            val = 1.0f - (val - floored_val);                                                \</span></div>
<div class="line"><span class="preprocessor">          else                                                                               \</span></div>
<div class="line"><span class="preprocessor">            val = val - floored_val;                                                         \</span></div>
<div class="line"><span class="preprocessor">        }                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        float inv_hdim = 0.5f * (inv_dim);                                                   \</span></div>
<div class="line"><span class="preprocessor">        val = fminf(fmaxf(val, inv_hdim), 1.f - inv_hdim);                                   \</span></div>
<div class="line"><span class="preprocessor">      }                                                                                      \</span></div>
<div class="line"><span class="preprocessor">      val = val * ((crop_vals)[1] - (crop_vals)[0]) + (crop_vals)[0];                        \</span></div>
<div class="line"><span class="preprocessor">    }                                                                                        \</span></div>
<div class="line"><span class="preprocessor">  } while ( 0 )</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef USE_SMOOTHERSTEP_FILTER</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// Modify texture coordinates to get better texture filtering,</span></div>
<div class="line"><span class="comment">// see http://www.iquilezles.org/www/articles/texture/texture.htm</span></div>
<div class="line"><span class="preprocessor">#define APPLY_SMOOTHERSTEP_FILTER()                                                         \</span></div>
<div class="line"><span class="preprocessor">    do {                                                                                    \</span></div>
<div class="line"><span class="preprocessor">        u = u * tex.size.x + 0.5f;                                                          \</span></div>
<div class="line"><span class="preprocessor">        v = v * tex.size.y + 0.5f;                                                          \</span></div>
<div class="line"><span class="preprocessor">                                                                                            \</span></div>
<div class="line"><span class="preprocessor">        float u_i = floorf(u), v_i = floorf(v);                                             \</span></div>
<div class="line"><span class="preprocessor">        float u_f = u - u_i;                                                                \</span></div>
<div class="line"><span class="preprocessor">        float v_f = v - v_i;                                                                \</span></div>
<div class="line"><span class="preprocessor">        u_f = u_f * u_f * u_f * (u_f * (u_f * 6.f - 15.f) + 10.f);                          \</span></div>
<div class="line"><span class="preprocessor">        v_f = v_f * v_f * v_f * (v_f * (v_f * 6.f - 15.f) + 10.f);                          \</span></div>
<div class="line"><span class="preprocessor">        u = u_i + u_f;                                                                      \</span></div>
<div class="line"><span class="preprocessor">        v = v_i + v_f;                                                                      \</span></div>
<div class="line"><span class="preprocessor">                                                                                            \</span></div>
<div class="line"><span class="preprocessor">        u = (u - 0.5f) * tex.inv_size.x;                                                    \</span></div>
<div class="line"><span class="preprocessor">        v = (v - 0.5f) * tex.inv_size.y;                                                    \</span></div>
<div class="line"><span class="preprocessor">    } while ( 0 )</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define APPLY_SMOOTHERSTEP_FILTER()</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[2],</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2D&lt;float4&gt;(tex.filtered_object, u, v));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_deriv_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    tct_deriv_float2 <span class="keyword">const</span>     *coord,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord-&gt;val.x, v = coord-&gt;val.y;</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2DGrad&lt;float4&gt;(tex.filtered_object, u, v, coord-&gt;dx, coord-&gt;dy));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[2],</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex2D&lt;float4&gt;(tex.filtered_object, u, v));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_2d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_deriv_float3_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    tct_deriv_float2 <span class="keyword">const</span>     *coord,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_u,</div>
<div class="line">    Tex_wrap_mode <span class="keyword">const</span>         wrap_v,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    <span class="keywordtype">float</span> u = coord-&gt;val.x, v = coord-&gt;val.y;</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line"></div>
<div class="line">    APPLY_SMOOTHERSTEP_FILTER();</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex2DGrad&lt;float4&gt;(tex.filtered_object, u, v, coord-&gt;dx, coord-&gt;dy));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::texel_float4() for a texture_2d texture.</span></div>
<div class="line"><span class="comment">// Note: uvtile and/or animated textures are not supported</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_texel_float4_2d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   coord[2],</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   <span class="comment">/*uv_tile*/</span>[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex2D&lt;float4&gt;(</div>
<div class="line">        tex.unfiltered_object,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[0]) * tex.inv_size.x,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[1]) * tex.inv_size.y));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3],</div>
<div class="line">    Tex_wrap_mode               wrap_u,</div>
<div class="line">    Tex_wrap_mode               wrap_v,</div>
<div class="line">    Tex_wrap_mode               wrap_w,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_w[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1], w = coord[2];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result4);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(w, tex.inv_size.z, wrap_w, crop_w, store_result4);</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex3D&lt;float4&gt;(tex.filtered_object, u, v, w));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3],</div>
<div class="line">    Tex_wrap_mode               wrap_u,</div>
<div class="line">    Tex_wrap_mode               wrap_v,</div>
<div class="line">    Tex_wrap_mode               wrap_w,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_u[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_v[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 crop_w[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> u = coord[0], v = coord[1], w = coord[2];</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(u, tex.inv_size.x, wrap_u, crop_u, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(v, tex.inv_size.y, wrap_v, crop_v, store_result3);</div>
<div class="line">    WRAP_AND_CROP_OR_RETURN_BLACK(w, tex.inv_size.z, wrap_w, crop_w, store_result3);</div>
<div class="line"></div>
<div class="line">    store_result3(result, tex3D&lt;float4&gt;(tex.filtered_object, u, v, w));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::texel_float4() for a texture_3d texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_texel_float4_3d(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>                   coord[3],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, tex3D&lt;float4&gt;(</div>
<div class="line">        tex.unfiltered_object,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[0]) * tex.inv_size.x,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[1]) * tex.inv_size.y,</div>
<div class="line">        <span class="keywordtype">float</span>(coord[2]) * tex.inv_size.z));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float4() for a texture_cube texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float4_cube(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result4(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result4(result, texCubemap&lt;float4&gt;(tex.filtered_object, coord[0], coord[1], coord[2]));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of tex::lookup_float3() for a texture_cube texture.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_lookup_float3_cube(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 coord[3])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line"></div>
<div class="line">    store_result3(result, texCubemap&lt;float4&gt;(tex.filtered_object, coord[0], coord[1], coord[2]));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of resolution_2d function needed by generated code.</span></div>
<div class="line"><span class="comment">// Note: uvtile and/or animated textures are not supported</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_resolution_2d(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                   <span class="comment">/*uv_tile*/</span>[2],</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> ( texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures ) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span> &amp;tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    result[0] = tex.size.x;</div>
<div class="line">    result[1] = tex.size.y;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of resolution_3d function needed by generated code.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_resolution_3d(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx,</div>
<div class="line">    <span class="keywordtype">float</span>                       <span class="comment">/*frame*/</span>)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span>* <span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler const*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Texture <span class="keyword">const</span>&amp; tex = <span class="keyword">self</span>-&gt;textures[texture_idx - 1];</div>
<div class="line">    result[0] = tex.size.x;</div>
<div class="line">    result[1] = tex.size.y;</div>
<div class="line">    result[2] = tex.size.z;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of texture_isvalid().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> tex_texture_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> texture_idx != 0 &amp;&amp; texture_idx - 1 &lt; <span class="keyword">self</span>-&gt;num_textures;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of frame function needed by generated code.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> tex_frame(</div>
<div class="line">    <span class="keywordtype">int</span>                         result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    texture_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span>* <span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler const*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (texture_idx == 0 || texture_idx - 1 &gt;= self-&gt;num_textures) {</div>
<div class="line">        <span class="comment">// invalid texture returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Texture const&amp; tex = self-&gt;textures[texture_idx - 1];</span></div>
<div class="line">    result[0] = 0;</div>
<div class="line">    result[1] = 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Light Profiles</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_power() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_power(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    <span class="keywordflow">return</span> lp.total_power;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_maximum() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_maximum(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    <span class="keywordflow">return</span> lp.candela_multiplier;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of light_profile_isvalid() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> df_light_profile_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">return</span> light_profile_idx != 0 &amp;&amp; light_profile_idx - 1 &lt; <span class="keyword">self</span>-&gt;num_lightprofiles;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// binary search through CDF</span></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> sample_cdf(</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf,</div>
<div class="line">    <span class="keywordtype">unsigned</span> cdf_size,</div>
<div class="line">    <span class="keywordtype">float</span> xi)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">unsigned</span> li = 0;</div>
<div class="line">    <span class="keywordtype">unsigned</span> ri = cdf_size - 1;</div>
<div class="line">    <span class="keywordtype">unsigned</span> m = (li + ri) / 2;</div>
<div class="line">    <span class="keywordflow">while</span> (ri &gt; li)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (xi &lt; cdf[m])</div>
<div class="line">            ri = m;</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            li = m + 1;</div>
<div class="line"></div>
<div class="line">        m = (li + ri) / 2;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> m;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_evaluate() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_evaluate(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f; <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// map theta to 0..1 range</span></div>
<div class="line">    <span class="keywordtype">float</span> u = (theta_phi[0] - lp.theta_phi_start.x) *</div>
<div class="line">        lp.theta_phi_inv_delta.x * lp.inv_angular_resolution.x;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// converting input phi from -pi..pi to 0..2pi</span></div>
<div class="line">    <span class="keywordtype">float</span> phi = (theta_phi[1] &gt; 0.0f) ? theta_phi[1] : (float(2.0 * M_PI) + theta_phi[1]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// floorf wraps phi range into 0..2pi</span></div>
<div class="line">    phi = phi - lp.theta_phi_start.y -</div>
<div class="line">        floorf((phi - lp.theta_phi_start.y) * <span class="keywordtype">float</span>(0.5 / M_PI)) * float(2.0 * M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// (phi &lt; 0.0f) is no problem, this is handle by the (black) border</span></div>
<div class="line">    <span class="comment">// since it implies lp.theta_phi_start.y &gt; 0 (and we really have &quot;no data&quot; below that)</span></div>
<div class="line">    <span class="keywordtype">float</span> v = phi * lp.theta_phi_inv_delta.y * lp.inv_angular_resolution.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// half pixel offset</span></div>
<div class="line">    <span class="comment">// see https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#linear-filtering</span></div>
<div class="line">    u += 0.5f * lp.inv_angular_resolution.x;</div>
<div class="line">    v += 0.5f * lp.inv_angular_resolution.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wrap_mode: border black would be an alternative (but it produces artifacts at low res)</span></div>
<div class="line">    <span class="keywordflow">if</span> (u &lt; 0.0f || u &gt; 1.0f || v &lt; 0.0f || v &gt; 1.0f) <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> tex2D&lt;float&gt;(lp.eval_data, u, v) * lp.candela_multiplier;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_sample() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_light_profile_sample(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],          <span class="comment">// output: theta, phi, pdf</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 xi[3])              <span class="comment">// uniform random values</span></div>
<div class="line">{</div>
<div class="line">    result[0] = -1.0f;  <span class="comment">// negative theta means no emission</span></div>
<div class="line">    result[1] = -1.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line">    uint2 res = lp.angular_resolution;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample theta_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi0 = xi[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_theta = lp.cdf_data;                          <span class="comment">// CDF theta</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta = sample_cdf(cdf_data_theta, res.x - 1, xi0);    <span class="comment">// binary search</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_data_theta[idx_theta];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_theta[idx_theta - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">        xi0 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi0 /= prob_theta;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample phi_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi1 = xi[1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_phi = cdf_data_theta + (res.x - 1)            <span class="comment">// CDF theta block</span></div>
<div class="line">                              + (idx_theta * (res.y - 1));              <span class="comment">// selected CDF for phi</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> idx_phi = sample_cdf(cdf_data_phi, res.y - 1, xi1);        <span class="comment">// binary search</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_data_phi[idx_phi];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_phi[idx_phi - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">        xi1 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi1 /= prob_phi;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute theta and phi</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="comment">// sample uniformly within the patch (grid cell)</span></div>
<div class="line">    <span class="keyword">const</span> float2 start = lp.theta_phi_start;</div>
<div class="line">    <span class="keyword">const</span> float2 delta = lp.theta_phi_delta;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(start.x + <span class="keywordtype">float</span>(idx_theta)      * delta.x);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(start.x + <span class="keywordtype">float</span>(idx_theta + 1u) * delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//               n = \int_{\theta_0}^{\theta_1} \sin{\theta} \delta \theta</span></div>
<div class="line">    <span class="comment">//                 = 1 / (\cos{\theta_0} - \cos{\theta_1})</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">//             \xi = n * \int_{\theta_0}^{\theta_1} \sin{\theta} \delta \theta</span></div>
<div class="line">    <span class="comment">// =&gt; \cos{\theta} = (1 - \xi) \cos{\theta_0} + \xi \cos{\theta_1}</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta = (1.0f - xi1) * cos_theta_0 + xi1 * cos_theta_1;</div>
<div class="line">    result[0] = acosf(cos_theta);</div>
<div class="line">    result[1] = start.y + (float(idx_phi) + xi0) * delta.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// align phi</span></div>
<div class="line">    if (result[1] &gt; <span class="keywordtype">float</span>(2.0 * M_PI)) result[1] -= <span class="keywordtype">float</span>(2.0 * M_PI);              <span class="comment">// wrap</span></div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) result[1] = <span class="keywordtype">float</span>(-2.0 * M_PI) + result[1];  <span class="comment">// to [-pi, pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute pdf</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    result[2] = prob_theta * prob_phi / (delta.y * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::light_profile_pdf() for a light profile.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_light_profile_pdf(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    light_profile_idx,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (light_profile_idx == 0 || light_profile_idx - 1 &gt;= self-&gt;num_lightprofiles)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;  <span class="comment">// invalid light profile returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Lightprofile&amp; lp = <span class="keyword">self</span>-&gt;lightprofiles[light_profile_idx - 1];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data</span></div>
<div class="line">    <span class="keyword">const</span> uint2 res = lp.angular_resolution;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_theta = lp.cdf_data;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// map theta to 0..1 range</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> theta = theta_phi[0] - lp.theta_phi_start.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> idx_theta = int(theta * lp.theta_phi_inv_delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// converting input phi from -pi..pi to 0..2pi</span></div>
<div class="line">    <span class="keywordtype">float</span> phi = (theta_phi[1] &gt; 0.0f) ? theta_phi[1] : (<span class="keywordtype">float</span>(2.0 * M_PI) + theta_phi[1]);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// floorf wraps phi range into 0..2pi</span></div>
<div class="line">    phi = phi - lp.theta_phi_start.y -</div>
<div class="line">        floorf((phi - lp.theta_phi_start.y) * <span class="keywordtype">float</span>(0.5 / M_PI)) * float(2.0 * M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// (phi &lt; 0.0f) is no problem, this is handle by the (black) border</span></div>
<div class="line">    <span class="comment">// since it implies lp.theta_phi_start.y &gt; 0 (and we really have &quot;no data&quot; below that)</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> idx_phi = int(phi * lp.theta_phi_inv_delta.y);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// wrap_mode: border black would be an alternative (but it produces artifacts at low res)</span></div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &lt; 0 || idx_theta &gt; (res.x - 2) || idx_phi &lt; 0 || idx_phi &gt;(res.x - 2))</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability for theta</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_data_theta[idx_theta];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_theta[idx_theta - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability for phi</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_data_phi = cdf_data_theta</div>
<div class="line">        + (res.x - 1)                             <span class="comment">// CDF theta block</span></div>
<div class="line">        + (idx_theta * (res.y - 1));              <span class="comment">// selected CDF for phi</span></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_data_phi[idx_phi];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_data_phi[idx_phi - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute probability to select a position in the sphere patch</span></div>
<div class="line">    <span class="keyword">const</span> float2 start = lp.theta_phi_start;</div>
<div class="line">    <span class="keyword">const</span> float2 delta = lp.theta_phi_delta;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(start.x + <span class="keywordtype">float</span>(idx_theta)      * delta.x);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = <a class="code" href="group__mi__math__color.html#gabc5aea22823783b69d311547daddadf2" title="Returns a color with the elementwise cosine of the color c. ">cos</a>(start.x + <span class="keywordtype">float</span>(idx_theta + 1u) * delta.x);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> prob_theta * prob_phi / (delta.y * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// BSDF Measurements</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of bsdf_measurement_isvalid() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> df_bsdf_measurement_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span> *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">return</span> bsdf_measurement_index != 0 &amp;&amp; bsdf_measurement_index - 1 &lt; <span class="keyword">self</span>-&gt;num_mbsdfs;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_resolution() function needed by generated code,</span></div>
<div class="line"><span class="comment">// which retrieves the angular and chromatic resolution of the given MBSDF.</span></div>
<div class="line"><span class="comment">// The returned triple consists of: number of equi-spaced steps of theta_i and theta_o,</span></div>
<div class="line"><span class="comment">// number of equi-spaced steps of phi, and number of color channels (1 or 3).</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_resolution(</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    Mbsdf <span class="keyword">const</span> &amp;bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">    {</div>
<div class="line">        result[0] = 0;</div>
<div class="line">        result[1] = 0;</div>
<div class="line">        result[2] = 0;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// pass out the information</span></div>
<div class="line">    result[0] = bm.angular_resolution[part_index].x;</div>
<div class="line">    result[1] = bm.angular_resolution[part_index].y;</div>
<div class="line">    result[2] = bm.num_channels[part_index];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> float3 bsdf_compute_uvw(<span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_in[2],</div>
<div class="line">                                          <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_out[2])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// assuming each phi is between -pi and pi</span></div>
<div class="line">    <span class="keywordtype">float</span> u = theta_phi_out[1] - theta_phi_in[1];</div>
<div class="line">    <span class="keywordflow">if</span> (u &lt; 0.0) u += float(2.0 * M_PI);</div>
<div class="line">    <span class="keywordflow">if</span> (u &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) u = float(2.0 * M_PI) - u;</div>
<div class="line">    u *= M_ONE_OVER_PI;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> v = theta_phi_out[0] * float(2.0 / M_PI);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> w = theta_phi_in[0] * float(2.0 / M_PI);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> make_float3(u, v, w);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">__device__ <span class="keyword">inline</span> T bsdf_measurement_lookup(<span class="keyword">const</span> cudaTextureObject_t&amp; eval_volume,</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_in[2],</div>
<div class="line">                                            <span class="keyword">const</span> <span class="keywordtype">float</span> theta_phi_out[2])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// 3D volume on the GPU (phi_delta x theta_out x theta_in)</span></div>
<div class="line">    <span class="keyword">const</span> float3 uvw = bsdf_compute_uvw(theta_phi_in, theta_phi_out);</div>
<div class="line">    <span class="keywordflow">return</span> tex3D&lt;T&gt;(eval_volume, uvw.x, uvw.y, uvw.z);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_evaluate() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_evaluate(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_in[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the parta</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">    {</div>
<div class="line">        store_result3(result, 0.0f);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle channels</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.num_channels[part_index] == 3)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> float4 sample = bsdf_measurement_lookup&lt;float4&gt;(</div>
<div class="line">            bm.eval_data[part_index], theta_phi_in, theta_phi_out);</div>
<div class="line">        store_result3(result, sample.x, sample.y, sample.z);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> sample = bsdf_measurement_lookup&lt;float&gt;(</div>
<div class="line">            bm.eval_data[part_index], theta_phi_in, theta_phi_out);</div>
<div class="line">        store_result3(result, sample);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_sample() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_sample(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[3],          <span class="comment">// output: theta, phi, pdf</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 xi[3],              <span class="comment">// uniform random values</span></div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    result[0] = -1.0f;  <span class="comment">// negative theta means absorption</span></div>
<div class="line">    result[1] = -1.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid MBSDFs returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// check for the part</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data</span></div>
<div class="line">    uint2 res = bm.angular_resolution[part_index];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* sample_data = bm.sample_data[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute the theta_in index (flipping input and output, BSDFs are symmetric)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_in = unsigned(theta_phi_out[0] * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    idx_theta_in = min(idx_theta_in, res.x - 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample theta_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi0 = xi[0];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_theta = sample_data + idx_theta_in * res.x;</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_out = sample_cdf(cdf_theta, res.x, xi0);       <span class="comment">// binary search</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_theta[idx_theta_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_theta[idx_theta_out - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">        xi0 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi0 /= prob_theta;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// sample phi_out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keywordtype">float</span> xi1 = xi[1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_phi = sample_data +</div>
<div class="line">                           (res.x * res.x) +                                <span class="comment">// CDF theta block</span></div>
<div class="line">                           (idx_theta_in * res.x + idx_theta_out) * res.y;  <span class="comment">// selected CDF phi</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// select which half-circle to choose with probability 0.5</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> flip = (xi1 &gt; 0.5f);</div>
<div class="line">    <span class="keywordflow">if</span> (flip)</div>
<div class="line">        xi1 = 1.0f - xi1;</div>
<div class="line">    xi1 *= 2.0f;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_phi_out = sample_cdf(cdf_phi, res.y, xi1);           <span class="comment">// binary search</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_phi[idx_phi_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_phi[idx_phi_out - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">        xi1 -= tmp;</div>
<div class="line">    }</div>
<div class="line">    xi1 /= prob_phi;  <span class="comment">// rescale for re-usage</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute theta and phi out</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    <span class="keyword">const</span> float2 inv_res = bm.inv_angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = float(0.5 * M_PI) * inv_res.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi   = float(1.0 * M_PI) * inv_res.y;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(<span class="keywordtype">float</span>(idx_theta_out)      * s_theta);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(<span class="keywordtype">float</span>(idx_theta_out + 1u) * s_theta);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta = cos_theta_0 * (1.0f - xi1) + cos_theta_1 * xi1;</div>
<div class="line">    result[0] = acosf(cos_theta);</div>
<div class="line">    result[1] = (float(idx_phi_out) + xi0) * s_phi;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (flip)</div>
<div class="line">        result[1] = float(2.0 * M_PI) - result[1];  <span class="comment">// phi \in [0, 2pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// align phi</span></div>
<div class="line">    result[1] += (theta_phi_out[1] &gt; 0) ? theta_phi_out[1] : (<span class="keywordtype">float</span>(2.0 * M_PI) + theta_phi_out[1]);</div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(2.0 * M_PI)) result[1] -= <span class="keywordtype">float</span>(2.0 * M_PI);</div>
<div class="line">    <span class="keywordflow">if</span> (result[1] &gt; <span class="keywordtype">float</span>(1.0 * M_PI)) result[1] = <span class="keywordtype">float</span>(-2.0 * M_PI) + result[1];  <span class="comment">// to [-pi, pi]</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute pdf</span></div>
<div class="line">    <span class="comment">//-------------------------------------------</span></div>
<div class="line">    result[2] = prob_theta * prob_phi * 0.5f</div>
<div class="line">                / (s_phi * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_pdf() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> df_bsdf_measurement_pdf(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_in[2],</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi_out[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;  <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span> 0.0f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// CDF data and resolution</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* sample_data = bm.sample_data[part_index];</div>
<div class="line">    uint2 res = bm.angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute indices in the CDF data</span></div>
<div class="line">    float3 uvw = bsdf_compute_uvw(theta_phi_in, theta_phi_out); <span class="comment">// phi_delta, theta_out, theta_in</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_in  = unsigned(theta_phi_in[0]  * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta_out = unsigned(theta_phi_out[0] * M_ONE_OVER_PI * 2.0f * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_phi_out   = unsigned(uvw.x * <span class="keywordtype">float</span>(res.y));</div>
<div class="line">    idx_theta_in  = min(idx_theta_in, res.x - 1);</div>
<div class="line">    idx_theta_out = min(idx_theta_out, res.x - 1);</div>
<div class="line">    idx_phi_out   = min(idx_phi_out, res.y - 1);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability to select theta_out</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_theta = sample_data + idx_theta_in * res.x;</div>
<div class="line">    <span class="keywordtype">float</span> prob_theta = cdf_theta[idx_theta_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_theta_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_theta[idx_theta_out - 1];</div>
<div class="line">        prob_theta -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get probability to select phi_out</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* cdf_phi = sample_data +</div>
<div class="line">        (res.x * res.x) +                                <span class="comment">// CDF theta block</span></div>
<div class="line">        (idx_theta_in * res.x + idx_theta_out) * res.y;  <span class="comment">// selected CDF phi</span></div>
<div class="line">    <span class="keywordtype">float</span> prob_phi = cdf_phi[idx_phi_out];</div>
<div class="line">    <span class="keywordflow">if</span> (idx_phi_out &gt; 0)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> tmp = cdf_phi[idx_phi_out - 1];</div>
<div class="line">        prob_phi -= tmp;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// compute probability to select a position in the sphere patch</span></div>
<div class="line">    float2 inv_res = bm.inv_angular_resolution[part_index];</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = float(0.5 * M_PI) * inv_res.x;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi = float(1.0 * M_PI) * inv_res.y;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_0 = cosf(<span class="keywordtype">float</span>(idx_theta_out)      * s_theta);</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta_1 = cosf(<span class="keywordtype">float</span>(idx_theta_out + 1u) * s_theta);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> prob_theta * prob_phi * 0.5f</div>
<div class="line">        / (s_phi * (cos_theta_0 - cos_theta_1));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">__device__ <span class="keyword">inline</span> <span class="keywordtype">void</span> df_bsdf_measurement_albedo(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[2],          <span class="comment">// output: max (in case of color) albedo</span></div>
<div class="line">                                                    <span class="comment">// for the selected direction ([0]) and</span></div>
<div class="line">                                                    <span class="comment">// global ([1])</span></div>
<div class="line">    Texture_handler <span class="keyword">const</span>       *<span class="keyword">self</span>,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2],</div>
<div class="line">    Mbsdf_part                  part)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> Mbsdf&amp; bm = <span class="keyword">self</span>-&gt;mbsdfs[bsdf_measurement_index - 1];</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> part_index = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// check for the part</span></div>
<div class="line">    <span class="keywordflow">if</span> (bm.has_data[part_index] == 0)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> uint2 res = bm.angular_resolution[part_index];</div>
<div class="line">    <span class="keywordtype">unsigned</span> idx_theta = unsigned(theta_phi[0] * <span class="keywordtype">float</span>(2.0 / M_PI) * <span class="keywordtype">float</span>(res.x));</div>
<div class="line">    idx_theta = min(idx_theta, res.x - 1u);</div>
<div class="line">    result[0] = bm.albedo_data[part_index][idx_theta];</div>
<div class="line">    result[1] = bm.max_albedo[part_index];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of df::bsdf_measurement_albedos() for an MBSDF.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> df_bsdf_measurement_albedos(</div>
<div class="line">    <span class="keywordtype">float</span>                       result[4],          <span class="comment">// output: [0] albedo refl. for theta_phi</span></div>
<div class="line">                                                    <span class="comment">//         [1] max albedo refl. global</span></div>
<div class="line">                                                    <span class="comment">//         [2] albedo trans. for theta_phi</span></div>
<div class="line">                                                    <span class="comment">//         [3] max albedo trans. global</span></div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>  *self_base,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                    bsdf_measurement_index,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                 theta_phi[2])</div>
<div class="line">{</div>
<div class="line">    result[0] = 0.0f;</div>
<div class="line">    result[1] = 0.0f;</div>
<div class="line">    result[2] = 0.0f;</div>
<div class="line">    result[3] = 0.0f;</div>
<div class="line"></div>
<div class="line">    Texture_handler <span class="keyword">const</span> *<span class="keyword">self</span> = <span class="keyword">static_cast&lt;</span>Texture_handler <span class="keyword">const </span>*<span class="keyword">&gt;</span>(self_base);</div>
<div class="line">    <span class="keywordflow">if</span> (bsdf_measurement_index == 0 || bsdf_measurement_index - 1 &gt;= self-&gt;num_mbsdfs)</div>
<div class="line">        <span class="keywordflow">return</span>;  <span class="comment">// invalid MBSDF returns zero</span></div>
<div class="line"></div>
<div class="line">    df_bsdf_measurement_albedo(</div>
<div class="line">        &amp;result[0],</div>
<div class="line">        <span class="keyword">self</span>,</div>
<div class="line">        bsdf_measurement_index,</div>
<div class="line">        theta_phi,</div>
<div class="line">        <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>);</div>
<div class="line"></div>
<div class="line">    df_bsdf_measurement_albedo(</div>
<div class="line">        &amp;result[2],</div>
<div class="line">        <span class="keyword">self</span>,</div>
<div class="line">        bsdf_measurement_index,</div>
<div class="line">        theta_phi,</div>
<div class="line">        <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Normal adaption (dummy functions)</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Can be enabled via backend option &quot;use_renderer_adapt_normal&quot;.</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_DUMMY_ADAPTNORMAL</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Implementation of adapt_normal().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> adapt_normal(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            normal[3])</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return original normal</span></div>
<div class="line">    result[0] = normal[0];</div>
<div class="line">    result[1] = normal[1];</div>
<div class="line">    result[2] = normal[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_DUMMY_ADAPTNORMAL</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Scene data (dummy functions)</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_DUMMY_SCENEDATA</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Implementation of scene_data_isvalid().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">bool</span> scene_data_isvalid(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float4().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float4(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[4],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">    result[3] = default_value[3];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float3().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float3(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_color().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_color(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float2().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_float2(</div>
<div class="line">    <span class="keywordtype">float</span>                                  result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value[2],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">float</span> scene_data_lookup_float(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">float</span> <span class="keyword">const</span>                            default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    <span class="keywordflow">return</span> default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int4().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int4(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[4],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[4],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">    result[3] = default_value[3];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int3().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int3(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[3],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[3],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">    result[2] = default_value[2];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int2().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_int2(</div>
<div class="line">    <span class="keywordtype">int</span>                                    result[2],</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span> <span class="keyword">const</span>                              default_value[2],</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    result[0] = default_value[0];</div>
<div class="line">    result[1] = default_value[1];</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_int().</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">int</span> scene_data_lookup_int(</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material                *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    <span class="keywordtype">int</span>                                    default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    <span class="keywordflow">return</span> default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float4() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float4(</div>
<div class="line">    tct_deriv_arr_float_4                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_4 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float3() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float3(</div>
<div class="line">    tct_deriv_arr_float_3                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_3 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_color() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_color(</div>
<div class="line">    tct_deriv_arr_float_3                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_3 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float2() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float2(</div>
<div class="line">    tct_deriv_arr_float_2                 *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_arr_float_2 <span class="keyword">const</span>           *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Implementation of scene_data_lookup_float() with derivatives.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __device__ <span class="keywordtype">void</span> scene_data_lookup_deriv_float(</div>
<div class="line">    tct_deriv_float                       *result,</div>
<div class="line">    Texture_handler_base <span class="keyword">const</span>            *self_base,</div>
<div class="line">    Shading_state_material_with_derivs    *state,</div>
<div class="line">    <span class="keywordtype">unsigned</span>                               scene_data_id,</div>
<div class="line">    tct_deriv_float <span class="keyword">const</span>                 *default_value,</div>
<div class="line">    <span class="keywordtype">bool</span>                                   uniform_lookup)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// just return default value</span></div>
<div class="line">    *result = *default_value;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_DUMMY_SCENEDATA</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">// Vtables</span></div>
<div class="line"><span class="comment">// ------------------------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef TEX_SUPPORT_NO_VTABLES</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// The vtable containing all texture access handlers required by the generated code</span></div>
<div class="line"><span class="comment">// in &quot;vtable&quot; mode.</span></div>
<div class="line">__device__ <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__vtable__impl.html" title="The runtime for bitmap texture access for the generated target code can optionally be implemented in ...">mi::neuraylib::Texture_handler_vtable</a> tex_vtable = {</div>
<div class="line">    tex_lookup_float4_2d,</div>
<div class="line">    tex_lookup_float3_2d,</div>
<div class="line">    tex_texel_float4_2d,</div>
<div class="line">    tex_lookup_float4_3d,</div>
<div class="line">    tex_lookup_float3_3d,</div>
<div class="line">    tex_texel_float4_3d,</div>
<div class="line">    tex_lookup_float4_cube,</div>
<div class="line">    tex_lookup_float3_cube,</div>
<div class="line">    tex_resolution_2d,</div>
<div class="line">    tex_resolution_3d,</div>
<div class="line">    tex_texture_isvalid,</div>
<div class="line">    tex_frame,</div>
<div class="line">    df_light_profile_power,</div>
<div class="line">    df_light_profile_maximum,</div>
<div class="line">    df_light_profile_isvalid,</div>
<div class="line">    df_light_profile_evaluate,</div>
<div class="line">    df_light_profile_sample,</div>
<div class="line">    df_light_profile_pdf,</div>
<div class="line">    df_bsdf_measurement_isvalid,</div>
<div class="line">    df_bsdf_measurement_resolution,</div>
<div class="line">    df_bsdf_measurement_evaluate,</div>
<div class="line">    df_bsdf_measurement_sample,</div>
<div class="line">    df_bsdf_measurement_pdf,</div>
<div class="line">    df_bsdf_measurement_albedos,</div>
<div class="line">    adapt_normal,</div>
<div class="line">    scene_data_isvalid,</div>
<div class="line">    scene_data_lookup_float,</div>
<div class="line">    scene_data_lookup_float2,</div>
<div class="line">    scene_data_lookup_float3,</div>
<div class="line">    scene_data_lookup_float4,</div>
<div class="line">    scene_data_lookup_int,</div>
<div class="line">    scene_data_lookup_int2,</div>
<div class="line">    scene_data_lookup_int3,</div>
<div class="line">    scene_data_lookup_int4,</div>
<div class="line">    scene_data_lookup_color,</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// The vtable containing all texture access handlers required by the generated code</span></div>
<div class="line"><span class="comment">// in &quot;vtable&quot; mode with derivatives.</span></div>
<div class="line">__device__ <a class="code" href="structmi_1_1neuraylib_1_1Texture__handler__vtable__impl.html" title="The runtime for bitmap texture access for the generated target code can optionally be implemented in ...">mi::neuraylib::Texture_handler_deriv_vtable</a> tex_deriv_vtable = {</div>
<div class="line">    tex_lookup_deriv_float4_2d,</div>
<div class="line">    tex_lookup_deriv_float3_2d,</div>
<div class="line">    tex_texel_float4_2d,</div>
<div class="line">    tex_lookup_float4_3d,</div>
<div class="line">    tex_lookup_float3_3d,</div>
<div class="line">    tex_texel_float4_3d,</div>
<div class="line">    tex_lookup_float4_cube,</div>
<div class="line">    tex_lookup_float3_cube,</div>
<div class="line">    tex_resolution_2d,</div>
<div class="line">    tex_resolution_3d,</div>
<div class="line">    tex_texture_isvalid,</div>
<div class="line">    tex_frame,</div>
<div class="line">    df_light_profile_power,</div>
<div class="line">    df_light_profile_maximum,</div>
<div class="line">    df_light_profile_isvalid,</div>
<div class="line">    df_light_profile_evaluate,</div>
<div class="line">    df_light_profile_sample,</div>
<div class="line">    df_light_profile_pdf,</div>
<div class="line">    df_bsdf_measurement_isvalid,</div>
<div class="line">    df_bsdf_measurement_resolution,</div>
<div class="line">    df_bsdf_measurement_evaluate,</div>
<div class="line">    df_bsdf_measurement_sample,</div>
<div class="line">    df_bsdf_measurement_pdf,</div>
<div class="line">    df_bsdf_measurement_albedos,</div>
<div class="line">    adapt_normal,</div>
<div class="line">    scene_data_isvalid,</div>
<div class="line">    scene_data_lookup_float,</div>
<div class="line">    scene_data_lookup_float2,</div>
<div class="line">    scene_data_lookup_float3,</div>
<div class="line">    scene_data_lookup_float4,</div>
<div class="line">    scene_data_lookup_int,</div>
<div class="line">    scene_data_lookup_int2,</div>
<div class="line">    scene_data_lookup_int3,</div>
<div class="line">    scene_data_lookup_int4,</div>
<div class="line">    scene_data_lookup_color,</div>
<div class="line">    scene_data_lookup_deriv_float,</div>
<div class="line">    scene_data_lookup_deriv_float2,</div>
<div class="line">    scene_data_lookup_deriv_float3,</div>
<div class="line">    scene_data_lookup_deriv_float4,</div>
<div class="line">    scene_data_lookup_deriv_color,</div>
<div class="line">};</div>
<div class="line"><span class="preprocessor">#endif  // TEX_SUPPORT_NO_VTABLES</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif  // __CUDACC__</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif  // TEXTURE_SUPPORT_CUDA_H</span></div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/shared/example_cuda_shared.h</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Code shared by CUDA MDL SDK examples</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifndef EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#define EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sstream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#define _USE_MATH_DEFINES</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;example_shared.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;compiled_material_traverser_base.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cuda.h&gt;</span></div>
<div class="line"><span class="preprocessor">#ifdef OPENGL_INTEROP</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;GL/glew.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;GLFW/glfw3.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cudaGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector_functions.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing an MDL texture, containing filtered and unfiltered CUDA texture</span></div>
<div class="line"><span class="comment">// objects and the size of the texture.</span></div>
<div class="line"><span class="keyword">struct </span>Texture</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Texture(cudaTextureObject_t  filtered_object,</div>
<div class="line">            cudaTextureObject_t  unfiltered_object,</div>
<div class="line">            uint3                size)</div>
<div class="line">        : filtered_object(filtered_object)</div>
<div class="line">        , unfiltered_object(unfiltered_object)</div>
<div class="line">        , size(size)</div>
<div class="line">        , inv_size(make_float3(1.0f / size.x, 1.0f / size.y, 1.0f / size.z))</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t  filtered_object;    <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    cudaTextureObject_t  unfiltered_object;  <span class="comment">// uses filter mode cudaFilterModePoint</span></div>
<div class="line">    uint3                size;               <span class="comment">// size of the texture, needed for texel access</span></div>
<div class="line">    float3               inv_size;           <span class="comment">// the inverse values of the size of the texture</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing an MDL bsdf measurement.</span></div>
<div class="line"><span class="keyword">struct </span>Mbsdf</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Mbsdf()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            has_data[i] = 0u;</div>
<div class="line">            eval_data[i] = 0;</div>
<div class="line">            sample_data[i] = 0;</div>
<div class="line">            albedo_data[i] = 0;</div>
<div class="line">            this-&gt;max_albedo[i] = 0.0f;</div>
<div class="line">            angular_resolution[i] = make_uint2(0u, 0u);</div>
<div class="line">            inv_angular_resolution[i] = make_float2(0.0f, 0.0f);</div>
<div class="line">            num_channels[i] = 0;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> Add(<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a> part,</div>
<div class="line">             <span class="keyword">const</span> uint2&amp; angular_resolution,</div>
<div class="line">             <span class="keywordtype">unsigned</span> num_channels)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordtype">unsigned</span> part_idx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span><span class="keyword">&gt;</span>(part);</div>
<div class="line"></div>
<div class="line">        this-&gt;has_data[part_idx] = 1u;</div>
<div class="line">        this-&gt;angular_resolution[part_idx] = angular_resolution;</div>
<div class="line">        this-&gt;inv_angular_resolution[part_idx] = make_float2(1.0f / <span class="keywordtype">float</span>(angular_resolution.x),</div>
<div class="line">                                                             1.0f / <span class="keywordtype">float</span>(angular_resolution.y));</div>
<div class="line">        this-&gt;num_channels[part_idx] = num_channels;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">unsigned</span>            has_data[2];            <span class="comment">// true if there is a measurement for this part</span></div>
<div class="line">    cudaTextureObject_t eval_data[2];           <span class="comment">// uses filter mode cudaFilterModeLinear</span></div>
<div class="line">    <span class="keywordtype">float</span>               max_albedo[2];          <span class="comment">// max albedo used to limit the multiplier</span></div>
<div class="line">    <span class="keywordtype">float</span>*              sample_data[2];         <span class="comment">// CDFs for sampling a BSDF measurement</span></div>
<div class="line">    <span class="keywordtype">float</span>*              albedo_data[2];         <span class="comment">// max albedo for each theta (isotropic)</span></div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution[2];      <span class="comment">// size of the dataset, needed for texel access</span></div>
<div class="line">    float2          inv_angular_resolution[2];  <span class="comment">// the inverse values of the size of the dataset</span></div>
<div class="line">    <span class="keywordtype">unsigned</span>        num_channels[2];            <span class="comment">// number of color channels (1 or 3)</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing a Light Profile</span></div>
<div class="line"><span class="keyword">struct </span>Lightprofile</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">explicit</span> Lightprofile(</div>
<div class="line">        uint2               angular_resolution = make_uint2(0, 0),</div>
<div class="line">        float2              theta_phi_start = make_float2(0.0f, 0.0f),</div>
<div class="line">        float2              theta_phi_delta = make_float2(0.0f, 0.0f),</div>
<div class="line">        <span class="keywordtype">float</span>               candela_multiplier = 0.0f,</div>
<div class="line">        <span class="keywordtype">float</span>               total_power = 0.0f,</div>
<div class="line">        cudaTextureObject_t eval_data = 0,</div>
<div class="line">        <span class="keywordtype">float</span>               *cdf_data = <span class="keyword">nullptr</span>)</div>
<div class="line">    : angular_resolution(angular_resolution)</div>
<div class="line">    , inv_angular_resolution(make_float2(</div>
<div class="line">        1.0f / float(angular_resolution.x),</div>
<div class="line">        1.0f / float(angular_resolution.y)))</div>
<div class="line">    , theta_phi_start(theta_phi_start)</div>
<div class="line">    , theta_phi_delta(theta_phi_delta)</div>
<div class="line">        , theta_phi_inv_delta(make_float2(0.0f, 0.0f))</div>
<div class="line">    , candela_multiplier(candela_multiplier)</div>
<div class="line">    , total_power(total_power)</div>
<div class="line">    , eval_data(eval_data)</div>
<div class="line">    , cdf_data(cdf_data)</div>
<div class="line">    {</div>
<div class="line">        theta_phi_inv_delta.x = theta_phi_delta.x ? (1.f / theta_phi_delta.x) : 0.f;</div>
<div class="line">        theta_phi_inv_delta.y = theta_phi_delta.y ? (1.f / theta_phi_delta.y) : 0.f;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    uint2           angular_resolution;     <span class="comment">// angular resolution of the grid</span></div>
<div class="line">    float2          inv_angular_resolution; <span class="comment">// inverse angular resolution of the grid</span></div>
<div class="line">    float2          theta_phi_start;        <span class="comment">// start of the grid</span></div>
<div class="line">    float2          theta_phi_delta;        <span class="comment">// angular step size</span></div>
<div class="line">    float2          theta_phi_inv_delta;    <span class="comment">// inverse step size</span></div>
<div class="line">    <span class="keywordtype">float</span>           candela_multiplier;     <span class="comment">// factor to rescale the normalized data</span></div>
<div class="line">    <span class="keywordtype">float</span>           total_power;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t eval_data;          <span class="comment">// normalized data sampled on grid</span></div>
<div class="line">    <span class="keywordtype">float</span>*              cdf_data;           <span class="comment">// CDFs for sampling a light profile</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Structure representing the resources used by the generated code of a target code.</span></div>
<div class="line"><span class="keyword">struct </span>Target_code_data</div>
<div class="line">{</div>
<div class="line">    Target_code_data(</div>
<div class="line">        <span class="keywordtype">size_t</span> num_textures,</div>
<div class="line">        CUdeviceptr textures,</div>
<div class="line">        <span class="keywordtype">size_t</span> num_mbsdfs,</div>
<div class="line">        CUdeviceptr mbsdfs,</div>
<div class="line">        <span class="keywordtype">size_t</span> num_lightprofiles,</div>
<div class="line">        CUdeviceptr lightprofiles,</div>
<div class="line">                     CUdeviceptr ro_data_segment)</div>
<div class="line">        : num_textures(num_textures)</div>
<div class="line">        , textures(textures)</div>
<div class="line">        , num_mbsdfs(num_mbsdfs)</div>
<div class="line">        , mbsdfs(mbsdfs)</div>
<div class="line">        , num_lightprofiles(num_lightprofiles)</div>
<div class="line">        , lightprofiles(lightprofiles)</div>
<div class="line">        , ro_data_segment(ro_data_segment)</div>
<div class="line">    {}</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_textures;           <span class="comment">// number of elements in the textures field</span></div>
<div class="line">    CUdeviceptr textures;               <span class="comment">// a device pointer to a list of Texture objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_mbsdfs;             <span class="comment">// number of elements in the mbsdfs field</span></div>
<div class="line">    CUdeviceptr mbsdfs;                 <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span>      num_lightprofiles;     <span class="comment">// number of elements in the lightprofiles field</span></div>
<div class="line">    CUdeviceptr lightprofiles;         <span class="comment">// a device pointer to a list of mbsdfs objects, if used</span></div>
<div class="line"></div>
<div class="line">    CUdeviceptr ro_data_segment;        <span class="comment">// a device pointer to the read-only data segment, if used</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Helper functions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Return a textual representation of the given value.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">std::string to_string(T val)</div>
<div class="line">{</div>
<div class="line">    std::ostringstream stream;</div>
<div class="line">    stream &lt;&lt; val;</div>
<div class="line">    <span class="keywordflow">return</span> stream.str();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Collects the handles in a compiled material</span></div>
<div class="line"><span class="keyword">class </span>Handle_collector : <span class="keyword">public</span> Compiled_material_traverser_base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// add all handle appearing in the provided material to the collectors handle list.</span></div>
<div class="line">    <span class="keyword">explicit</span> Handle_collector(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* material)</div>
<div class="line">    : Compiled_material_traverser_base()</div>
<div class="line">    {</div>
<div class="line">        traverse(material, transaction);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get the collected handles.</span></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; get_handles()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_handles; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Called when the traversal reaches a new element.</span></div>
<div class="line">    <span class="keywordtype">void</span> visit_begin(<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* material,</div>
<div class="line">                     <span class="keyword">const</span> Compiled_material_traverser_base::Traversal_element&amp; element,</div>
<div class="line">                     <span class="keywordtype">void</span>* context)<span class="keyword"> override</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="comment">// look for direct calls</span></div>
<div class="line">        <span class="keywordflow">if</span> (!element.expression ||</div>
<div class="line">            element.expression-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IExpression.html#a7ebbfc1f9ceee07cd8721b3cb6e20032a79fecd7418c18fa74068ab7a823eb1ed" title="A direct call expression. See mi::neuraylib::IExpression_direct_call. ">mi::neuraylib::IExpression::EK_DIRECT_CALL</a>)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// check if it is a distribution function</span></div>
<div class="line">        <span class="keyword">auto</span> transaction = <span class="keyword">static_cast&lt;</span><a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>*<span class="keyword">&gt;</span>(context);</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_direct_call&gt;</a> expr_dcall(</div>
<div class="line">            element.expression-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IExpression__direct__call.html" title="A direct call expression. ">mi::neuraylib::IExpression_direct_call</a></div>
<div class="line">            &gt;());</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_list&gt;</a> args(</div>
<div class="line">            expr_dcall-&gt;get_arguments());</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> func_def(</div>
<div class="line">            transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(</div>
<div class="line">            expr_dcall-&gt;get_definition()));</div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html#a31eb719644d42372c0612ec0a4dc5e51" title="All known semantics of functions definitions. ">mi::neuraylib::IFunction_definition::Semantics</a> semantic = func_def-&gt;</div>
<div class="line">            get_semantic();</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (semantic &lt; mi::neuraylib::IFunction_definition::DS_INTRINSIC_DF_FIRST</div>
<div class="line">            || semantic &gt; mi::neuraylib::IFunction_definition::DS_INTRINSIC_DF_LAST)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// check if the last argument is a handle</span></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_list&gt;</a> arguments(</div>
<div class="line">            expr_dcall-&gt;get_arguments());</div>
<div class="line"></div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> arg_count = arguments-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IExpression__list.html#a8f729ca92305e91f7a6bebff5822dde0" title="Returns the number of elements. ">get_size</a>();</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* name = arguments-&gt;get_name(arg_count - 1);</div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(name, <span class="stringliteral">&quot;handle&quot;</span>) != 0)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get the handle value</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression&gt;</a> expr(</div>
<div class="line">            arguments-&gt;get_expression(arg_count - 1));</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (expr-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IExpression.html#a7ebbfc1f9ceee07cd8721b3cb6e20032ab563823691ce8b3c99a9a58bde726cef" title="A constant expression. See mi::neuraylib::IExpression_constant. ">mi::neuraylib::IExpression::EK_CONSTANT</a>)</div>
<div class="line">            <span class="keywordflow">return</span>; <span class="comment">// is an error if &#39;handle&#39; is a reserved parameter name</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IExpression_constant&gt;</a> expr_const(</div>
<div class="line">            expr-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IExpression__constant.html" title="A constant expression. ">mi::neuraylib::IExpression_constant</a>&gt;());</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IValue&gt;</a> value(expr_const-&gt;get_value());</div>
<div class="line">        <span class="keywordflow">if</span> (value-&gt;get_kind() != <a class="code" href="classmi_1_1neuraylib_1_1IValue.html#af6acadbbd8941fc571234560178d1f49ae5c46734d11a735e06d32592029cf431" title="A string value. See mi::neuraylib::IValue_string. ">mi::neuraylib::IValue::VK_STRING</a>)</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IValue_string&gt;</a> handle(</div>
<div class="line">            value-&gt;get_interface&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IValue__string.html" title="A value of type string. ">mi::neuraylib::IValue_string</a>&gt;());</div>
<div class="line"></div>
<div class="line">        std::string handle_value = handle-&gt;get_value() ? std::string(handle-&gt;get_value()) : <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (std::find(m_handles.begin(), m_handles.end(), handle_value) == m_handles.end())</div>
<div class="line">            m_handles.push_back(handle_value);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt;std::string&gt; m_handles;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// CUDA helper functions</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper macro. Checks whether the expression is cudaSuccess and if not prints a message and</span></div>
<div class="line"><span class="comment">// resets the device and exits.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DEPRECATED_UTILIY_FUNCTIONS</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define check_cuda_success(expr) \</span></div>
<div class="line"><span class="preprocessor">    do { \</span></div>
<div class="line"><span class="preprocessor">        int err = (expr); \</span></div>
<div class="line"><span class="preprocessor">        if (err != 0) { \</span></div>
<div class="line"><span class="preprocessor">            fprintf(stderr, &quot;CUDA error %d in file %s, line %u: \&quot;%s\&quot;.\n&quot;, \</span></div>
<div class="line"><span class="preprocessor">                err, __FILE__, __LINE__, #expr); \</span></div>
<div class="line"><span class="preprocessor">            keep_console_open(); \</span></div>
<div class="line"><span class="preprocessor">            cudaDeviceReset(); \</span></div>
<div class="line"><span class="preprocessor">            exit(EXIT_FAILURE); \</span></div>
<div class="line"><span class="preprocessor">        } \</span></div>
<div class="line"><span class="preprocessor">    } while (false)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#define check_cuda_success(expr) \</span></div>
<div class="line"><span class="preprocessor">    do { \</span></div>
<div class="line"><span class="preprocessor">        int err = (expr); \</span></div>
<div class="line"><span class="preprocessor">        if (err != 0) { \</span></div>
<div class="line"><span class="preprocessor">            cudaDeviceReset(); \</span></div>
<div class="line"><span class="preprocessor">            exit_failure( &quot;Error in file %s, line %u: \&quot;%s\&quot;.\n&quot;, __FILE__, __LINE__, #expr); \</span></div>
<div class="line"><span class="preprocessor">        } \</span></div>
<div class="line"><span class="preprocessor">    } while (false)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Initialize CUDA.</span></div>
<div class="line">CUcontext init_cuda(</div>
<div class="line">    <span class="keywordtype">int</span> ordinal</div>
<div class="line">#ifdef OPENGL_INTEROP</div>
<div class="line">    , <span class="keyword">const</span> <span class="keywordtype">bool</span> opengl_interop</div>
<div class="line">#endif</div>
<div class="line">    )</div>
<div class="line">{</div>
<div class="line">    CUdevice cu_device;</div>
<div class="line">    CUcontext cu_context;</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuInit(0));</div>
<div class="line"><span class="preprocessor">#if defined(OPENGL_INTEROP) &amp;&amp; !defined(__APPLE__)</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keywordflow">if</span> (opengl_interop) {</div>
<div class="line">        <span class="comment">// Use first device used by OpenGL context</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_cu_devices;</div>
<div class="line">        check_cuda_success(cuGLGetDevices(&amp;num_cu_devices, &amp;cu_device, 1, CU_GL_DEVICE_LIST_ALL));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    {</div>
<div class="line">        <span class="comment">// Use given device</span></div>
<div class="line">        check_cuda_success(cuDeviceGet(&amp;cu_device, ordinal));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuCtxCreate(&amp;cu_context, 0, cu_device));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For this example, increase printf CUDA buffer size to support a larger number</span></div>
<div class="line">    <span class="comment">// of MDL debug::print() calls per CUDA kernel launch</span></div>
<div class="line">    cudaDeviceSetLimit(cudaLimitPrintfFifoSize, 16 * 1024 * 1024);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cu_context;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Uninitialize CUDA.</span></div>
<div class="line"><span class="keywordtype">void</span> uninit_cuda(CUcontext cuda_context)</div>
<div class="line">{</div>
<div class="line">    check_cuda_success(cuCtxDestroy(cuda_context));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct </span>Resource_deleter {</div>
<div class="line">    <span class="comment">/*compile error*/</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;cudaArray_t&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(cudaArray_t res) { check_cuda_success(cudaFreeArray(res)); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;cudaMipmappedArray_t&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(cudaMipmappedArray_t res) { check_cuda_success(cudaFreeMipmappedArray(res)); }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Texture&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Texture &amp;res) {</div>
<div class="line">        check_cuda_success(cudaDestroyTextureObject(res.filtered_object));</div>
<div class="line">        check_cuda_success(cudaDestroyTextureObject(res.unfiltered_object));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Mbsdf&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Mbsdf &amp;res) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; 2; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (res.has_data[i] != 0u) {</div>
<div class="line">                check_cuda_success(cudaDestroyTextureObject(res.eval_data[i]));</div>
<div class="line">                check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(res.sample_data[i])));</div>
<div class="line">                check_cuda_success(cuMemFree(reinterpret_cast&lt;CUdeviceptr&gt;(res.albedo_data[i])));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Lightprofile&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Lightprofile res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res.cdf_data)</div>
<div class="line">            check_cuda_success(cuMemFree((CUdeviceptr)res.cdf_data));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;Target_code_data&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(Target_code_data &amp;res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res.textures)</div>
<div class="line">            check_cuda_success(cuMemFree(res.textures));</div>
<div class="line">        <span class="keywordflow">if</span> (res.ro_data_segment)</div>
<div class="line">            check_cuda_success(cuMemFree(res.ro_data_segment));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">struct </span>Resource_deleter&lt;CUdeviceptr&gt; {</div>
<div class="line">    <span class="keywordtype">void</span> operator()(CUdeviceptr res) {</div>
<div class="line">        <span class="keywordflow">if</span> (res != 0)</div>
<div class="line">            check_cuda_success(cuMemFree(res));</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> D = Resource_deleter&lt;T&gt; &gt;</div>
<div class="line"><span class="keyword">struct </span>Resource_handle {</div>
<div class="line">    Resource_handle(T res) : m_res(res) {}</div>
<div class="line"></div>
<div class="line">    ~Resource_handle() {</div>
<div class="line">        D deleter;</div>
<div class="line">        deleter(m_res);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    T &amp;<span class="keyword">get</span>() { <span class="keywordflow">return</span> m_res; }</div>
<div class="line"></div>
<div class="line">    T <span class="keyword">const</span> &amp;<span class="keyword">get</span>() <span class="keyword">const</span> { <span class="keywordflow">return</span> m_res; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">void</span> set(T res) { m_res = res; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// No copy possible.</span></div>
<div class="line">    Resource_handle(Resource_handle <span class="keyword">const</span> &amp;);</div>
<div class="line">    Resource_handle &amp;operator=(Resource_handle <span class="keyword">const</span> &amp;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    T m_res;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C = std::vector&lt;T&gt;, <span class="keyword">typename</span> D = Resource_deleter&lt;T&gt; &gt;</div>
<div class="line"><span class="keyword">struct </span>Resource_container {</div>
<div class="line">    Resource_container() : m_cont() {}</div>
<div class="line"></div>
<div class="line">    ~Resource_container() {</div>
<div class="line">        D deleter;</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> C::iterator I;</div>
<div class="line">        <span class="keywordflow">for</span> (I it(m_cont.begin()), end(m_cont.end()); it != end; ++it) {</div>
<div class="line">            T &amp;r = *it;</div>
<div class="line">            deleter(r);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    C &amp;<a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>() { <span class="keywordflow">return</span> m_cont; }</div>
<div class="line"></div>
<div class="line">    C <span class="keyword">const</span> &amp;<a class="code" href="group__mi__math__bbox.html#ga66a9bcc85c6e0bd89112445d3b16d655" title="Returns a bounding box that is a version of bbox scaled by factor, i.e., bbox.max and bbox...">operator*</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_cont; }</div>
<div class="line"></div>
<div class="line">    C *operator-&gt;() { <span class="keywordflow">return</span> &amp;m_cont; }</div>
<div class="line"></div>
<div class="line">    C <span class="keyword">const</span> *operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;m_cont; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// No copy possible.</span></div>
<div class="line">    Resource_container(Resource_container <span class="keyword">const</span> &amp;);</div>
<div class="line">    Resource_container &amp;operator=(Resource_container <span class="keyword">const</span> &amp;);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    C m_cont;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line">CUdeviceptr gpu_mem_dup(<span class="keywordtype">void</span> <span class="keyword">const</span> *data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    CUdeviceptr device_ptr;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;device_ptr, size));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(device_ptr, data, size));</div>
<div class="line">    <span class="keywordflow">return</span> device_ptr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(Resource_handle&lt;T&gt; <span class="keyword">const</span> *data, <span class="keywordtype">size_t</span> size)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup((<span class="keywordtype">void</span> *)data-&gt;get(), size);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(std::vector&lt;T&gt; <span class="keyword">const</span> &amp;data)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup(&amp;data[0], data.size() * <span class="keyword">sizeof</span>(T));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate memory on GPU and copy the given data to the allocated memory.</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;</div>
<div class="line">CUdeviceptr gpu_mem_dup(Resource_container&lt;T,C&gt; <span class="keyword">const</span> &amp;cont)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> gpu_mem_dup(*cont);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Material_gpu_context class</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper class responsible for making textures and read-only data available to the GPU</span></div>
<div class="line"><span class="comment">// by generating and managing a list of Target_code_data objects.</span></div>
<div class="line"><span class="keyword">class </span>Material_gpu_context</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    Material_gpu_context(<span class="keywordtype">bool</span> enable_derivatives)</div>
<div class="line">        : m_enable_derivatives(enable_derivatives)</div>
<div class="line">        , m_device_target_code_data_list(0)</div>
<div class="line">        , m_device_target_argument_block_list(0)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Use first entry as &quot;not-used&quot; block</span></div>
<div class="line">        m_target_argument_block_list-&gt;push_back(0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the needed data of the given target code.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_target_code_data(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>          *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>            *image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span>    *target_code,</div>
<div class="line">        std::vector&lt;size_t&gt; <span class="keyword">const</span>            &amp;arg_block_indices);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the target code data list.</span></div>
<div class="line">    CUdeviceptr get_device_target_code_data_list();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the target argument block list.</span></div>
<div class="line">    CUdeviceptr get_device_target_argument_block_list();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a device pointer to the i&#39;th target argument block.</span></div>
<div class="line">    CUdeviceptr get_device_target_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// First entry is the &quot;not-used&quot; block, so start at index 1.</span></div>
<div class="line">        <span class="keywordflow">if</span> (i + 1 &gt;= m_target_argument_block_list-&gt;size())</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        <span class="keywordflow">return</span> (*m_target_argument_block_list)[i + 1];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the number of target argument blocks.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_argument_block_count()<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_own_arg_blocks.size();</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the argument block of the i&#39;th BSDF.</span></div>
<div class="line">    <span class="comment">// If the BSDF has no target argument block, size_t(~0) is returned.</span></div>
<div class="line">    <span class="keywordtype">size_t</span> get_bsdf_argument_block_index(<span class="keywordtype">size_t</span> i)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_bsdf_arg_block_indices.size()) <span class="keywordflow">return</span> <span class="keywordtype">size_t</span>(~0);</div>
<div class="line">        <span class="keywordflow">return</span> m_bsdf_arg_block_indices[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get a writable copy of the i&#39;th target argument block.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a> get_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_own_arg_blocks.size())</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a>();</div>
<div class="line">        <span class="keywordflow">return</span> m_own_arg_blocks[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the layout of the i&#39;th target argument block.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt;</a> get_argument_block_layout(<span class="keywordtype">size_t</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (i &gt;= m_arg_block_layouts.size())</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt;</a>();</div>
<div class="line">        <span class="keywordflow">return</span> m_arg_block_layouts[i];</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Update the i&#39;th target argument block on the device with the data from the corresponding</span></div>
<div class="line">    <span class="comment">// block returned by get_argument_block().</span></div>
<div class="line">    <span class="keywordtype">void</span> update_device_argument_block(<span class="keywordtype">size_t</span> i);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Copy the image data of a canvas to a CUDA array.</span></div>
<div class="line">    <span class="keywordtype">void</span> copy_canvas_to_cuda_array(cudaArray_t device_array, <a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> <span class="keyword">const</span> *canvas);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line">    <span class="comment">// on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_texture(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>         *image_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           texture_index,</div>
<div class="line">        std::vector&lt;Texture&gt;              &amp;textures);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the mbsdf identified by the mbsdf_index for use by the bsdf measurement access</span></div>
<div class="line">    <span class="comment">// functions on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_mbsdf(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           mbsdf_index,</div>
<div class="line">        std::vector&lt;Mbsdf&gt;                &amp;mbsdfs);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Prepare the mbsdf identified by the mbsdf_index for use by the bsdf measurement access</span></div>
<div class="line">    <span class="comment">// functions on the GPU.</span></div>
<div class="line">    <span class="keywordtype">bool</span> prepare_lightprofile(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           lightprofile_index,</div>
<div class="line">        std::vector&lt;Lightprofile&gt;        &amp;lightprofiles);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// If true, mipmaps will be generated for all 2D textures.</span></div>
<div class="line">    <span class="keywordtype">bool</span> m_enable_derivatives;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The device pointer of the target code data list.</span></div>
<div class="line">    Resource_handle&lt;CUdeviceptr&gt; m_device_target_code_data_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target code data objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Target_code_data&gt; m_target_code_data_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The device pointer of the target argument block list.</span></div>
<div class="line">    Resource_handle&lt;CUdeviceptr&gt; m_device_target_argument_block_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target argument blocks owned by this context.</span></div>
<div class="line">    Resource_container&lt;CUdeviceptr&gt; m_target_argument_block_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all local, writable copies of the target argument blocks.</span></div>
<div class="line">    std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt; &gt; m_own_arg_blocks;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of argument block indices per material BSDF.</span></div>
<div class="line">    std::vector&lt;size_t&gt; m_bsdf_arg_block_indices;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all target argument block layouts.</span></div>
<div class="line">    std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ITarget_value_layout const&gt; &gt; m_arg_block_layouts;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all Texture objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Texture&gt; m_all_textures;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all MBSDFs objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Mbsdf&gt; m_all_mbsdfs;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all Light profiles objects owned by this context.</span></div>
<div class="line">    Resource_container&lt;Lightprofile&gt; m_all_lightprofiles;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all CUDA arrays owned by this context.</span></div>
<div class="line">    Resource_container&lt;cudaArray_t&gt; m_all_texture_arrays;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// List of all CUDA mipmapped arrays owned by this context.</span></div>
<div class="line">    Resource_container&lt;cudaMipmappedArray_t&gt; m_all_texture_mipmapped_arrays;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get a device pointer to the target code data list.</span></div>
<div class="line">CUdeviceptr Material_gpu_context::get_device_target_code_data_list()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!m_device_target_code_data_list.get())</div>
<div class="line">        m_device_target_code_data_list.set(gpu_mem_dup(m_target_code_data_list));</div>
<div class="line">    <span class="keywordflow">return</span> m_device_target_code_data_list.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Get a device pointer to the target argument block list.</span></div>
<div class="line">CUdeviceptr Material_gpu_context::get_device_target_argument_block_list()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (!m_device_target_argument_block_list.get())</div>
<div class="line">        m_device_target_argument_block_list.set(gpu_mem_dup(m_target_argument_block_list));</div>
<div class="line">    <span class="keywordflow">return</span> m_device_target_argument_block_list.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Copy the image data of a canvas to a CUDA array.</span></div>
<div class="line"><span class="keywordtype">void</span> Material_gpu_context::copy_canvas_to_cuda_array(</div>
<div class="line">    cudaArray_t device_array,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a> <span class="keyword">const</span> *canvas)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>());</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const</span> *data = <span class="keyword">static_cast&lt;</span><a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line">    check_cuda_success(cudaMemcpy2DToArray(</div>
<div class="line">        device_array, 0, 0, data,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>() * <span class="keyword">sizeof</span>(float) * 4,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>() * <span class="keyword">sizeof</span>(float) * 4,</div>
<div class="line">        canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>(),</div>
<div class="line">        cudaMemcpyHostToDevice));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the texture identified by the texture_index for use by the texture access functions</span></div>
<div class="line"><span class="comment">// on the GPU.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_texture(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>         *image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           texture_index,</div>
<div class="line">    std::vector&lt;Texture&gt;              &amp;textures)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITexture&gt;</a> texture(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ITexture.html" title="Textures add image processing options to images. ">mi::neuraylib::ITexture</a>&gt;(code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9981716cff2ab0dada7d3b5288c9afb4" title="Returns the name of a texture resource used by the target code. ">get_texture</a>(texture_index)));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IImage&gt;</a> image(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IImage.html" title="This interface represents a pixel image file. ">mi::neuraylib::IImage</a>&gt;(texture-&gt;get_image()));</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ICanvas&gt;</a> canvas(image-&gt;get_canvas(0, 0, 0));</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_width = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#acd28f45b9d22b1cd1e24043aeda5c065" title="Returns the resolution of the canvas in x direction. ">get_resolution_x</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_height = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a51874ccdb54f6e03ff325b01d98dfefb" title="Returns the resolution of the canvas in y direction. ">get_resolution_y</a>();</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> tex_layers = canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#a1d62d69c848f7b4da053bac9e071bb75" title="Returns the number of layers this canvas has. ">get_layers_size</a>();</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *image_type = image-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas__base.html#ab36d6bebb85da08e907eadbe7542c658" title="Returns the pixel type used by the canvas. ">get_type</a>(0, 0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (image-&gt;is_uvtile() || image-&gt;is_animated()) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;The example does not support uvtile and/or animated textures!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For simplicity, the texture access functions are only implemented for float4 and gamma</span></div>
<div class="line">    <span class="comment">// is pre-applied here (all images are converted to linear space).</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Convert to linear color space if necessary</span></div>
<div class="line">    <span class="keywordflow">if</span> (texture-&gt;get_effective_gamma(0, 0) != 1.0f) {</div>
<div class="line">        <span class="comment">// Copy/convert to float4 canvas and adjust gamma from &quot;effective gamma&quot; to 1.</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas&gt;</a> gamma_canvas(</div>
<div class="line">            image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.get(), <span class="stringliteral">&quot;Color&quot;</span>));</div>
<div class="line">        gamma_canvas-&gt;set_gamma(texture-&gt;get_effective_gamma(0, 0));</div>
<div class="line">        image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#aef6f6c7994c60410b14d45a6cd0af7ce" title="Sets the gamma value of a canvas and adjusts the pixel data accordingly. ">adjust_gamma</a>(gamma_canvas.get(), 1.0f);</div>
<div class="line">        canvas = gamma_canvas;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(image_type, <span class="stringliteral">&quot;Color&quot;</span>) != 0 &amp;&amp; strcmp(image_type, <span class="stringliteral">&quot;Float32&lt;4&gt;&quot;</span>) != 0) {</div>
<div class="line">        <span class="comment">// Convert to expected format</span></div>
<div class="line">        canvas = image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#a70bb55d4f633151d12664b078ddd6ebb" title="Converts a canvas to a different pixel type. ">convert</a>(canvas.get(), <span class="stringliteral">&quot;Color&quot;</span>);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc&lt;float4&gt;();</div>
<div class="line">    cudaResourceDesc res_desc;</div>
<div class="line">    memset(&amp;res_desc, 0, <span class="keyword">sizeof</span>(res_desc));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy image data to GPU array depending on texture shape</span></div>
<div class="line">    <a class="code" href="group__mi__neuray__mdl__compiler.html#gaa788bdbb9cb28f793e2c91cd8adf3faa">mi::neuraylib::ITarget_code::Texture_shape</a> texture_shape =</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1ffc64d788c1ff52bb994266a242c81c" title="Returns the texture shape of a given texture resource used by the target code. ">get_texture_shape</a>(texture_index);</div>
<div class="line">    <span class="keywordflow">if</span> (texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> ||</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaaa755f4fdb8b3cf46c19606707687ef4b" title="Three-dimensional texture. ">mi::neuraylib::ITarget_code::Texture_shape_3d</a> ||</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa7406ffbe2b2d7025a1467a7798d72400" title="Three-dimensional texture representing a BSDF data table. ">mi::neuraylib::ITarget_code::Texture_shape_bsdf_data</a>) {</div>
<div class="line">        <span class="comment">// Cubemap and 3D texture objects require 3D CUDA arrays</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span> (texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> &amp;&amp;</div>
<div class="line">            tex_layers != 6) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid number of layers (&quot;</span> &lt;&lt; tex_layers</div>
<div class="line">                &lt;&lt; <span class="stringliteral">&quot;), cubemaps must have 6 layers!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate a 3D array on the GPU</span></div>
<div class="line">        cudaExtent extent = make_cudaExtent(tex_width, tex_height, tex_layers);</div>
<div class="line">        cudaArray_t device_tex_array;</div>
<div class="line">        check_cuda_success(cudaMalloc3DArray(</div>
<div class="line">            &amp;device_tex_array, &amp;channel_desc, extent,</div>
<div class="line">            texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a> ?</div>
<div class="line">            cudaArrayCubemap : 0));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Prepare the memcpy parameter structure</span></div>
<div class="line">        cudaMemcpy3DParms copy_params;</div>
<div class="line">        memset(&amp;copy_params, 0, <span class="keyword">sizeof</span>(copy_params));</div>
<div class="line">        copy_params.dstArray = device_tex_array;</div>
<div class="line">        copy_params.extent = make_cudaExtent(tex_width, tex_height, 1);</div>
<div class="line">        copy_params.kind = cudaMemcpyHostToDevice;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy the image data of all layers (the layers are not consecutive in memory)</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> layer = 0; layer &lt; tex_layers; ++layer) {</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITile&gt;</a> tile(</div>
<div class="line">                canvas-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html#a2498f17d35d4e888a76bdc077df1a406" title="Returns the tile for the given layer. ">get_tile</a>(layer));</div>
<div class="line">            <span class="keywordtype">float</span> <span class="keyword">const</span> *data = <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span> <span class="keyword">const </span>*<span class="keyword">&gt;</span>(tile-&gt;get_data());</div>
<div class="line"></div>
<div class="line">            copy_params.srcPtr = make_cudaPitchedPtr(</div>
<div class="line">                const_cast&lt;float *&gt;(data), tex_width * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>) * 4,</div>
<div class="line">                tex_width, tex_height);</div>
<div class="line">            copy_params.dstPos = make_cudaPos(0, 0, layer);</div>
<div class="line"></div>
<div class="line">            check_cuda_success(cudaMemcpy3D(&amp;copy_params));</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">        res_desc.res.array.array = device_tex_array;</div>
<div class="line"></div>
<div class="line">        m_all_texture_arrays-&gt;push_back(device_tex_array);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_enable_derivatives) {</div>
<div class="line">        <span class="comment">// mipmapped textures use CUDA mipmapped arrays</span></div>
<div class="line">        <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> num_levels = image-&gt;get_levels(0, 0);</div>
<div class="line">        cudaExtent extent = make_cudaExtent(tex_width, tex_height, 0);</div>
<div class="line">        cudaMipmappedArray_t device_tex_miparray;</div>
<div class="line">        check_cuda_success(cudaMallocMipmappedArray(</div>
<div class="line">            &amp;device_tex_miparray, &amp;channel_desc, extent, num_levels));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// create all mipmap levels and copy them to the CUDA arrays in the mipmapped array</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::IArray&gt;</a> mipmaps(image_api-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html#abb070d2b58cda51830236dccecf55210" title="Creates mipmaps from the given canvas. ">create_mipmaps</a>(canvas.get(), 1.0f));</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> level = 0; level &lt; num_levels; ++level) {</div>
<div class="line">            <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICanvas const&gt;</a> level_canvas;</div>
<div class="line">            <span class="keywordflow">if</span> (level == 0)</div>
<div class="line">                level_canvas = canvas;</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">                <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::IPointer&gt;</a> mipmap_ptr(mipmaps-&gt;get_element&lt;<a class="code" href="classmi_1_1IPointer.html" title="This interface represents mutable pointers. ">mi::IPointer</a>&gt;(level - 1));</div>
<div class="line">                level_canvas = mipmap_ptr-&gt;get_pointer&lt;<a class="code" href="classmi_1_1neuraylib_1_1ICanvas.html" title="Abstract interface for a canvas represented by a rectangular array of tiles. ">mi::neuraylib::ICanvas</a>&gt;();</div>
<div class="line">            }</div>
<div class="line">            cudaArray_t device_level_array;</div>
<div class="line">            cudaGetMipmappedArrayLevel(&amp;device_level_array, device_tex_miparray, level);</div>
<div class="line">            copy_canvas_to_cuda_array(device_level_array, level_canvas.<a class="code" href="classmi_1_1base_1_1Handle.html#ab28423d4121459d4026449e4991f5486" title="Access to the interface. Returns 0 for an invalid interface. ">get</a>());</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeMipmappedArray;</div>
<div class="line">        res_desc.res.mipmap.mipmap = device_tex_miparray;</div>
<div class="line"></div>
<div class="line">        m_all_texture_mipmapped_arrays-&gt;push_back(device_tex_miparray);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// 2D texture objects use CUDA arrays</span></div>
<div class="line">        cudaArray_t device_tex_array;</div>
<div class="line">        check_cuda_success(cudaMallocArray(</div>
<div class="line">            &amp;device_tex_array, &amp;channel_desc, tex_width, tex_height));</div>
<div class="line"></div>
<div class="line">        copy_canvas_to_cuda_array(device_tex_array, canvas.get());</div>
<div class="line"></div>
<div class="line">        res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">        res_desc.res.array.array = device_tex_array;</div>
<div class="line"></div>
<div class="line">        m_all_texture_arrays-&gt;push_back(device_tex_array);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// For cube maps we need clamped address mode to avoid artifacts in the corners</span></div>
<div class="line">    cudaTextureAddressMode addr_mode =</div>
<div class="line">        texture_shape == <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a></div>
<div class="line">        ? cudaAddressModeClamp</div>
<div class="line">        : cudaAddressModeWrap;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create filtered texture object</span></div>
<div class="line">    cudaTextureDesc tex_desc;</div>
<div class="line">    memset(&amp;tex_desc, 0, <span class="keyword">sizeof</span>(tex_desc));</div>
<div class="line">    tex_desc.addressMode[0]   = addr_mode;</div>
<div class="line">    tex_desc.addressMode[1]   = addr_mode;</div>
<div class="line">    tex_desc.addressMode[2]   = addr_mode;</div>
<div class="line">    tex_desc.filterMode       = cudaFilterModeLinear;</div>
<div class="line">    tex_desc.readMode         = cudaReadModeElementType;</div>
<div class="line">    tex_desc.normalizedCoords = 1;</div>
<div class="line">    <span class="keywordflow">if</span> (res_desc.resType == cudaResourceTypeMipmappedArray) {</div>
<div class="line">        tex_desc.mipmapFilterMode = cudaFilterModeLinear;</div>
<div class="line">        tex_desc.maxAnisotropy = 16;</div>
<div class="line">        tex_desc.minMipmapLevelClamp = 0.f;</div>
<div class="line">        tex_desc.maxMipmapLevelClamp = 1000.f;  <span class="comment">// default value in OpenGL</span></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t tex_obj = 0;</div>
<div class="line">    check_cuda_success(cudaCreateTextureObject(&amp;tex_obj, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create unfiltered texture object if necessary (cube textures have no texel functions)</span></div>
<div class="line">    cudaTextureObject_t tex_obj_unfilt = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (texture_shape != <a class="code" href="group__mi__neuray__mdl__compiler.html#ggaa788bdbb9cb28f793e2c91cd8adf3faaa8ba2e927aca386ccf40476329c8013d1" title="Cube map texture. ">mi::neuraylib::ITarget_code::Texture_shape_cube</a>) {</div>
<div class="line">        <span class="comment">// Use a black border for access outside of the texture</span></div>
<div class="line">        tex_desc.addressMode[0]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.addressMode[1]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.addressMode[2]   = cudaAddressModeBorder;</div>
<div class="line">        tex_desc.filterMode       = cudaFilterModePoint;</div>
<div class="line"></div>
<div class="line">        check_cuda_success(cudaCreateTextureObject(</div>
<div class="line">            &amp;tex_obj_unfilt, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Store texture infos in result vector</span></div>
<div class="line">    textures.push_back(Texture(</div>
<div class="line">        tex_obj,</div>
<div class="line">        tex_obj_unfilt,</div>
<div class="line">        make_uint3(tex_width, tex_height, tex_layers)));</div>
<div class="line">    m_all_textures-&gt;push_back(textures.back());</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b12efb3645f76a6f1233d671546bae5" title="MBSDFs can consist of two parts, which can be selected using this enumeration. ">mi::neuraylib::Mbsdf_part</a> part, Mbsdf&amp; mbsdf_cuda_representation,</div>
<div class="line">                             <span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html" title="A scene element that stores measured BSDF data. ">mi::neuraylib::IBsdf_measurement</a>* bsdf_measurement)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::Bsdf_isotropic_data&gt;</a> dataset;</div>
<div class="line">        <span class="keywordflow">switch</span> (part)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>:</div>
<div class="line">                dataset = bsdf_measurement-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html#a1fac5d8562d606091ea652528480b37f" title="Returns the BSDF data for the reflection. ">get_reflection</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html" title="Example implementation of the abstract interface mi::neuraylib::IBsdf_isotropic_data. ">mi::neuraylib::Bsdf_isotropic_data</a>&gt;();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>:</div>
<div class="line">                dataset = bsdf_measurement-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html#af7ffdff52a088d45a12e93aa5d65bb72" title="Returns the BSDF data for transmission. ">get_transmission</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html" title="Example implementation of the abstract interface mi::neuraylib::IBsdf_isotropic_data. ">mi::neuraylib::Bsdf_isotropic_data</a>&gt;();</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// no data, fine</span></div>
<div class="line">        <span class="keywordflow">if</span> (!dataset)</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get dimensions</span></div>
<div class="line">        uint2 res;</div>
<div class="line">        res.x = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a5b71354f2117339bb9581631137460f1" title="Returns the number of values in theta direction. ">get_resolution_theta</a>();</div>
<div class="line">        res.y = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#abd7643ec08b101e4e58f591d6e80af06" title="Returns the number of values in phi direction. ">get_resolution_phi</a>();</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_channels = dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a60f76457e265c983409dc04dde554119" title="Returns the type of the values. ">get_type</a>() == <a class="code" href="group__mi__neuray__misc.html#gga038cede92a99d99c9df55a87727c2c92ad8c362821ed5a71bb29f64c4dd4db7c7" title="One scalar per grid value. ">mi::neuraylib::BSDF_SCALAR</a> ? 1 : 3;</div>
<div class="line">        mbsdf_cuda_representation.Add(part, res, num_channels);</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        <span class="comment">// get data</span></div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IBsdf_buffer&gt;</a> buffer(dataset-&gt;<a class="code" href="classmi_1_1neuraylib_1_1Bsdf__isotropic__data.html#a4d24f4d314a00dc7d88af2534f834111" title="Returns the buffer containing the values (const). ">get_bsdf_buffer</a>());</div>
<div class="line">        <span class="comment">// {1,3} * (index_theta_in * (res_phi * res_theta) + index_theta_out * res_phi + index_phi)</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <a class="code" href="group__mi__base__types.html#gac1b8c06a073706523d7a054c6e2a89c7" title="32-bit float. ">mi::Float32</a>* src_data = buffer-&gt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__buffer.html#a58dc792ae63b977ef02549a4b9e3c417" title="Returns the memory block containing the actual BSDF values. ">get_data</a>();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line">        <span class="comment">// prepare importance sampling data:</span></div>
<div class="line">        <span class="comment">// - for theta_in we will be able to perform a two stage CDF, first to select theta_out,</span></div>
<div class="line">        <span class="comment">//   and second to select phi_out</span></div>
<div class="line">        <span class="comment">// - maximum component is used to &quot;probability&quot; in case of colored measurements</span></div>
<div class="line"></div>
<div class="line">        <span class="comment">// CDF of the probability to select a certain theta_out for a given theta_in</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cdf_theta_size = res.x * res.x;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// for each of theta_in x theta_out combination, a CDF of the probabilities to select a</span></div>
<div class="line">        <span class="comment">// a certain theta_out is stored</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> sample_data_size = cdf_theta_size + cdf_theta_size * res.y;</div>
<div class="line">        <span class="keywordtype">float</span>* sample_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[sample_data_size];</div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span>* albedo_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[res.x]; <span class="comment">// albedo for sampling reflection and transmission</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span>* sample_data_theta = sample_data;                <span class="comment">// begin of the first (theta) CDF</span></div>
<div class="line">        <span class="keywordtype">float</span>* sample_data_phi = sample_data + cdf_theta_size; <span class="comment">// begin of the second (phi) CDFs</span></div>
<div class="line"></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> s_theta = (float) (M_PI * 0.5) / float(res.x);  <span class="comment">// step size</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> s_phi = (float) (M_PI) / float(res.y);          <span class="comment">// step size</span></div>
<div class="line"></div>
<div class="line">        <span class="keywordtype">float</span> max_albedo = 0.0f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_in = 0; t_in &lt; res.x; ++t_in)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">float</span> sum_theta = 0.0f;</div>
<div class="line">            <span class="keywordtype">float</span> sintheta0_sqd = 0.0f;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> sintheta1 = sinf(<span class="keywordtype">float</span>(t_out + 1) * s_theta);</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> sintheta1_sqd = sintheta1 * sintheta1;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// BSDFs are symmetric: f(w_in, w_out) = f(w_out, w_in)</span></div>
<div class="line">                <span class="comment">// take the average of both measurements</span></div>
<div class="line"></div>
<div class="line">                <span class="comment">// area of two the surface elements (the ones we are averaging)</span></div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> mu = (sintheta1_sqd - sintheta0_sqd) * s_phi * 0.5f;</div>
<div class="line">                sintheta0_sqd = sintheta1_sqd;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// offset for both the thetas into the measurement data (select row in the volume)</span></div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi  = (t_in * res.x + t_out) * res.y;</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi2 = (t_out * res.x + t_in) * res.y;</div>
<div class="line"></div>
<div class="line">                <span class="comment">// build CDF for phi</span></div>
<div class="line">                <span class="keywordtype">float</span> sum_phi = 0.0f;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx  = offset_phi  + p_out;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx2 = offset_phi2 + p_out;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordtype">float</span> value = 0.0f;</div>
<div class="line">                    <span class="keywordflow">if</span> (num_channels == 3)</div>
<div class="line">                    {</div>
<div class="line">                        value = fmax(fmaxf(src_data[3 * idx  + 0], src_data[3 * idx  + 1]),</div>
<div class="line">                                     fmaxf(src_data[3 * idx  + 2], 0.0f))</div>
<div class="line">                              + fmax(fmaxf(src_data[3 * idx2 + 0], src_data[3 * idx2 + 1]),</div>
<div class="line">                                     fmaxf(src_data[3 * idx2 + 2], 0.0f));</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span> <span class="comment">/* num_channels == 1 */</span></div>
<div class="line">                    {</div>
<div class="line">                        value = fmaxf(src_data[idx], 0.0f) + fmaxf(src_data[idx2], 0.0f);</div>
<div class="line">                    }</div>
<div class="line"></div>
<div class="line">                    sum_phi += value * mu;</div>
<div class="line">                    sample_data_phi[idx] = sum_phi;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// normalize CDF for phi</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = offset_phi + p_out;</div>
<div class="line">                    sample_data_phi[idx] = sample_data_phi[idx] / sum_phi;</div>
<div class="line">                }</div>
<div class="line"></div>
<div class="line">                <span class="comment">// build CDF for theta</span></div>
<div class="line">                sum_theta += sum_phi;</div>
<div class="line">                sample_data_theta[t_in * res.x + t_out] = sum_theta;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">if</span> (sum_theta &gt; max_albedo)</div>
<div class="line">                max_albedo = sum_theta;</div>
<div class="line"></div>
<div class="line">            albedo_data[t_in] = sum_theta;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// normalize CDF for theta</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = t_in * res.x + t_out;</div>
<div class="line">                sample_data_theta[idx] = sample_data_theta[idx] / sum_theta;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// copy entire CDF data buffer to GPU</span></div>
<div class="line">        CUdeviceptr sample_obj = 0;</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;sample_obj, sample_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        check_cuda_success(cuMemcpyHtoD(sample_obj, sample_data, sample_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        <span class="keyword">delete</span>[] sample_data;</div>
<div class="line"></div>
<div class="line">        CUdeviceptr albedo_obj = 0;</div>
<div class="line">        check_cuda_success(cuMemAlloc(&amp;albedo_obj, res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        check_cuda_success(cuMemcpyHtoD(albedo_obj, albedo_data, res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">        <span class="keyword">delete</span>[] albedo_data;</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">        mbsdf_cuda_representation.sample_data[part] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(sample_obj);</div>
<div class="line">        mbsdf_cuda_representation.albedo_data[part] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">float</span>*<span class="keyword">&gt;</span>(albedo_obj);</div>
<div class="line">        mbsdf_cuda_representation.max_albedo[part] = max_albedo;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// ----------------------------------------------------------------------------------------</span></div>
<div class="line">        <span class="comment">// prepare evaluation data:</span></div>
<div class="line">        <span class="comment">// - simply store the measured data in a volume texture</span></div>
<div class="line">        <span class="comment">// - in case of color data, we store each sample in a vector4 to get texture support</span></div>
<div class="line">        <span class="keywordtype">unsigned</span> lookup_channels = (num_channels == 3) ? 4 : 1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// make lookup data symmetric</span></div>
<div class="line">        <span class="keywordtype">float</span>* lookup_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[lookup_channels * res.y * res.x * res.x];</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_in = 0; t_in &lt; res.x; ++t_in)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t_out = 0; t_out &lt; res.x; ++t_out)</div>
<div class="line">            {</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi = (t_in * res.x + t_out) * res.y;</div>
<div class="line">                <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset_phi2 = (t_out * res.x + t_in) * res.y;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p_out = 0; p_out &lt; res.y; ++p_out)</div>
<div class="line">                {</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = offset_phi + p_out;</div>
<div class="line">                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx2 = offset_phi2 + p_out;</div>
<div class="line"></div>
<div class="line">                    <span class="keywordflow">if</span> (num_channels == 3)</div>
<div class="line">                    {</div>
<div class="line">                        lookup_data[4*idx+0] = (src_data[3*idx+0] + src_data[3*idx2+0]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+1] = (src_data[3*idx+1] + src_data[3*idx2+1]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+2] = (src_data[3*idx+2] + src_data[3*idx2+2]) * 0.5f;</div>
<div class="line">                        lookup_data[4*idx+3] = 1.0f;</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                    {</div>
<div class="line">                        lookup_data[idx] = (src_data[idx] + src_data[idx2]) * 0.5f;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy data to GPU array</span></div>
<div class="line">        cudaArray_t device_mbsdf_data;</div>
<div class="line">        cudaChannelFormatDesc channel_desc = (num_channels == 3</div>
<div class="line">            ? cudaCreateChannelDesc&lt;float4&gt;() <span class="comment">// float3 is not supported</span></div>
<div class="line">            : cudaCreateChannelDesc&lt;float&gt;());</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Allocate a 3D array on the GPU (phi_delta x theta_out x theta_in)</span></div>
<div class="line">        cudaExtent extent = make_cudaExtent(res.y, res.x, res.x);</div>
<div class="line">        check_cuda_success(cudaMalloc3DArray(&amp;device_mbsdf_data, &amp;channel_desc, extent, 0));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// prepare and copy</span></div>
<div class="line">        cudaMemcpy3DParms copy_params;</div>
<div class="line">        memset(&amp;copy_params, 0, <span class="keyword">sizeof</span>(copy_params));</div>
<div class="line">        copy_params.srcPtr = make_cudaPitchedPtr(</div>
<div class="line">            (<span class="keywordtype">void</span>*)(lookup_data),                                   <span class="comment">// base pointer</span></div>
<div class="line">            res.y * lookup_channels * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),                <span class="comment">// row pitch</span></div>
<div class="line">            res.y,                                                  <span class="comment">// width of slice</span></div>
<div class="line">            res.x);                                                 <span class="comment">// height of slice</span></div>
<div class="line">        copy_params.dstArray = device_mbsdf_data;</div>
<div class="line">        copy_params.extent = extent;</div>
<div class="line">        copy_params.kind = cudaMemcpyHostToDevice;</div>
<div class="line">        check_cuda_success(cudaMemcpy3D(&amp;copy_params));</div>
<div class="line">        <span class="keyword">delete</span>[] lookup_data;</div>
<div class="line"></div>
<div class="line">        cudaResourceDesc    texRes;</div>
<div class="line">        memset(&amp;texRes, 0, <span class="keyword">sizeof</span>(cudaResourceDesc));</div>
<div class="line">        texRes.resType = cudaResourceTypeArray;</div>
<div class="line">        texRes.res.array.array = device_mbsdf_data;</div>
<div class="line"></div>
<div class="line">        cudaTextureDesc     texDescr;</div>
<div class="line">        memset(&amp;texDescr, 0, <span class="keyword">sizeof</span>(cudaTextureDesc));</div>
<div class="line">        texDescr.normalizedCoords = 1;</div>
<div class="line">        texDescr.filterMode = cudaFilterModeLinear;</div>
<div class="line">        texDescr.addressMode[0] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.addressMode[1] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.addressMode[2] = cudaAddressModeClamp;</div>
<div class="line">        texDescr.readMode = cudaReadModeElementType;</div>
<div class="line"></div>
<div class="line">        cudaTextureObject_t eval_tex_obj;</div>
<div class="line">        check_cuda_success(cudaCreateTextureObject(&amp;eval_tex_obj, &amp;texRes, &amp;texDescr, <span class="keyword">nullptr</span>));</div>
<div class="line">        mbsdf_cuda_representation.eval_data[part] = eval_tex_obj;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_mbsdf(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           mbsdf_index,</div>
<div class="line">    std::vector&lt;Mbsdf&gt;                &amp;mbsdfs)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IBsdf_measurement&gt;</a> mbsdf(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1IBsdf__measurement.html" title="A scene element that stores measured BSDF data. ">mi::neuraylib::IBsdf_measurement</a>&gt;(</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae001a474fbb738d2c5b0cd9805e456c8" title="Returns the name of a bsdf measurement resource used by the target code. ">get_bsdf_measurement</a>(mbsdf_index)));</div>
<div class="line"></div>
<div class="line">    Mbsdf mbsdf_cuda;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// handle reflection and transmission</span></div>
<div class="line">    <span class="keywordflow">if</span> (!prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5adfe9c2690a07a463521000e33bb7c9b9" title="the bidirectional reflection distribution function (BRDF) ">mi::neuraylib::MBSDF_DATA_REFLECTION</a>, mbsdf_cuda, mbsdf.get()))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (!prepare_mbsdfs_part(<a class="code" href="group__mi__neuray__mdl__compiler.html#gga3b12efb3645f76a6f1233d671546bae5a441408b0557132f861adaeb9bf2b304b" title="the bidirectional transmission distribution function (BTDF) ">mi::neuraylib::MBSDF_DATA_TRANSMISSION</a>, mbsdf_cuda, mbsdf.get()))</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    mbsdfs.push_back(mbsdf_cuda);</div>
<div class="line">    m_all_mbsdfs-&gt;push_back(mbsdfs.back());</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_lightprofile(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>       *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span> *code_ptx,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>                           lightprofile_index,</div>
<div class="line">    std::vector&lt;Lightprofile&gt;         &amp;lightprofiles)</div>
<div class="line">{</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get access to the texture data by the texture database name from the target code.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ILightprofile&gt;</a> lprof_nr(</div>
<div class="line">        transaction-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html#adafe2621ae719c43076b79a5677b4934" title="Retrieves an element from the database. ">access</a>&lt;<a class="code" href="classmi_1_1neuraylib_1_1ILightprofile.html" title="This interface represents light profiles. ">mi::neuraylib::ILightprofile</a>&gt;(</div>
<div class="line">        code_ptx-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga9b21ee745bcf580cce3beef23fbfc6e6" title="Returns the name of a light profile resource used by the target code. ">get_light_profile</a>(lightprofile_index)));</div>
<div class="line"></div>
<div class="line">    uint2 res = make_uint2(lprof_nr-&gt;get_resolution_theta(), lprof_nr-&gt;get_resolution_phi());</div>
<div class="line">    float2 start = make_float2(lprof_nr-&gt;get_theta(0), lprof_nr-&gt;get_phi(0));</div>
<div class="line">    float2 delta = make_float2(lprof_nr-&gt;get_theta(1) - start.x, lprof_nr-&gt;get_phi(1) - start.y);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// phi-mayor: [res.x x res.y]</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">float</span>* data = lprof_nr-&gt;<a class="code" href="classmi_1_1neuraylib_1_1ITile.html#a0c4de1ae0441a464da1fc605369469f5" title="Returns a pointer to the raw tile data according to the pixel type of the tile. ">get_data</a>();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// compute total power</span></div>
<div class="line">    <span class="comment">// compute inverse CDF data for sampling</span></div>
<div class="line">    <span class="comment">// sampling will work on cells rather than grid nodes (used for evaluation)</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// first (res.x-1) for the cdf for sampling theta</span></div>
<div class="line">    <span class="comment">// rest (rex.x-1) * (res.y-1) for the individual cdfs for sampling phi (after theta)</span></div>
<div class="line">    <span class="keywordtype">size_t</span> cdf_data_size = (res.x - 1) + (res.x - 1) * (res.y - 1);</div>
<div class="line">    <span class="keywordtype">float</span>* cdf_data = <span class="keyword">new</span> <span class="keywordtype">float</span>[cdf_data_size];</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">float</span> debug_total_erea = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> sum_theta = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> total_power = 0.0f;</div>
<div class="line">    <span class="keywordtype">float</span> cos_theta0 = cosf(start.x);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t = 0; t &lt; res.x - 1; ++t)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> cos_theta1 = cosf(start.x + <span class="keywordtype">float</span>(t + 1) * delta.x);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// area of the patch (grid cell)</span></div>
<div class="line">        <span class="comment">// \mu = int_{theta0}^{theta1} sin{theta} \delta theta</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> mu = cos_theta0 - cos_theta1;</div>
<div class="line">        cos_theta0 = cos_theta1;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build CDF for phi</span></div>
<div class="line">        <span class="keywordtype">float</span>* cdf_data_phi = cdf_data + (res.x - 1) + t * (res.y - 1);</div>
<div class="line">        <span class="keywordtype">float</span> sum_phi = 0.0f;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; res.y - 1; ++p)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// the probability to select a patch corresponds to the value times area</span></div>
<div class="line">            <span class="comment">// the value of a cell is the average of the corners</span></div>
<div class="line">            <span class="comment">// omit the *1/4 as we normalize in the end</span></div>
<div class="line">            <span class="keywordtype">float</span> value = data[p * res.x + t]</div>
<div class="line">                + data[p * res.x + t + 1]</div>
<div class="line">                + data[(p + 1) * res.x + t]</div>
<div class="line">                + data[(p + 1) * res.x + t + 1];</div>
<div class="line"></div>
<div class="line">            sum_phi += value * mu;</div>
<div class="line">            cdf_data_phi[p] = sum_phi;</div>
<div class="line">            debug_total_erea += mu;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// normalize CDF for phi</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; res.y - 2; ++p)</div>
<div class="line">            cdf_data_phi[p] = sum_phi ? (cdf_data_phi[p] / sum_phi) : 0.0f;</div>
<div class="line"></div>
<div class="line">        cdf_data_phi[res.y - 2] = 1.0f;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// build CDF for theta</span></div>
<div class="line">        sum_theta += sum_phi;</div>
<div class="line">        cdf_data[t] = sum_theta;</div>
<div class="line">    }</div>
<div class="line">    total_power = sum_theta * 0.25f * delta.y;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// normalize CDF for theta</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> t = 0; t &lt; res.x - 2; ++t)</div>
<div class="line">        cdf_data[t] = sum_theta ? (cdf_data[t] / sum_theta) : cdf_data[t];</div>
<div class="line"></div>
<div class="line">    cdf_data[res.x - 2] = 1.0f;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// copy entire CDF data buffer to GPU</span></div>
<div class="line">    CUdeviceptr cdf_data_obj = 0;</div>
<div class="line">    check_cuda_success(cuMemAlloc(&amp;cdf_data_obj, cdf_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(cdf_data_obj, cdf_data, cdf_data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>)));</div>
<div class="line">    <span class="keyword">delete</span>[] cdf_data;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// --------------------------------------------------------------------------------------------</span></div>
<div class="line">    <span class="comment">// prepare evaluation data</span></div>
<div class="line">    <span class="comment">//  - use a 2d texture that allows bilinear interpolation</span></div>
<div class="line">    <span class="comment">// Copy data to GPU array</span></div>
<div class="line">    cudaArray_t device_lightprofile_data;</div>
<div class="line">    cudaChannelFormatDesc channel_desc = cudaCreateChannelDesc&lt;float&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="comment">// 2D texture objects use CUDA arrays</span></div>
<div class="line">    check_cuda_success(cudaMallocArray(&amp;device_lightprofile_data, &amp;channel_desc, res.x, res.y));</div>
<div class="line">    check_cuda_success(cudaMemcpy2DToArray(</div>
<div class="line">        device_lightprofile_data, 0, 0, data,</div>
<div class="line">        res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), res.x * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>), res.y, cudaMemcpyHostToDevice));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Create filtered texture object</span></div>
<div class="line">    cudaResourceDesc res_desc;</div>
<div class="line">    memset(&amp;res_desc, 0, <span class="keyword">sizeof</span>(res_desc));</div>
<div class="line">    res_desc.resType = cudaResourceTypeArray;</div>
<div class="line">    res_desc.res.array.array = device_lightprofile_data;</div>
<div class="line"></div>
<div class="line">    cudaTextureDesc tex_desc;</div>
<div class="line">    memset(&amp;tex_desc, 0, <span class="keyword">sizeof</span>(tex_desc));</div>
<div class="line">    tex_desc.addressMode[0] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.addressMode[1] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.addressMode[2] = cudaAddressModeClamp;</div>
<div class="line">    tex_desc.borderColor[0] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[1] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[2] = 1.0f;</div>
<div class="line">    tex_desc.borderColor[3] = 1.0f;</div>
<div class="line">    tex_desc.filterMode = cudaFilterModeLinear;</div>
<div class="line">    tex_desc.readMode = cudaReadModeElementType;</div>
<div class="line">    tex_desc.normalizedCoords = 1;</div>
<div class="line"></div>
<div class="line">    cudaTextureObject_t tex_obj = 0;</div>
<div class="line">    check_cuda_success(cudaCreateTextureObject(&amp;tex_obj, &amp;res_desc, &amp;tex_desc, <span class="keyword">nullptr</span>));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">double</span> multiplier = lprof_nr-&gt;get_candela_multiplier();</div>
<div class="line">    Lightprofile lprof(</div>
<div class="line">        res,</div>
<div class="line">        start,</div>
<div class="line">        delta,</div>
<div class="line">        <span class="keywordtype">float</span>(multiplier),</div>
<div class="line">        <span class="keywordtype">float</span>(total_power * multiplier),</div>
<div class="line">        tex_obj,</div>
<div class="line">        reinterpret_cast&lt;float*&gt;(cdf_data_obj));</div>
<div class="line"></div>
<div class="line">    lightprofiles.push_back(lprof);</div>
<div class="line">    m_all_lightprofiles-&gt;push_back(lightprofiles.back());</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prepare the needed target code data of the given target code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_gpu_context::prepare_target_code_data(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>          *transaction,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IImage__api.html" title="This interface provides various utilities related to canvases and buffers. ">mi::neuraylib::IImage_api</a>            *image_api,</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ITarget__code.html" title="Represents target code of an MDL backend. ">mi::neuraylib::ITarget_code</a> <span class="keyword">const</span>    *target_code,</div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span>            &amp;arg_block_indices)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Target code data list may not have been retrieved already</span></div>
<div class="line">    check_success(m_device_target_code_data_list.get() == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Handle the read-only data segments if necessary.</span></div>
<div class="line">    <span class="comment">// They are only created, if the &quot;enable_ro_segment&quot; backend option was set to &quot;on&quot;.</span></div>
<div class="line">    CUdeviceptr device_ro_data = 0;</div>
<div class="line">    <span class="keywordflow">if</span> (target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga2463c3e18318a828aaca780d42d1ae93" title="Returns the number of constant data initializers. ">get_ro_data_segment_count</a>() &gt; 0) {</div>
<div class="line">        device_ro_data = gpu_mem_dup(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gae8b6fe8d9476094193c84fd9d65273dd" title="Returns the data of the constant data segment at the given index. ">get_ro_data_segment_data</a>(0),</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga34a679f235fb3a81a9ffdff8205929d1" title="Returns the size of the constant data segment at the given index. ">get_ro_data_segment_size</a>(0));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy textures to GPU if the code has more than just the invalid texture</span></div>
<div class="line">    CUdeviceptr device_textures = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_textures = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5d379f3e8619bd43bfbe569c0490949a" title="Returns the number of texture resources used by the target code. ">get_texture_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_textures &gt; 1) {</div>
<div class="line">        std::vector&lt;Texture&gt; textures;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all textures skipping the first texture,</span></div>
<div class="line">        <span class="comment">// which is always the invalid texture</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_textures; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_texture(</div>
<div class="line">                    transaction, image_api, target_code, i, textures))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy texture list to GPU</span></div>
<div class="line">        device_textures = gpu_mem_dup(textures);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy MBSDFs to GPU if the code has more than just the invalid mbsdf</span></div>
<div class="line">    CUdeviceptr device_mbsdfs = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_mbsdfs = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga1c3669ca1523d2a98fcec3b049349f76" title="Returns the number of bsdf measurement resources used by the target code. ">get_bsdf_measurement_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_mbsdfs &gt; 1) {</div>
<div class="line">        std::vector&lt;Mbsdf&gt; mbsdfs;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all mbsdfs skipping the first mbsdf,</span></div>
<div class="line">        <span class="comment">// which is always the invalid mbsdf</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_mbsdfs; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_mbsdf(</div>
<div class="line">                transaction, target_code, i, mbsdfs))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy mbsdf list to GPU</span></div>
<div class="line">        device_mbsdfs = gpu_mem_dup(mbsdfs);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Copy light profiles to GPU if the code has more than just the invalid light profile</span></div>
<div class="line">    CUdeviceptr device_lightprofiles = 0;</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> num_lightprofiles = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gaf0cee310f5957d93edff6c4b13bc8e92" title="Returns the number of light profile resources used by the target code. ">get_light_profile_count</a>();</div>
<div class="line">    <span class="keywordflow">if</span> (num_lightprofiles &gt; 1) {</div>
<div class="line">        std::vector&lt;Lightprofile&gt; lightprofiles;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Loop over all profiles skipping the first profile,</span></div>
<div class="line">        <span class="comment">// which is always the invalid profile</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 1; i &lt; num_lightprofiles; ++i) {</div>
<div class="line">            <span class="keywordflow">if</span> (!prepare_lightprofile(</div>
<div class="line">                transaction, target_code, i, lightprofiles))</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Copy light profile list to GPU</span></div>
<div class="line">        device_lightprofiles = gpu_mem_dup(lightprofiles);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    (*m_target_code_data_list).push_back(</div>
<div class="line">        Target_code_data(num_textures, device_textures,</div>
<div class="line">                         num_mbsdfs, device_mbsdfs,</div>
<div class="line">                         num_lightprofiles, device_lightprofiles,</div>
<div class="line">                         device_ro_data));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> i = 0, num = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga6e3493e83e86a5f346f935cd9ac5f3f0" title="Returns the number of target argument blocks. ">get_argument_block_count</a>(); i &lt; num; ++i) {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block const&gt;</a> arg_block(</div>
<div class="line">            target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga21940811d1cb33be2400ee7e5bd66983" title="Get a target argument block if available. ">get_argument_block</a>(i));</div>
<div class="line">        CUdeviceptr dev_block = gpu_mem_dup(arg_block-&gt;get_data(), arg_block-&gt;get_size());</div>
<div class="line">        m_target_argument_block_list-&gt;push_back(dev_block);</div>
<div class="line">        m_own_arg_blocks.push_back(<a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(arg_block-&gt;clone()));</div>
<div class="line">        m_arg_block_layouts.push_back(</div>
<div class="line">            <a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga8359a85ac66eed012aa0332a12f43e3f" title="Get a captured arguments block layout if available. ">get_argument_block_layout</a>(i)));</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> arg_block_index : arg_block_indices) {</div>
<div class="line">        m_bsdf_arg_block_indices.push_back(arg_block_index);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Update the i&#39;th target argument block on the device with the data from the corresponding</span></div>
<div class="line"><span class="comment">// block returned by get_argument_block().</span></div>
<div class="line"><span class="keywordtype">void</span> Material_gpu_context::update_device_argument_block(<span class="keywordtype">size_t</span> i)</div>
<div class="line">{</div>
<div class="line">    CUdeviceptr device_ptr = get_device_target_argument_block(i);</div>
<div class="line">    <span class="keywordflow">if</span> (device_ptr == 0) <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ITarget_argument_block&gt;</a> arg_block(get_argument_block(i));</div>
<div class="line">    check_cuda_success(cuMemcpyHtoD(</div>
<div class="line">        device_ptr, arg_block-&gt;get_data(), arg_block-&gt;get_size()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// MDL material compilation code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Material_compiler {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Constructor.</span></div>
<div class="line">    Material_compiler(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_texture_results,</div>
<div class="line">#<span class="keywordflow">if</span> !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</div>
<div class="line">        <span class="keywordtype">bool</span> use_df_interpreter,</div>
<div class="line">#endif</div>
<div class="line">        <span class="keywordtype">bool</span> enable_derivatives,</div>
<div class="line">        <span class="keywordtype">bool</span> fold_ternary_on_df,</div>
<div class="line">        <span class="keywordtype">bool</span> enable_auxiliary,</div>
<div class="line">        <span class="keywordtype">bool</span> use_adapt_normal,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; df_handle_mode);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Loads an MDL module and returns the module DB.</span></div>
<div class="line">    std::string load_module(<span class="keyword">const</span> std::string&amp; mdl_module_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add a subexpression of a given material to the link unit.</span></div>
<div class="line">    <span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line">    <span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line">    <span class="comment">// If class_compilation is true, the material will use class compilation.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material_subexpr(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* fname,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation=<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add a distribution function of a given material to the link unit.</span></div>
<div class="line">    <span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line">    <span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line">    <span class="comment">// If class_compilation is true, the material will use class compilation.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material_df(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span>* base_fname,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation=<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Add (multiple) MDL distribution function and expressions of a material to this link unit.</span></div>
<div class="line">    <span class="comment">// For each distribution function it results in four functions, suffixed with \c &quot;_init&quot;,</span></div>
<div class="line">    <span class="comment">// \c &quot;_sample&quot;, \c &quot;_evaluate&quot;, and \c &quot;_pdf&quot;. Functions can be selected by providing a</span></div>
<div class="line">    <span class="comment">// a list of \c Target_function_descriptions. Each of them needs to define the \c path, the root</span></div>
<div class="line">    <span class="comment">// of the expression that should be translated. After calling this function, each element of</span></div>
<div class="line">    <span class="comment">// the list will contain information for later usage in the application,</span></div>
<div class="line">    <span class="comment">// e.g., the \c argument_block_index and the \c function_index.</span></div>
<div class="line">    <span class="keywordtype">bool</span> add_material(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">        <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>* function_descriptions,</div>
<div class="line">        <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> description_count,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Generates CUDA PTX target code for the current link unit.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> generate_cuda_ptx();</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;mi::base::Handle&lt;mi::neuraylib::IFunction_definition const&gt; &gt;</div>
<div class="line">        Material_definition_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the list of used material definitions.</span></div>
<div class="line">    <span class="comment">// There will be one entry per add_* call.</span></div>
<div class="line">    Material_definition_list <span class="keyword">const</span> &amp;get_material_defs()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> m_material_defs;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> std::vector&lt;mi::base::Handle&lt;mi::neuraylib::ICompiled_material const&gt; &gt;</div>
<div class="line">        Compiled_material_list;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get the list of compiled materials.</span></div>
<div class="line">    <span class="comment">// There will be one entry per add_* call.</span></div>
<div class="line">    Compiled_material_list <span class="keyword">const</span> &amp;get_compiled_materials()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> m_compiled_materials;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::vector&lt;size_t&gt; <span class="keyword">const</span> &amp;get_argument_block_indices()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_arg_block_indexes;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;std::string&gt;&amp; get_handles()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> m_handles;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// Creates an instance of the given material.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* create_material_instance(</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; material_db_name);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a>* compile_material_instance(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">        <span class="keywordtype">bool</span> class_compilation);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_impexp_api&gt;</a> m_mdl_impexp_api;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_backend&gt;</a>    m_be_cuda_ptx;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::IMdl_factory&gt;</a>    m_mdl_factory;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html">mi::base::Handle&lt;mi::neuraylib::ITransaction&gt;</a>    m_transaction;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IMdl_execution_context&gt;</a> m_context;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ILink_unit&gt;</a>             m_link_unit;</div>
<div class="line"></div>
<div class="line">    Material_definition_list  m_material_defs;</div>
<div class="line">    Compiled_material_list    m_compiled_materials;</div>
<div class="line">    std::vector&lt;size_t&gt;       m_arg_block_indexes;</div>
<div class="line">    std::vector&lt;std::string&gt;  m_handles;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor.</span></div>
<div class="line">Material_compiler::Material_compiler(</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__impexp__api.html" title="API component for MDL related import and export operations. ">mi::neuraylib::IMdl_impexp_api</a>* mdl_impexp_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__backend__api.html" title="This interface can be used to obtain the MDL backends. ">mi::neuraylib::IMdl_backend_api</a>* mdl_backend_api,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1IMdl__factory.html" title="Factory for various MDL interfaces and functions. ">mi::neuraylib::IMdl_factory</a>* mdl_factory,</div>
<div class="line">        <a class="code" href="classmi_1_1neuraylib_1_1ITransaction.html" title="A transaction provides a consistent view on the database. ">mi::neuraylib::ITransaction</a>* transaction,</div>
<div class="line">        <span class="keywordtype">unsigned</span> num_texture_results,</div>
<div class="line">#<span class="keywordflow">if</span> !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</div>
<div class="line">        <span class="keywordtype">bool</span> use_df_interpreter,</div>
<div class="line">#endif</div>
<div class="line">        <span class="keywordtype">bool</span> enable_derivatives,</div>
<div class="line">        <span class="keywordtype">bool</span> fold_ternary_on_df,</div>
<div class="line">        <span class="keywordtype">bool</span> enable_auxiliary,</div>
<div class="line">        <span class="keywordtype">bool</span> use_adapt_normal,</div>
<div class="line">        <span class="keyword">const</span> std::string&amp; df_handle_mode)</div>
<div class="line">    : m_mdl_impexp_api(mdl_impexp_api, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_be_cuda_ptx(mdl_backend_api-&gt;get_backend(mi::neuraylib::IMdl_backend_api::MB_CUDA_PTX))</div>
<div class="line">    , m_mdl_factory(mdl_factory, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_transaction(transaction, mi::base::<a class="code" href="group__mi__base__iinterface.html#ga3328e25679f6aa162cd95a2c9c9d5b09" title="Symbolic constant to trigger a special constructor in the Handle class. ">DUP_INTERFACE</a>)</div>
<div class="line">    , m_context(mdl_factory-&gt;create_execution_context())</div>
<div class="line">    , m_link_unit()</div>
<div class="line">{</div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;num_texture_spaces&quot;</span>, <span class="stringliteral">&quot;1&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;enable_ro_segment&quot;: Default is disabled.</span></div>
<div class="line">    <span class="comment">// If you have a lot of big arrays, enabling this might speed up compilation.</span></div>
<div class="line">    <span class="comment">// check_success(m_be_cuda_ptx-&gt;set_option(&quot;enable_ro_segment&quot;, &quot;on&quot;) == 0);</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (enable_derivatives) {</div>
<div class="line">        <span class="comment">// Option &quot;texture_runtime_with_derivs&quot;: Default is disabled.</span></div>
<div class="line">        <span class="comment">// We enable it to get coordinates with derivatives for texture lookup functions.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;texture_runtime_with_derivs&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;tex_lookup_call_mode&quot;: Default mode is vtable mode.</span></div>
<div class="line">    <span class="comment">// You can switch to the slower vtable mode by commenting out the next line.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;tex_lookup_call_mode&quot;</span>, <span class="stringliteral">&quot;direct_call&quot;</span>) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;num_texture_results&quot;: Default is 0.</span></div>
<div class="line">    <span class="comment">// Set the size of a renderer provided array for texture results in the MDL SDK state in number</span></div>
<div class="line">    <span class="comment">// of float4 elements processed by the init() function.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(</div>
<div class="line">        <span class="stringliteral">&quot;num_texture_results&quot;</span>,</div>
<div class="line">        to_string(num_texture_results).c_str()) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (enable_auxiliary) {</div>
<div class="line">        <span class="comment">// Option &quot;enable_auxiliary&quot;: Default is disabled.</span></div>
<div class="line">        <span class="comment">// We enable it to create an additional &#39;auxiliary&#39; function that can be called on each</span></div>
<div class="line">        <span class="comment">// distribution function to fill an albedo and normal buffer e.g. for denoising.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;enable_auxiliary&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#if !defined(MDL_SOURCE_RELEASE) &amp;&amp; defined(MDL_ENABLE_INTERPRETER)</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// Option &quot;enable_df_interpreter&quot;: Default is disabled.</span></div>
<div class="line">    <span class="comment">// Using the interpreter allows to reuse the same code for multiple materials</span></div>
<div class="line">    <span class="comment">// reducing code divergence, if your scene shows many materials at the same time.</span></div>
<div class="line">    <span class="keywordflow">if</span> (use_df_interpreter) {</div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;enable_df_interpreter&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Option &quot;df_handle_slot_mode&quot;: Default is &quot;none&quot;.</span></div>
<div class="line">    <span class="comment">// When using light path expressions, individual parts of the distribution functions can be</span></div>
<div class="line">    <span class="comment">// selected using &quot;handles&quot;. The contribution of each of those parts has to be evaluated during</span></div>
<div class="line">    <span class="comment">// rendering. This option controls how many parts are evaluated with each call into the</span></div>
<div class="line">    <span class="comment">// generated &quot;evaluate&quot; and &quot;auxiliary&quot; functions and how the data is passed.</span></div>
<div class="line">    <span class="comment">// The CUDA backend supports pointers, which means an externally managed buffer of arbitrary</span></div>
<div class="line">    <span class="comment">// size is used to transport the contributions of each part.</span></div>
<div class="line">    check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;df_handle_slot_mode&quot;</span>, df_handle_mode.c_str()) == 0);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Option &quot;scene_data_names&quot;: Default is &quot;&quot;.</span></div>
<div class="line">    <span class="comment">// Uncomment the line below to enable calling the scene data runtime functions</span></div>
<div class="line">    <span class="comment">// for any scene data names or specify a comma-separated list of names for which</span></div>
<div class="line">    <span class="comment">// you may provide scene data. The example runtime functions always return the</span></div>
<div class="line">    <span class="comment">// default values, which is the same as not supporting any scene data.</span></div>
<div class="line">    <span class="comment">//     m_be_cuda_ptx-&gt;set_option(&quot;scene_data_names&quot;, &quot;*&quot;);</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (use_adapt_normal) {</div>
<div class="line">        <span class="comment">// Option &quot;use_renderer_adapt_normal&quot;: Default is &quot;off&quot;.</span></div>
<div class="line">        <span class="comment">// If enabled, the renderer can adapt the normal of BSDFs before use.</span></div>
<div class="line">        check_success(m_be_cuda_ptx-&gt;set_option(<span class="stringliteral">&quot;use_renderer_adapt_normal&quot;</span>, <span class="stringliteral">&quot;on&quot;</span>) == 0);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// force experimental to true for now</span></div>
<div class="line">    m_context-&gt;set_option(<span class="stringliteral">&quot;experimental&quot;</span>, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">    m_context-&gt;set_option(<span class="stringliteral">&quot;fold_ternary_on_df&quot;</span>, fold_ternary_on_df);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// After we set the options, we can create the link unit</span></div>
<div class="line">    m_link_unit = <a class="code" href="group__mi__base__iinterface.html#ga18f61a252409bb61d7b686868aebfef9" title="Returns a handle that holds the interface pointer passed in as argument. ">mi::base::make_handle</a>(m_be_cuda_ptx-&gt;create_link_unit(transaction, m_context.get()));</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">std::string Material_compiler::load_module(<span class="keyword">const</span> std::string&amp; mdl_module_name)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// load module</span></div>
<div class="line">    m_mdl_impexp_api-&gt;load_module(m_transaction.get(), mdl_module_name.c_str(), m_context.get());</div>
<div class="line">    <span class="keywordflow">if</span> (!print_messages(m_context.get()))</div>
<div class="line">        exit_failure(<span class="stringliteral">&quot;Failed to load module: %s&quot;</span>, mdl_module_name.c_str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// get and return the DB name</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::IString&gt;</a> db_module_name(</div>
<div class="line">        m_mdl_factory-&gt;get_db_module_name(mdl_module_name.c_str()));</div>
<div class="line">    <span class="keywordflow">return</span> db_module_name-&gt;get_c_str();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Creates an instance of the given material.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* Material_compiler::create_material_instance(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create a material instance from the material definition</span></div>
<div class="line">    <span class="comment">// with the default arguments.</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IFunction_definition&gt;</a> material_definition(</div>
<div class="line">        m_transaction-&gt;access&lt;<a class="code" href="classmi_1_1neuraylib_1_1IFunction__definition.html" title="This interface represents a function definition. ">mi::neuraylib::IFunction_definition</a>&gt;(</div>
<div class="line">            material_db_name.c_str()));</div>
<div class="line">    <span class="keywordflow">if</span> (!material_definition) {</div>
<div class="line">        <span class="comment">// material with given name does not exist</span></div>
<div class="line">        print_message(</div>
<div class="line">            <a class="code" href="group__mi__base__ilogger.html#gga35cadb98d3212ad7941f401da374f28dadaba4c0d57879faf349416dce0d3cb10" title="An error has occurred. ">mi::base::details::MESSAGE_SEVERITY_ERROR</a>,</div>
<div class="line">            <a class="code" href="classmi_1_1neuraylib_1_1IMessage.html#acd9444148b559e3d89a2b0042db48207aea0e19abaf4d2903fa254edc9d5c1051" title="MDL Core DAG generator message. ">mi::neuraylib::IMessage::MSG_COMPILER_DAG</a>,</div>
<div class="line">            (</div>
<div class="line">                <span class="stringliteral">&quot;Material &#39;&quot;</span> +</div>
<div class="line">                material_db_name +</div>
<div class="line">                <span class="stringliteral">&quot;&#39; does not exist in &#39;&quot;</span> +</div>
<div class="line">                qualified_module_name + <span class="stringliteral">&quot;&#39;&quot;</span>).c_str());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    m_material_defs.push_back(material_definition);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gafcdcb44319b0596ee8a9a44fddaec8c6" title="32-bit signed integer. ">mi::Sint32</a> result;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        material_definition-&gt;create_function_call(0, &amp;result));</div>
<div class="line">    check_success(result == 0);</div>
<div class="line"></div>
<div class="line">    material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> material_instance.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Compiles the given material instance in the given compilation modes.</span></div>
<div class="line"><a class="code" href="classmi_1_1neuraylib_1_1ICompiled__material.html" title="This interface represents a compiled material. ">mi::neuraylib::ICompiled_material</a> *Material_compiler::compile_material_instance(</div>
<div class="line">    <a class="code" href="classmi_1_1neuraylib_1_1IFunction__call.html" title="This interface represents a function call. ">mi::neuraylib::IFunction_call</a>* material_instance,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#ga607bb87332bf166dbd67cb30ca30da3a" title="32-bit unsigned integer. ">mi::Uint32</a> flags = class_compilation</div>
<div class="line">        ? <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959a7474d76ee055edda39a494edf06cfc36" title="Selects class compilation instead of instance compilation. ">mi::neuraylib::IMaterial_instance::CLASS_COMPILATION</a></div>
<div class="line">        : <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html#ab0b7608e59f1ad96b00a2fbb5cc2d959afdcc06252ec8a89909ddd69006031766" title="Default compilation options (e.g., instance compilation). ">mi::neuraylib::IMaterial_instance::DEFAULT_OPTIONS</a>;</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::IMaterial_instance&gt;</a> material_instance2(</div>
<div class="line">        material_instance-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#aa24ef1b57dcff38f9abafc420978df5c" title="Acquires a const interface from another. ">get_interface</a>&lt;<span class="keyword">const</span> <a class="code" href="classmi_1_1neuraylib_1_1IMaterial__instance.html" title="This interface represents a material instance. ">mi::neuraylib::IMaterial_instance</a>&gt;());</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        material_instance2-&gt;create_compiled_material(flags, m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line"></div>
<div class="line">    m_compiled_materials.push_back(compiled_material);</div>
<div class="line"></div>
<div class="line">    compiled_material-&gt;<a class="code" href="classmi_1_1base_1_1IInterface.html#a2c52e362969ee0f56ab5f8655937402f" title="Increments the reference count. ">retain</a>();</div>
<div class="line">    <span class="keywordflow">return</span> compiled_material.get();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generates CUDA PTX target code for the current link unit.</span></div>
<div class="line"><a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> Material_compiler::generate_cuda_ptx()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> code_cuda_ptx(</div>
<div class="line">        m_be_cuda_ptx-&gt;translate_link_unit(m_link_unit.get(), m_context.get()));</div>
<div class="line">    check_success(print_messages(m_context.get()));</div>
<div class="line">    check_success(code_cuda_ptx);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef DUMP_PTX</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping CUDA PTX code:\n\n&quot;</span></div>
<div class="line">        &lt;&lt; code_cuda_ptx-&gt;get_code() &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="keywordflow">return</span> code_cuda_ptx;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a subexpression of a given material to the link unit.</span></div>
<div class="line"><span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line"><span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material_subexpr(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* fname,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a> desc;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#ga16a953c7e8bad024170a407b79372601" title="The path from the material root to the expression that should be translated, e.g., &quot;surface.scattering&quot;. ">path</a> = path;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gac11619c64e2547799987787278060abc" title="The base name of the generated functions. ">base_fname</a> = fname;</div>
<div class="line">    add_material(qualified_module_name, material_db_name, &amp;desc, 1, class_compilation);</div>
<div class="line">    <span class="keywordflow">return</span> desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gad50243f50149324fd09ca0206e35d265" title="A return code. ">return_code</a> == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add a distribution function of a given material to the link unit.</span></div>
<div class="line"><span class="comment">// path is the path of the sub-expression.</span></div>
<div class="line"><span class="comment">// fname is the function name in the generated code.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material_df(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* path,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* base_fname,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a> desc;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#ga16a953c7e8bad024170a407b79372601" title="The path from the material root to the expression that should be translated, e.g., &quot;surface.scattering&quot;. ">path</a> = path;</div>
<div class="line">    desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gac11619c64e2547799987787278060abc" title="The base name of the generated functions. ">base_fname</a> = base_fname;</div>
<div class="line">    add_material(qualified_module_name, material_db_name, &amp;desc, 1, class_compilation);</div>
<div class="line">    <span class="keywordflow">return</span> desc.<a class="code" href="group__mi__neuray__mdl__compiler.html#gad50243f50149324fd09ca0206e35d265" title="A return code. ">return_code</a> == 0;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Add (multiple) MDL distribution function and expressions of a material to this link unit.</span></div>
<div class="line"><span class="comment">// For each distribution function it results in four functions, suffixed with \c &quot;_init&quot;,</span></div>
<div class="line"><span class="comment">// \c &quot;_sample&quot;, \c &quot;_evaluate&quot;, and \c &quot;_pdf&quot;. Functions can be selected by providing a</span></div>
<div class="line"><span class="comment">// a list of \c Target_function_description. Each of them needs to define the \c path, the root</span></div>
<div class="line"><span class="comment">// of the expression that should be translated. After calling this function, each element of</span></div>
<div class="line"><span class="comment">// the list will contain information for later usage in the application,</span></div>
<div class="line"><span class="comment">// e.g., the \c argument_block_index and the \c function_index.</span></div>
<div class="line"><span class="keywordtype">bool</span> Material_compiler::add_material(</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; qualified_module_name,</div>
<div class="line">    <span class="keyword">const</span> std::string&amp; material_db_name,</div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Target__function__description.html" title="Description of target function. ">mi::neuraylib::Target_function_description</a>* function_descriptions,</div>
<div class="line">    <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> description_count,</div>
<div class="line">    <span class="keywordtype">bool</span> class_compilation)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (description_count == 0)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load the given module and create a material instance</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::IFunction_call&gt;</a> material_instance(</div>
<div class="line">        create_material_instance(qualified_module_name, material_db_name));</div>
<div class="line">    <span class="keywordflow">if</span> (!material_instance)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Compile the material instance in instance compilation mode</span></div>
<div class="line">    <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;mi::neuraylib::ICompiled_material&gt;</a> compiled_material(</div>
<div class="line">        compile_material_instance(material_instance.get(), class_compilation));</div>
<div class="line"></div>
<div class="line">    m_link_unit-&gt;add_material(</div>
<div class="line">        compiled_material.get(), function_descriptions, description_count,</div>
<div class="line">        m_context.get());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Note: the same argument_block_index is filled into all function descriptions of a</span></div>
<div class="line">    <span class="comment">//       material, if any function uses it</span></div>
<div class="line">    m_arg_block_indexes.push_back(function_descriptions[0].argument_block_index);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> print_messages(m_context.get());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// Material execution code</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------------</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper function to create PTX source code for a non-empty 32-bit value array.</span></div>
<div class="line"><span class="keywordtype">void</span> print_array_u32(</div>
<div class="line">    std::string &amp;str, std::string <span class="keyword">const</span> &amp;name, <span class="keywordtype">unsigned</span> count, std::string <span class="keyword">const</span> &amp;content)</div>
<div class="line">{</div>
<div class="line">    str += <span class="stringliteral">&quot;.visible .const .align 4 .u32 &quot;</span> + name + <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (count == 0) {</div>
<div class="line">        <span class="comment">// PTX does not allow empty arrays, so use a dummy entry</span></div>
<div class="line">        str += <span class="stringliteral">&quot;1] = { 0 };\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        str += to_string(count) + <span class="stringliteral">&quot;] = { &quot;</span> + content + <span class="stringliteral">&quot; };\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Helper function to create PTX source code for a non-empty function pointer array.</span></div>
<div class="line"><span class="keywordtype">void</span> print_array_func(</div>
<div class="line">    std::string &amp;str, std::string <span class="keyword">const</span> &amp;name, <span class="keywordtype">unsigned</span> count, std::string <span class="keyword">const</span> &amp;content)</div>
<div class="line">{</div>
<div class="line">    str += <span class="stringliteral">&quot;.visible .const .align 8 .u64 &quot;</span> + name + <span class="stringliteral">&quot;[&quot;</span>;</div>
<div class="line">    <span class="keywordflow">if</span> (count == 0) {</div>
<div class="line">        <span class="comment">// PTX does not allow empty arrays, so use a dummy entry</span></div>
<div class="line">        str += <span class="stringliteral">&quot;1] = { dummy_func };\n&quot;</span>;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        str += to_string(count) + <span class="stringliteral">&quot;] = { &quot;</span> + content + <span class="stringliteral">&quot; };\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Generate PTX array containing the references to all generated functions.</span></div>
<div class="line">std::string generate_func_array_ptx(</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> &gt; &amp;target_codes)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Create PTX header and mdl_expr_functions_count constant</span></div>
<div class="line">    std::string src =</div>
<div class="line">        <span class="stringliteral">&quot;.version 4.0\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;.target sm_20\n&quot;</span></div>
<div class="line">        <span class="stringliteral">&quot;.address_size 64\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Workaround needed to let CUDA linker resolve the function pointers in the arrays.</span></div>
<div class="line">    <span class="comment">// Also used for &quot;empty&quot; function arrays.</span></div>
<div class="line">    src += <span class="stringliteral">&quot;.func dummy_func() { ret; }\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    std::string tc_offsets;</div>
<div class="line">    std::string function_names;</div>
<div class="line">    std::string tc_indices;</div>
<div class="line">    std::string ab_indices;</div>
<div class="line">    <span class="keywordtype">unsigned</span> f_count = 0;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Iterate over all target codes</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> tc_index = 0, num = target_codes.size(); tc_index &lt; num; ++tc_index)</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> <span class="keyword">const</span> &amp;target_code =</div>
<div class="line">            target_codes[tc_index];</div>
<div class="line"></div>
<div class="line">        <span class="comment">// in case of multiple target codes, we need to address the functions by a pair of</span></div>
<div class="line">        <span class="comment">// target_code_index and function_index.</span></div>
<div class="line">        <span class="comment">// the elements in the resulting function array can then be index by offset + func_index.</span></div>
<div class="line">        <span class="keywordflow">if</span>(!tc_offsets.empty())</div>
<div class="line">            tc_offsets += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">        tc_offsets += to_string(f_count);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Collect all names and prototypes of callable functions within the current target code</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> func_index = 0, func_count = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga5002e9d426ebb8abd844b418541d9870" title="Returns the number of callable functions in the target code. ">get_callable_function_count</a>();</div>
<div class="line">             func_index &lt; func_count; ++func_index)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// add to function list</span></div>
<div class="line">            <span class="keywordflow">if</span> (!tc_indices.empty())</div>
<div class="line">            {</div>
<div class="line">                tc_indices += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">                function_names += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">                ab_indices += <span class="stringliteral">&quot;, &quot;</span>;</div>
<div class="line">            }</div>
<div class="line"></div>
<div class="line">            <span class="comment">// target code index in case of multiple link units</span></div>
<div class="line">            tc_indices += to_string(tc_index);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// name of the function</span></div>
<div class="line">            function_names += target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#gab23aae54fc513ea49c271ea09287ad7e" title="Returns the name of a callable function in the target code. ">get_callable_function</a>(func_index);</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Get argument block index and translate to 1 based list index (-&gt; 0 = not-used)</span></div>
<div class="line">            <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a> ab_index = target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga3b64734a46cffe60913b567108f30ed3" title="Get the index of the target argument block to use with a callable function. ">get_callable_function_argument_block_index</a>(func_index);</div>
<div class="line">            ab_indices += to_string(ab_index == <a class="code" href="group__mi__base__types.html#gaa8e6476e3c0fc948ef75264572568791" title="Unsigned integral type that is large enough to hold the size of all types. ">mi::Size</a>(~0) ? 0 : (ab_index + 1));</div>
<div class="line">            f_count++;</div>
<div class="line"></div>
<div class="line">            <span class="comment">// Add prototype declaration</span></div>
<div class="line">            src += target_code-&gt;<a class="code" href="group__mi__neuray__mdl__compiler.html#ga67096668a1a25617564ecd8687023fe6" title="Returns the prototype of a callable function in the target code. ">get_callable_function_prototype</a>(</div>
<div class="line">                func_index, mi::neuraylib::ITarget_code::SL_PTX);</div>
<div class="line">            src += <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// infos per target code (link unit)</span></div>
<div class="line">    src += std::string(<span class="stringliteral">&quot;.visible .const .align 4 .u32 mdl_target_code_count = &quot;</span>)</div>
<div class="line">        + to_string(target_codes.size()) + <span class="stringliteral">&quot;;\n&quot;</span>;</div>
<div class="line">    print_array_u32(</div>
<div class="line">        src, std::string(<span class="stringliteral">&quot;mdl_target_code_offsets&quot;</span>), <span class="keywordtype">unsigned</span>(target_codes.size()), tc_offsets);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// infos per function</span></div>
<div class="line">    src += std::string(<span class="stringliteral">&quot;.visible .const .align 4 .u32 mdl_functions_count = &quot;</span>)</div>
<div class="line">        + to_string(f_count) + <span class="stringliteral">&quot;;\n&quot;</span>;</div>
<div class="line">    print_array_func(src, std::string(<span class="stringliteral">&quot;mdl_functions&quot;</span>), f_count, function_names);</div>
<div class="line">    print_array_u32(src, std::string(<span class="stringliteral">&quot;mdl_arg_block_indices&quot;</span>), f_count, ab_indices);</div>
<div class="line">    print_array_u32(src, std::string(<span class="stringliteral">&quot;mdl_target_code_indices&quot;</span>), f_count, tc_indices);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> src;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Build a linked CUDA kernel containing our kernel and all the generated code, making it</span></div>
<div class="line"><span class="comment">// available to the kernel via an added &quot;mdl_expr_functions&quot; array.</span></div>
<div class="line">CUmodule build_linked_kernel(</div>
<div class="line">    std::vector&lt;<a class="code" href="classmi_1_1base_1_1Handle.html" title="Handle class template for interfaces, automatizing the lifetime control via reference counting...">mi::base::Handle&lt;const mi::neuraylib::ITarget_code&gt;</a> &gt; <span class="keyword">const</span> &amp;target_codes,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *ptx_file,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *kernel_function_name,</div>
<div class="line">    CUfunction *out_kernel_function)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Generate PTX array containing the references to all generated functions.</span></div>
<div class="line">    <span class="comment">// The linker will resolve them to addresses.</span></div>
<div class="line"></div>
<div class="line">    std::string ptx_func_array_src = generate_func_array_ptx(target_codes);</div>
<div class="line"><span class="preprocessor">#ifdef DUMP_PTX</span></div>
<div class="line"><span class="preprocessor"></span>    std::cout &lt;&lt; <span class="stringliteral">&quot;Dumping CUDA PTX code for the \&quot;mdl_expr_functions\&quot; array:\n\n&quot;</span></div>
<div class="line">        &lt;&lt; ptx_func_array_src &lt;&lt; std::endl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">    <span class="comment">// Link all generated code, our generated PTX array and our kernel together</span></div>
<div class="line"></div>
<div class="line">    CUlinkState   cuda_link_state;</div>
<div class="line">    CUmodule      cuda_module;</div>
<div class="line">    <span class="keywordtype">void</span>         *linked_cubin;</div>
<div class="line">    <span class="keywordtype">size_t</span>        linked_cubin_size;</div>
<div class="line">    <span class="keywordtype">char</span>          error_log[8192], info_log[8192];</div>
<div class="line">    CUjit_option  options[4];</div>
<div class="line">    <span class="keywordtype">void</span>         *optionVals[4];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup the linker</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Pass a buffer for info messages</span></div>
<div class="line">    options[0] = CU_JIT_INFO_LOG_BUFFER;</div>
<div class="line">    optionVals[0] = info_log;</div>
<div class="line">    <span class="comment">// Pass the size of the info buffer</span></div>
<div class="line">    options[1] = CU_JIT_INFO_LOG_BUFFER_SIZE_BYTES;</div>
<div class="line">    optionVals[1] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(uintptr_t(<span class="keyword">sizeof</span>(info_log)));</div>
<div class="line">    <span class="comment">// Pass a buffer for error messages</span></div>
<div class="line">    options[2] = CU_JIT_ERROR_LOG_BUFFER;</div>
<div class="line">    optionVals[2] = error_log;</div>
<div class="line">    <span class="comment">// Pass the size of the error buffer</span></div>
<div class="line">    options[3] = CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES;</div>
<div class="line">    optionVals[3] = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>(uintptr_t(<span class="keyword">sizeof</span>(error_log)));</div>
<div class="line"></div>
<div class="line">    check_cuda_success(cuLinkCreate(4, options, optionVals, &amp;cuda_link_state));</div>
<div class="line"></div>
<div class="line">    CUresult link_result = CUDA_SUCCESS;</div>
<div class="line">    <span class="keywordflow">do</span> {</div>
<div class="line">        <span class="comment">// Add all code generated by the MDL PTX backend</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0, num_target_codes = target_codes.size(); i &lt; num_target_codes; ++i) {</div>
<div class="line">            link_result = cuLinkAddData(</div>
<div class="line">                cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">                const_cast&lt;char *&gt;(target_codes[i]-&gt;get_code()),</div>
<div class="line">                target_codes[i]-&gt;get_code_size(),</div>
<div class="line">                <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add the &quot;mdl_expr_functions&quot; array PTX module</span></div>
<div class="line">        link_result = cuLinkAddData(</div>
<div class="line">            cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">            const_cast&lt;char *&gt;(ptx_func_array_src.c_str()),</div>
<div class="line">            ptx_func_array_src.size(),</div>
<div class="line">            <span class="keyword">nullptr</span>, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Add our kernel</span></div>
<div class="line">        link_result = cuLinkAddFile(</div>
<div class="line">            cuda_link_state, CU_JIT_INPUT_PTX,</div>
<div class="line">            ptx_file, 0, <span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) <span class="keywordflow">break</span>;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Link everything to a cubin</span></div>
<div class="line">        link_result = cuLinkComplete(cuda_link_state, &amp;linked_cubin, &amp;linked_cubin_size);</div>
<div class="line">    } <span class="keywordflow">while</span> (<span class="keyword">false</span>);</div>
<div class="line">    <span class="keywordflow">if</span> (link_result != CUDA_SUCCESS) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;PTX linker error:\n&quot;</span> &lt;&lt; error_log &lt;&lt; std::endl;</div>
<div class="line">        check_cuda_success(link_result);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;CUDA link completed.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">if</span> (info_log[0])</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Linker output:\n&quot;</span> &lt;&lt; info_log &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Load the result and get the entrypoint of our kernel</span></div>
<div class="line">    check_cuda_success(cuModuleLoadData(&amp;cuda_module, linked_cubin));</div>
<div class="line">    check_cuda_success(cuModuleGetFunction(</div>
<div class="line">        out_kernel_function, cuda_module, kernel_function_name));</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> regs = 0;</div>
<div class="line">    check_cuda_success(</div>
<div class="line">        cuFuncGetAttribute(&amp;regs, CU_FUNC_ATTRIBUTE_NUM_REGS, *out_kernel_function));</div>
<div class="line">    <span class="keywordtype">int</span> lmem = 0;</div>
<div class="line">    check_cuda_success(</div>
<div class="line">        cuFuncGetAttribute(&amp;lmem, CU_FUNC_ATTRIBUTE_LOCAL_SIZE_BYTES, *out_kernel_function));</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Kernel uses &quot;</span> &lt;&lt; regs &lt;&lt; <span class="stringliteral">&quot; registers and &quot;</span> &lt;&lt; lmem &lt;&lt; <span class="stringliteral">&quot; lmem and has a size of &quot;</span></div>
<div class="line">        &lt;&lt; linked_cubin_size &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Cleanup</span></div>
<div class="line">    check_cuda_success(cuLinkDestroy(cuda_link_state));</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> cuda_module;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // EXAMPLE_CUDA_SHARED_H</span></div>
<div class="line"><span class="preprocessor"></span></div>
</div><!-- fragment --><p><b>Source Code Location:</b> <code>examples/mdl_sdk/execution_cuda/example_execution_cuda.cu</code></p>
<div class="fragment"><div class="line"><span class="comment">/******************************************************************************</span></div>
<div class="line"><span class="comment"> * Copyright 2022 NVIDIA Corporation. All rights reserved.</span></div>
<div class="line"><span class="comment"> *****************************************************************************/</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// examples/mdl_sdk/execution_cuda/example_execution_cuda.cu</span></div>
<div class="line"><span class="comment">//</span></div>
<div class="line"><span class="comment">// This file contains the CUDA kernel used to evaluate the material sub-expressions.</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cuda_runtime.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;device_launch_parameters.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="math_8h.html" title="Math API. ">math.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;texture_support_cuda.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// To reuse this sample code for the MDL SDK and MDL Core the corresponding namespaces are used.</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// when this CUDA code is used in the context of an SDK sample.</span></div>
<div class="line"><span class="preprocessor">#if defined(MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define BSDF_USE_MATERIAL_IOR MI_NEURAYLIB_BSDF_USE_MATERIAL_IOR</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">using namespace </span>mi::neuraylib;</div>
<div class="line"><span class="comment">// when this CUDA code is used in the context of an Core sample.</span></div>
<div class="line"><span class="preprocessor">#elif defined(MDL_CORE_BSDF_USE_MATERIAL_IOR)</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">    #define BSDF_USE_MATERIAL_IOR MDL_CORE_BSDF_USE_MATERIAL_IOR</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">using namespace </span>mi::mdl;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#gab7316602c27a9f88add79aeec40ef134" title="Signature of material expression functions created via mi::neuraylib::IMdl_backend::translate_materia...">Material_expr_function_with_derivs</a> Mat_expr_func;</div>
<div class="line"><span class="keyword">typedef</span> Shading_state_material_with_derivs Mdl_state;</div>
<div class="line"><span class="keyword">typedef</span> Texture_handler_deriv Tex_handler;</div>
<div class="line"><span class="preprocessor">#define TEX_VTABLE tex_deriv_vtable</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">typedef</span> <a class="code" href="group__mi__neuray__mdl__compiler.html#ga709d350d54344584622f892f119e3dea" title="Signature of material expression functions created via mi::neuraylib::IMdl_backend::translate_materia...">Material_expr_function</a> Mat_expr_func;</div>
<div class="line"><span class="keyword">typedef</span> Shading_state_material Mdl_state;</div>
<div class="line"><span class="keyword">typedef</span> Texture_handler Tex_handler;</div>
<div class="line"><span class="preprocessor">#define TEX_VTABLE tex_vtable</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom structure representing the resources used by the generated code of a target code object.</span></div>
<div class="line"><span class="keyword">struct </span>Target_code_data</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">size_t</span>       num_textures;      <span class="comment">// number of elements in the textures field</span></div>
<div class="line">    Texture     *textures;          <span class="comment">// a list of Texture objects, if used</span></div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span>  *ro_data_segment;   <span class="comment">// the read-only data segment, if used</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// The number of generated MDL sub-expression functions available.</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_functions_count;</div>
<div class="line"></div>
<div class="line"><span class="comment">// The target argument block indices for the generated MDL sub-expression functions.</span></div>
<div class="line"><span class="comment">// Note: the original indices are incremented by one to allow us to use 0 as &quot;not-used&quot;.</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_arg_block_indices[];</div>
<div class="line"></div>
<div class="line"><span class="comment">// The function pointers of the generated MDL sub-expression functions.</span></div>
<div class="line"><span class="comment">// In this example it is assumed that only expressions are added to the link unit.</span></div>
<div class="line"><span class="comment">// For a more complex use case, see also example df_cuda.</span></div>
<div class="line"><span class="keyword">extern</span> __constant__ Mat_expr_func    *mdl_functions[];</div>
<div class="line"></div>
<div class="line"><span class="comment">// The target code indices for the generated MDL sub-expression functions.</span></div>
<div class="line"><span class="comment">// In contrast to the df_cuda sample, this example simply iterates over all generated expressions.</span></div>
<div class="line"><span class="comment">// Therefore, no target_code_indices and function_indices are passed from the host side.</span></div>
<div class="line"><span class="comment">// Instead, this additional array allows the mapping to target_code_index. </span></div>
<div class="line"><span class="keyword">extern</span> __constant__ <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     mdl_target_code_indices[];</div>
<div class="line"></div>
<div class="line"><span class="comment">// Identity matrix.</span></div>
<div class="line"><span class="comment">// The last row is always implied to be (0, 0, 0, 1).</span></div>
<div class="line">__constant__ <span class="keyword">const</span> <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">tct_float4</a> identity[3] = {</div>
<div class="line">    {1.0f, 0.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 1.0f, 0.0f, 0.0f},</div>
<div class="line">    {0.0f, 0.0f, 1.0f, 0.0f}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"><span class="comment">// Calculate radical inverse with base 2.</span></div>
<div class="line">__device__ <span class="keywordtype">float</span> radinv2(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bits)</div>
<div class="line">{</div>
<div class="line">    bits = (bits &lt;&lt; 16) | (bits &gt;&gt; 16);</div>
<div class="line">    bits = ((bits &amp; 0x00ff00ff) &lt;&lt; 8) | ((bits &amp; 0xff00ff00) &gt;&gt; 8);</div>
<div class="line">    bits = ((bits &amp; 0x0f0f0f0f) &lt;&lt; 4) | ((bits &amp; 0xf0f0f0f0) &gt;&gt; 4);</div>
<div class="line">    bits = ((bits &amp; 0x33333333) &lt;&lt; 2) | ((bits &amp; 0xcccccccc) &gt;&gt; 2);</div>
<div class="line">    bits = ((bits &amp; 0x55555555) &lt;&lt; 1) | ((bits &amp; 0xaaaaaaaa) &gt;&gt; 1);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> float(bits) / float(0x100000000ULL);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// CUDA kernel evaluating the MDL sub-expression for one texel.</span></div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> __global__ <span class="keywordtype">void</span> evaluate_mat_expr(</div>
<div class="line">    float3 *out_buf,</div>
<div class="line">    Target_code_data *tc_data_list,</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> **arg_block_list,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height,</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_samples)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Determine x and y coordinates of texel to be evaluated and check</span></div>
<div class="line">    <span class="comment">// whether it is out of bounds (due to block padding)</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = blockIdx.x * blockDim.x + threadIdx.x;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = blockIdx.y * blockDim.y + threadIdx.y;</div>
<div class="line">    <span class="keywordflow">if</span> (x &gt;= width || y &gt;= height)</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Calculate position and texture coordinates for a 2x2 quad around the center of the world</span></div>
<div class="line">    <span class="keywordtype">float</span> step_x = 1.f / width;</div>
<div class="line">    <span class="keywordtype">float</span> step_y = 1.f / height;</div>
<div class="line">    <span class="keywordtype">float</span> pos_x = 2.0f * x * step_x - 1.0f;  <span class="comment">// [-1, 1)</span></div>
<div class="line">    <span class="keywordtype">float</span> pos_y = 2.0f * y * step_y - 1.0f;  <span class="comment">// [-1, 1)</span></div>
<div class="line">    <span class="keywordtype">float</span> tex_x = float(x) * step_x;         <span class="comment">// [0, 1)</span></div>
<div class="line">    <span class="keywordtype">float</span> tex_y = float(y) * step_y;         <span class="comment">// [0, 1)</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Assign materials in a checkerboard pattern</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> material_index =</div>
<div class="line">        ((<span class="keywordtype">unsigned</span> int)(tex_x * 4) ^ (<span class="keywordtype">unsigned</span> int)(tex_y * 4)) % mdl_functions_count;</div>
<div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tc_idx = mdl_target_code_indices[material_index];</div>
<div class="line">    <span class="keywordtype">char</span> <span class="keyword">const</span> *arg_block = arg_block_list[mdl_arg_block_indices[material_index]];</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Setup MDL material state (with only one texture space)</span></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="group__mi__neuray__mdl__compiler.html#ga485e6f52995285582fc6a4b4be266e4e" title="A float3 with derivatives. ">tct_deriv_float3</a> texture_coords[1] = {</div>
<div class="line">        { { tex_x, tex_y, 0.0f }, { step_x, 0.0f, 0.0f }, { 0.0f, step_y, 0.0f } } };</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">tct_float3</a> texture_coords[1]    = { { tex_x, tex_y, 0.0f } };</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">tct_float3</a> texture_tangent_u[1] = { { 1.0f, 0.0f, 0.0f } };</div>
<div class="line">    <a class="code" href="structmi_1_1math_1_1Vector__struct.html" title="Generic storage class template for math vector representations storing DIM elements of type T...">tct_float3</a> texture_tangent_v[1] = { { 0.0f, 1.0f, 0.0f } };</div>
<div class="line"></div>
<div class="line">    Mdl_state mdl_state = {</div>
<div class="line">        <span class="comment">/*normal=*/</span>                { 0.0f, 0.0f, 1.0f },</div>
<div class="line">        <span class="comment">/*geom_normal=*/</span>           { 0.0f, 0.0f, 1.0f },</div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">/*position=*/</span></div>
<div class="line">        {</div>
<div class="line">            { pos_x, pos_y, 0.0f },</div>
<div class="line">            { 2 * step_x, 0.0f, 0.0f },</div>
<div class="line">            { 0.0f, 2 * step_y, 0.0f }</div>
<div class="line">        },</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">/*position=*/</span>              { pos_x, pos_y, 0.0f },</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>        <span class="comment">/*animation_time=*/</span>        0.0f,</div>
<div class="line">        <span class="comment">/*texture_coords=*/</span>        texture_coords,</div>
<div class="line">        <span class="comment">/*tangent_u=*/</span>             texture_tangent_u,</div>
<div class="line">        <span class="comment">/*tangent_v=*/</span>             texture_tangent_v,</div>
<div class="line">        <span class="comment">/*text_results=*/</span>          NULL,</div>
<div class="line">        <span class="comment">/*ro_data_segment=*/</span>       tc_data_list[tc_idx].ro_data_segment,</div>
<div class="line">        <span class="comment">/*world_to_object=*/</span>       identity,</div>
<div class="line">        <span class="comment">/*object_to_world=*/</span>       identity,</div>
<div class="line">        <span class="comment">/*object_id=*/</span>             0,</div>
<div class="line">        <span class="comment">/*meters_per_scene_unit=*/</span> 1.0f</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    Tex_handler tex_handler;</div>
<div class="line">    tex_handler.vtable       = &amp;TEX_VTABLE;   <span class="comment">// only required in &#39;vtable&#39; mode, otherwise NULL</span></div>
<div class="line">    tex_handler.num_textures = tc_data_list[tc_idx].num_textures;</div>
<div class="line">    tex_handler.textures     = tc_data_list[tc_idx].textures;</div>
<div class="line"></div>
<div class="line">    <a class="code" href="structmi_1_1neuraylib_1_1Resource__data.html" title="The data structure providing access to resources for generated code. ">Resource_data</a> res_data_pair = {</div>
<div class="line">        NULL, <span class="keyword">reinterpret_cast&lt;</span>Texture_handler_base *<span class="keyword">&gt;</span>(&amp;tex_handler) };</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Super-sample the current texel with the given number of samples</span></div>
<div class="line">    float3 res = make_float3(0, 0, 0);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; num_samples; ++i) {</div>
<div class="line">        <span class="comment">// Calculate the offset for the current sample</span></div>
<div class="line">        <span class="keywordtype">float</span> offs_x = float(i) / num_samples * step_x;</div>
<div class="line">        <span class="keywordtype">float</span> offs_y = radinv2(i) * step_y;</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Update the position and the texture coordinate</span></div>
<div class="line"><span class="preprocessor">#ifdef ENABLE_DERIVATIVES</span></div>
<div class="line"><span class="preprocessor"></span>        mdl_state.position.val.x = pos_x + 2 * offs_x;</div>
<div class="line">        mdl_state.position.val.y = pos_y + 2 * offs_y;</div>
<div class="line">        texture_coords[0].val.x = tex_x + offs_x;</div>
<div class="line">        texture_coords[0].val.y = tex_y + offs_y;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>        mdl_state.position.x = pos_x + 2 * offs_x;</div>
<div class="line">        mdl_state.position.y = pos_y + 2 * offs_y;</div>
<div class="line">        texture_coords[0].x = tex_x + offs_x;</div>
<div class="line">        texture_coords[0].y = tex_y + offs_y;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        <span class="comment">// Add result for current sample</span></div>
<div class="line">        float3 cur_res;</div>
<div class="line">        mdl_functions[material_index](&amp;cur_res, &amp;mdl_state, &amp;res_data_pair, NULL, arg_block);</div>
<div class="line">        res.x += cur_res.x;</div>
<div class="line">        res.y += cur_res.y;</div>
<div class="line">        res.z += cur_res.z;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Calculate average over all samples and apply gamma correction</span></div>
<div class="line">    res.x = powf(res.x / num_samples, 1.f / 2.2f);</div>
<div class="line">    res.y = powf(res.y / num_samples, 1.f / 2.2f);</div>
<div class="line">    res.z = powf(res.z / num_samples, 1.f / 2.2f);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Write result to output buffer</span></div>
<div class="line">    out_buf[y * width + x] = res;</div>
<div class="line">}</div>
</div><!-- fragment --><div align="right"> [<a class="el" href="mi_neuray_example_execution_native.html">Previous</a>] [<a class="el" href="mi_neuray_examples.html">Up</a>] [<a class="el" href="mi_neuray_example_execution_glsl.html">Next</a>] </div> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.4-->
<!-- start footer part -->
<div id="nav-path">
<span class="footeritem">5&#160;April&#160;2022,&#160;20:40, rev.358266</span>
<span class="footeritem"><a href="https://www.nvidia.com/en-us/about-nvidia/legal-info/" target="_blank" shape="rect">&copy; 2022 NVIDIA&nbsp;Corporation.</a> All rights reserved.</span>
</div>
</body>
</html>
